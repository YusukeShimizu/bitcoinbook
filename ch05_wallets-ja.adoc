//FIXME:reduce difficulty / we ramp up too quick Lesmes feedback
[[ch05_wallets]]
== ウォレットの復元

プライベートキーとパブリックキーのペアを作成することは、Bitcoin ウォレットがビットコインを受け取ったり送ったりするための重要な部分です。しかし、プライベートキーへのアクセスを失うと、対応するパブリックキーに受け取ったビットコインを誰も使えなくなる可能性があります。ウォレットやプロトコルの開発者たちは、問題が発生した後にユーザがビットコインへのアクセスを復元できるようにしつつ、通常時のセキュリティを損なわないシステムを設計するために取り組んできました。

この章では、ウォレットがデータの損失を金銭の損失にしないために採用しているさまざまな方法を検討します。ほとんど欠点がなく、現代のウォレットに普遍的に採用されている解決策もあります。これらの解決策はベストプラクティスとして単純に推奨します。他の解決策には利点と欠点があり、異なるウォレットの作者が異なるトレードオフを行っています。その場合、利用可能なさまざまなオプションを説明します。

=== 独立したキー生成

++++
<p class="fix_tracking2">
現金のウォレットはその現金を保持するため、多くの人が誤って Bitcoin ウォレットがビットコインを含んでいると信じてしまうのも無理はありません。実際、多くの人が Bitcoin ウォレットと呼ぶものは、ウォレットアプリケーションと区別するために私たちが<em>ウォレットデータベース</em>と呼ぶもので、キーのみを含んでいます。これらのキーはブロックチェーンに記録されたビットコインに関連付けられています。Bitcoin のフルノードに対してキーを制御していることを証明することで、関連するビットコインを使うことができます。
</p>
++++

シンプルなウォレットデータベースには、ビットコインを受け取るためのパブリックキーと、それらのビットコインを送るために必要な署名を作成するためのプライベートキーの両方が含まれています。他のウォレットのデータベースには、パブリックキーのみ、または送金トランザクションを承認するために必要なプライベートキーの一部のみが含まれている場合があります。これらのウォレットアプリケーションは、ハードウェア署名デバイスやマルチシグネチャスキームの他のウォレットなどの外部ツールと連携して必要な署名を生成します。

ウォレットアプリケーションは、後で使用する予定のウォレットキーを独立して生成することができます。これは <<Type0_wallet>> に示されています。初期のビットコインウォレットアプリケーションはすべてこの方法を採用していましたが、新しいキーを生成して配布するたびにウォレットデータベースをバックアップする必要がありました。これは、新しい支払いを受け取るために新しいアドレスを生成するたびに行うことができました。タイミングよくウォレットデータベースをバックアップしないと、バックアップされていないキーに受け取った資金へのアクセスを失うことになります。

独立して生成された各キーについて、ユーザは約 32 バイトとオーバーヘッドをバックアップする必要がありました。一部のユーザやウォレットアプリケーションは、バックアップが必要なデータ量を最小限に抑えるために、単一のキーのみを使用しようとしました。それは安全である可能性がありますが、そのユーザと取引するすべての人のプライバシーを著しく低下させます。プライバシーを重視する人々やその仲間たちは、各取引ごとに新しいキーペアを作成し、デジタルメディアを使用してのみ合理的にバックアップできるウォレットデータベースを作成しました。

[[Type0_wallet]]
[role="width-60"]
.非決定論的キー生成：ウォレットデータベースに保存された独立して生成されたキーのコレクション。
image::images/mbc3_0501.png["Non-Deterministic Wallet"]

現代のウォレットアプリケーションは、キーを独立して生成するのではなく、単一のランダムシードから繰り返し可能な（決定論的な）アルゴリズムを使用してキーを導出します。

==== 決定論的キー生成

ハッシュ関数は、同じ入力を与えられたときに常に同じ出力を生成しますが、入力がわずかに変わると出力も異なります。関数が暗号的に安全である場合、新しい入力を知っていても新しい出力を予測することはできないはずです。

これにより、1 つのランダムな値を取り、それをほぼ無限の数の見かけ上ランダムな値に変換することができます。さらに便利なのは、後で同じハッシュ関数を同じ入力（_seed_ と呼ばれる）で使用すると、同じ見かけ上ランダムな値が生成されることです。

----
# エントロピー（ランダム性）を収集する
$ dd if=/dev/random count=1 status=none | sha256sum
f1cc3bc03ef51cb43ee7844460fa5049e779e7425a6349c8e89dfbb0fd97bb73  -

# ランダムな値をシードに設定する
$ seed=f1cc3bc03ef51cb43ee7844460fa5049e779e7425a6349c8e89dfbb0fd97bb73

# 派生値を決定論的に生成する
$ for i in {0..2} ; do echo "$seed + $i" | sha256sum ; done
50b18e0bd9508310b8f699bad425efdf67d668cb2462b909fdb6b9bd2437beb3  -
a965dbcd901a9e3d66af11759e64a58d0ed5c6863e901dfda43adcd5f8c744f3  -
19580c97eb9048599f069472744e51ab2213f687d4720b0efc5bb344d624c3aa  -
----

派生値を秘密鍵として使用する場合、以前に使用したアルゴリズムとシード値を使って、まったく同じ秘密鍵を後で生成することができます。決定論的な鍵生成を利用するユーザは、シードと使用した決定論的アルゴリズムの参照を記録するだけで、ウォレット内のすべての鍵をバックアップできます。例えば、アリスが 100 万ビットコインを 100 万の異なるアドレスで受け取っている場合でも、後でそれらのビットコインにアクセスするためにバックアップが必要なのは次のものだけです。

----
f1cc 3bc0 3ef5 1cb4 3ee7 8444 60fa 5049
e779 e742 5a63 49c8 e89d fbb0 fd97 bb73
----

基本的な逐次決定論的鍵生成の論理図は <<Type1_wallet>> に示されています。しかし、現代のウォレットアプリケーションは、対応する秘密鍵とは別に公開鍵を派生させることができる、より巧妙な方法を採用しており、秘密鍵を公開鍵よりも安全に保存することが可能です。

[[Type1_wallet]]
[role="width-70"]
.決定論的キー生成：ウォレットデータベースのシードから派生した決定論的なキーのシーケンス。
image::images/mbc3_0502.png["決定論的ウォレット"]


[[public_child_key_derivation]]
==== 公開子キーの導出

<<public_key_derivation>> では、楕円曲線暗号 (ECC) を使用して秘密鍵から公開鍵を作成する方法を学びました。楕円曲線上の操作は直感的ではありませんが、通常の算術で使用される加算、減算、乗算の操作に類似しています。つまり、公開鍵に加算や減算を行ったり、乗算を行ったりすることが可能です。<<public_key_derivation>> で使用した、生成点 (_G_) を用いて秘密鍵 (_k_) から公開鍵 (_K_) を生成する操作を考えてみましょう：

[latexmath]
++++
\begin{equation}
{K = k \times G}
\end{equation}
++++

同じ値を方程式の両辺に加えるだけで、派生キーのペア、つまり子キーのペアを作成することが可能です：

////
[latexmath]
++++
\begin{equation}
K + (123 \times G) =\!\!\!= (k + 123) \times G
\end{equation}
++++
////

++++
<div data-type="equation">
<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="upper K plus left-parenthesis 123 times upper G right-parenthesis equals equals left-parenthesis k plus 123 right-parenthesis times upper G" display="block">
  <mrow>
    <mi>K</mi>
    <mo>+</mo>
    <mo>(</mo>
    <mn>123</mn>
    <mo>×</mo>
    <mi>G</mi>
    <mo>)</mo>
    <mo>==</mo>
    <mo>(</mo>
    <mi>k</mi>
    <mo>+</mo>
    <mn>123</mn>
    <mo>)</mo>
    <mo>×</mo>
    <mi>G</mi>
  </mrow>
</math>
</div>
++++


[TIP]
====
この本全体の方程式では、変数の値が計算される操作、例えば _K_ = _k_ × _G_ のような場合には単一の等号を使用します。方程式の両辺が等価であることを示す場合や、両辺が等価でない場合に操作が false (真ではない) を返すべきであることを示す場合には、二重の等号を使用します。
====

この興味深い結果として、公開鍵に 123 を加えることが完全に公開された情報を使って行えるということがあります。例えば、アリスが公開鍵 _K_ を生成してボブに渡します。ボブは秘密鍵を知りませんが、グローバル定数 _G_ を知っているので、任意の値を公開鍵に加えて派生公開子鍵を生成できます。その後、ボブがアリスに公開鍵に加えた値を伝えると、アリスは同じ値を秘密鍵に加えて、ボブが作成した公開子鍵に対応する派生秘密子鍵を生成できます。

言い換えると、親秘密鍵について何も知らなくても、子公開鍵を作成することが可能です。公開鍵に加えられる値は _key tweak_ として知られています。キーの調整を生成するために決定論的なアルゴリズムが使用される場合、秘密鍵を知らない人でも、単一の親公開鍵から事実上無制限の公開子鍵のシーケンスを作成することが可能です。親秘密鍵を管理する人は、同じキーの調整を使用して、対応するすべての秘密子鍵を作成できます。

この技術は、ウォレットアプリケーションのフロントエンド（秘密鍵を必要としない）と署名操作（秘密鍵を必要とする）を分離するために一般的に使用されます。例えば、アリスのフロントエンドは、彼女に支払いを希望する人々に公開鍵を配布します。後で、受け取ったお金を使いたいとき、彼女は使用したキーの調整を _hardware signing device_（時には混乱を招くこともある _hardware wallet_ とも呼ばれる）に提供します。このデバイスは彼女の元の秘密鍵を安全に保管しています。ハードウェア署名者は調整を使用して必要な子秘密鍵を導出し、それを使用してトランザクションに署名し、署名されたトランザクションを Bitcoin ネットワークにブロードキャストするためにセキュリティの低いフロントエンドに返します。

公開子鍵の導出は、以前に見た <<Type1_wallet>> に似た線形シーケンスの鍵を生成できますが、現代のウォレットアプリケーションは、単一のシーケンスではなく鍵のツリーを提供するためにもう一つのトリックを使用します。詳細は次のセクションで説明します。

[[hd_wallets]]
==== 階層的決定性 (HD) キー生成 (BIP32)

私たちが知っている限り、すべての現代的な Bitcoin ウォレットはデフォルトで階層的決定性 (HD) キー生成を使用しています。この標準は BIP32 で定義されており、決定性キー生成とオプションの公開子キー導出を使用してキーのツリーを生成するアルゴリズムです。このツリーでは、任意のキーが一連の子キーの親になることができ、その子キーのいずれかがさらに別の一連の子キー（元のキーの孫）の親になることができます。ツリーの深さに任意の制限はありません。このツリー構造は <<Type2_wallet>> に示されています。

[[Type2_wallet]]
.HD ウォレット：単一のシードから生成されたキーのツリー。
image::images/mbc3_0503.png["HD wallet"]

ツリー構造は、特定のサブキーのブランチが受信支払いを受け取るために使用され、別のブランチが送信支払いからの釣銭を受け取るために使用される場合など、追加の組織的な意味を表現するために使用できます。キーのブランチは、企業環境でも使用でき、異なるブランチを部門、子会社、特定の機能、または会計カテゴリに割り当てることができます。

HD ウォレットの詳細な探求は <<hd_wallet_details>> で提供します。

==== シードとリカバリーコード

HD ウォレットは、単一のシードから派生した多くのキーを管理するための非常に強力なメカニズムです。ウォレットデータベースが破損したり失われたりした場合でも、元のシードを使用してウォレットのすべての秘密鍵を再生成できます。しかし、他の誰かがあなたのシードを手に入れた場合、彼らもすべての秘密鍵を生成でき、シングルシグウォレットからすべてのビットコインを盗むことができ、マルチシグウォレットのビットコインのセキュリティを低下させる可能性があります。このセクションでは、バックアップをより簡単かつ安全にすることを目的としたいくつかの _リカバリーコード_ を見ていきます。

シードは通常 128 ビットから 256 ビットの大きな乱数ですが、ほとんどのリカバリーコードは人間の言語の単語を使用します。単語を使用する動機の大部分は、リカバリーコードを覚えやすくするためでした。たとえば、<<hex_seed_vs_recovery_words>> に示されているように、16 進数と単語の両方でエンコードされたリカバリーコードを考えてみてください。

[[hex_seed_vs_recovery_words]]
.16 進数と英語の単語でエンコードされたシード
====
----
16 進数でエンコード:
0C1E 24E5 9177 79D2 97E1 4D45 F14E 1A1A

単語でエンコード:
army van defense carry jealous true
garbage claim echo media make crunch
----
====

リカバリーコードを覚えておくことが強力な機能となる場合があります。たとえば、物理的な持ち物（紙に書かれたリカバリーコードなど）を外部の第三者に押収されたり検査されたりすることなく持ち運ぶことができない場合です。しかし、ほとんどの場合、記憶だけに頼るのは危険です：

- リカバリーコードを忘れて元のウォレットデータベースへのアクセスを失った場合、ビットコインは永遠に失われます。

- あなたが死亡したり重傷を負ったりして、相続人が元のウォレットデータベースにアクセスできない場合、彼らはビットコインを相続できません。

- 誰かがあなたがビットコインにアクセスできるリカバリーコードを記憶していると思った場合、そのコードを開示するよう強制されるかもしれません。この記事の執筆時点で、ビットコインの貢献者である Jameson Lopp は、ビットコインやその他のデジタル資産の疑わしい所有者に対する 100 件以上の物理的攻撃を
  https://oreil.ly/aw5XM[記録]
  しており、少なくとも 3 件の死亡事件や、拷問、誘拐、家族への脅迫が行われた事例が多数あります。

[TIP]
====
覚えやすいように設計されたリカバリーコードを使用する場合でも、書き留めることを強くお勧めします。
====

この記事の執筆時点で、さまざまな種類のリカバリーコードが広く使用されています：

BIP39::
  過去 10 年間で最も人気のあるリカバリーコード生成方法である BIP39 は、ランダムなバイト列を生成し、それにチェックサムを追加し、データを 12 から 24 語の一連の単語にエンコードします（ユーザの母国語にローカライズされることもあります）。これらの単語（およびオプションのパスフレーズ）は、*キー・ストレッチング関数*を通して処理され、その出力がシードとして使用されます。BIP39 リカバリーコードにはいくつかの欠点があり、後のスキームでそれを解決しようとしています。

Electrum v2::
  Electrum ウォレット（バージョン 2.0 以上）で使用されるこの単語ベースのリカバリーコードは、BIP39 に比べていくつかの利点があります。すべての互換プログラムのすべてのバージョンで実装されなければならないグローバルな単語リストに依存せず、リカバリーコードにはバージョン番号が含まれており、信頼性と効率が向上しています。BIP39 と同様に、オプションのパスフレーズ（Electrum では*シード拡張*と呼ばれます）をサポートし、同じキー・ストレッチング関数を使用します。

Aezeed::
  LND ウォレットで使用されるこの単語ベースのリカバリーコードは、BIP39 に対する改善を提供します。内部バージョン番号が含まれており、ウォレットアプリケーションのアップグレードに関するいくつかの問題を解消します（Electrum v2 のバージョン番号のように）。もう一つのバージョン番号は外部にあり、リカバリーコードの基礎となる暗号特性を変更するためにインクリメントできます。また、リカバリーコードには*ウォレットの誕生日*が含まれており、ユーザがウォレットデータベースを作成した日付を参照します。これにより、ウォレットに関連するすべての資金をブロックチェーン全体をスキャンせずに見つけることができ、特にプライバシー重視の軽量クライアントにとって便利です。パスフレーズの変更やリカバリーコードの他の側面の変更を、資金を新しいシードに移動することなくサポートしています。ユーザは新しいリカバリーコードをバックアップするだけで済みます。Electrum v2 と比較した場合の欠点として、BIP39 と同様に、バックアップとリカバリーソフトウェアの両方が同じ単語リストをサポートしている必要がある点があります。

[role="less_space pagebreak-before"]
Muun::
  Muunウォレットで使用されるMuunリカバリーコードは、複数のキーで署名することをデフォルトとする支出トランザクションを必要とします。これは非単語コードであり、追加情報（現在MuunがPDFで提供しています）を伴う必要があります。このリカバリーコードはシードとは無関係で、代わりにPDFに含まれる秘密鍵を復号するために使用されます。これはBIP39、Electrum v2、およびAezeedリカバリーコードと比較して扱いにくいですが、Lightning Network (LN) サポート、出力スクリプトディスクリプタ、ミニスクリプトなど、新しいウォレットで一般的になりつつある新技術や標準をサポートします。

SLIP39::
  BIP39の後継であり、いくつかの同じ著者によって作成されたSLIP39は、単一のシードを複数のリカバリーコードを使用して分散することを可能にします。これらのコードは異なる場所（または異なる人）に保管できます。リカバリーコードを作成する際に、シードを回復するために必要なコードの数を指定できます。例えば、5つのリカバリーコードを作成し、そのうち3つだけでシードを回復することができます。SLIP39はオプションのパスフレーズをサポートし、グローバルな単語リストに依存し、バージョン管理を直接提供しません。

[NOTE]
====
この本の執筆中に、SLIP39に似たリカバリーコードを分散する新しいシステムであるCodex32が提案されました。Codex32は、印刷された指示、はさみ、精密ナイフ、真鍮のファスナー、ペンだけでリカバリーコードを作成および検証することを可能にします。プライバシーと数時間の余暇も必要です。あるいは、コンピュータを信頼する人は、デジタルデバイス上のソフトウェアを使用してリカバリーコードを瞬時に作成できます。最大31のリカバリーコードを作成し、異なる場所に保管し、シードを回復するために必要なコードの数を指定できます。新しい提案として、Codex32の詳細はこの本が出版される前に大きく変わる可能性があるため、分散リカバリーコードに興味のある読者はそのhttps://oreil.ly/Xx_Zq[現在の状況]を調査することをお勧めします。
====


.リカバリーコードのパスフレーズ
****
BIP39、((("ウォレット", "リカバリーコード", "パスフレーズ", id="wallet-recovery-passphrase")))((("リカバリーコード", "パスフレーズ", id="recovery-code-passphrase")))((("パスフレーズ (リカバリーコード用)", id="passphrase")))Electrum v2、Aezeed、および SLIP39 のスキームはすべて、オプションのパスフレーズを使用することができます。このパスフレーズを記憶の中だけに保存する場合、それはリカバリーコードを記憶するのと同じ利点と欠点を持ちます。しかし、パスフレーズがリカバリーコードによって使用される方法には、さらに特有のトレードオフがあります。

3 つのスキーム (BIP39、Electrum v2、および SLIP39) は、データ入力ミスを防ぐためのチェックサムにオプションのパスフレーズを含めていません。すべてのパスフレーズ (パスフレーズを使用しない場合も含む) は、BIP32 キーのツリーのシードを生成しますが、それらは同じツリーにはなりません。異なるパスフレーズは異なるキーを生成します。それは視点によってはプラスにもマイナスにもなり得ます。

- プラス面としては、誰かがあなたのリカバリーコード (ただしパスフレーズは含まない) を取得した場合、有効な BIP32 キーのツリーを見ることができます。もしその事態に備えて、パスフレーズなしのツリーにビットコインを送っていた場合、そのお金は盗まれてしまいます。ビットコインの一部が盗まれることは通常悪いことですが、それはリカバリーコードが漏洩したという警告を提供し、調査して是正措置を取ることができます。同じリカバリーコードに対して複数のパスフレーズを作成し、それらがすべて有効に見える能力は、*もっともらしい否認* の一種です。

- マイナス面としては、攻撃者にリカバリーコード (パスフレーズの有無にかかわらず) を強要され、それが彼らが期待したビットコインの量を生み出さない場合、彼らはさらに多くのビットコインにアクセスできる別のパスフレーズを与えるまで、あなたに強要を続けるかもしれません。もっともらしい否認を設計することは、攻撃者にすべての情報を開示したことを証明する方法がないことを意味するため、すべてのビットコインを渡した後でも、彼らは強要を続けるかもしれません。

- もう一つのマイナス点は、エラー検出の量が減少することです。バックアップから復元する際に少し間違ったパスフレーズを入力しても、ウォレットはその間違いを警告できません。残高を期待している場合、再生成されたキー ツリーに対してウォレットアプリケーションがゼロ残高を表示すると、何かが間違っていることがわかります。しかし、初心者のユーザは自分のお金が永久に失われたと思い込み、回復コードを諦めて捨ててしまうなどの愚かな行動をとるかもしれません。また、実際にゼロ残高を期待していた場合、間違いを犯した後も何年もウォレットアプリケーションを使用し続け、次回正しいパスフレーズで復元したときにゼロ残高を確認することになるかもしれません。以前にどのようなタイプミスをしたのかを特定できない限り、資金は失われます。

他のスキームとは異なり、Aezeed シード暗号化スキームはオプションのパスフレーズを認証し、誤った値を提供するとエラーを返します。これにより、もっともらしい否認が排除され、エラー検出が追加され、パスフレーズが公開されたことを証明することが可能になります。

多くのユーザや開発者はどのアプローチが優れているかについて意見が分かれており、もっともらしい否認を強く支持する人もいれば、エラー検出が初心者やストレス下にある人に与える安全性の向上を好む人もいます。回復コードが広く使用され続ける限り、この議論は続くと考えられます。

==== 非キー データのバックアップ

ウォレットデータベースで最も重要なデータはプライベートキーです。プライベートキーへのアクセスを失うと、ビットコインを使う能力を失います。決定的なキー導出と回復コードは、キーとそれが管理するビットコインをバックアップおよび回復するための合理的に堅牢なソリューションを提供します。しかし、多くのウォレットデータベースはキーだけでなく、送信または受信したすべてのトランザクションに関するユーザ提供の情報も保存していることを考慮することが重要です。

たとえば、ボブがアリスに請求書を送る一環として新しいアドレスを作成するとき、彼は生成したアドレスに*ラベル*を追加します。これにより、彼が受け取る他の支払いと区別することができます。アリスがボブのアドレスに支払うときも、同じ理由でトランザクションにボブへの支払いとしてラベルを付けます。一部のウォレットは、トランザクションに現在の為替レートなどの有用な情報を追加することもあります。これは、一部の法域で税金を計算する際に役立ちます。これらのラベルは完全に自分のウォレット内に保存され、ネットワークと共有されないため、プライバシーが保護され、不要な個人データがブロックチェーンに含まれません。例については <<alice_tx_labels>> を参照してください。

++++
<table id="alice_tx_labels">
<caption>アリスのトランザクション履歴（各トランザクションにラベル付き）</caption>
<thead>
<tr>
<th>日付</th>
<th>ラベル</th>
<th>BTC</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>2023-01-01</p></td>
<td><p>ジョーからビットコインを購入</p></td>
<td><p>+0.00100</p></td>
</tr>
<tr>
<td><p>2023-01-02</p></td>
<td><p>ポッドキャストのためにボブに支払い</p></td>
<td><p>−0.00075</p></td>
</tr>
</tbody>
</table>
++++

しかし、アドレスとトランザクションのラベルは各ユーザのウォレットデータベースにのみ保存され、決定論的ではないため、リカバリーコードだけでは復元できません。リカバリーがシードベースのみの場合、ユーザが見ることができるのは、おおよそのトランザクション時間とビットコインの金額のリストだけです。これにより、過去にどのようにお金を使ったかを把握するのが非常に難しくなることがあります。1年前の銀行やクレジットカードの明細を見直すときに、すべてのトランザクションの日付と金額が記載されているが、「説明」欄が空白であると想像してみてください。

ウォレットは、ユーザにラベルデータをバックアップする便利な方法を提供するべきです。それは明らかに思えますが、リカバリーコードを簡単に作成して使用できるようにする一方で、ラベルデータをバックアップまたは復元する方法を提供しない広く使用されているウォレットアプリケーションがいくつかあります。

さらに、ウォレットアプリケーションがラベルを他のアプリケーション（例：会計ソフトウェア）で使用できるように標準化された形式でエクスポートする機能を提供することも有用かもしれません。その形式の標準は BIP329 で提案されています。

ウォレットアプリケーションが基本的な Bitcoin サポートを超えて追加のプロトコルを実装する場合、他のデータを保存する必要があるかもしれません。例えば、2023年現在、増加する数のアプリケーションが Lightning Network (LN) を介した送受信トランザクションのサポートを追加しています。LN プロトコルは、データ損失時に資金を回復する方法として _静的チャネルバックアップ_ を提供しますが、結果を保証することはできません。ウォレットが接続するノードがデータを失ったことに気づいた場合、ビットコインを盗まれる可能性があります。もしあなたとノードの両方がウォレットデータベースを同時に失い、どちらも適切なバックアップを持っていない場合、両者とも資金を失うことになります。

再度言いますが、ユーザとウォレットアプリケーションは、リカバリーコードをバックアップするだけでは不十分です。

いくつかのウォレットアプリケーションが実装している解決策の一つは、シードから派生したキーの一つで暗号化されたウォレットデータベースの完全なバックアップを頻繁かつ自動的に作成することです。ビットコインのキーは推測不可能であり、現代の暗号化アルゴリズムは非常に安全と考えられているため、シードを生成できる人以外は暗号化されたバックアップを開くことはできません。これにより、バックアップをクラウドホスティングサービスやランダムなネットワークピアのような信頼できないコンピュータに保存しても安全です。

後で、元のウォレットデータベースが失われた場合、ユーザはリカバリーコードをウォレットアプリケーションに入力してシードを復元できます。その後、アプリケーションは最新のバックアップファイルを取得し、暗号化キーを再生成し、バックアップを復号化し、ユーザのラベルや追加のプロトコルデータを復元できます。

==== キー導出パスのバックアップ

BIP32 キーのツリーでは、約 40 億の第一レベルキーが存在します。それぞれのキーは独自の 40 億の子を持つことができ、その子もそれぞれ 40 億の子を持つ可能性があります。ウォレットアプリケーションが BIP32 ツリー内のすべての可能なキーのほんの一部を生成することは不可能です。つまり、データ損失からの回復には、リカバリーコード、シードを取得するためのアルゴリズム (例：BIP39)、および決定的なキー導出アルゴリズム (例：BIP32) を知っているだけでは不十分であり、ウォレットアプリケーションが特定のキーを生成するために使用したキーのツリー内のパスを知っている必要があります。

この問題に対しては二つの解決策が採用されています。最初の解決策は標準パスを使用することです。ウォレットアプリケーションが生成したいアドレスに関連する変更があるたびに、誰かがどのキー導出パスを使用するかを定義する BIP を作成します。例えば、BIP44 は P2PKH スクリプト（レガシーアドレス）のキーに使用するパスとして `m/44'/0'/0'` を定義しています。この標準を実装するウォレットアプリケーションは、初回起動時やリカバリーコードからの復元後にそのパスのキーを使用します。この解決策を _暗黙のパス_ と呼びます。BIP によって定義されたいくつかの人気のある暗黙のパスは <<bip_implicit_paths>> に示されています。

++++
<table id="bip_implicit_paths">
<caption>さまざまな BIP によって定義された暗黙のスクリプトパス</caption>
<thead>
<tr>
<th>標準</th>
<th>スクリプト</th>
<th>BIP32 パス</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>BIP44</p></td>
<td><p>P2PKH</p></td>
<td><p><code>m/44'/0'/0'</code></p></td>
</tr>
<tr>
<td><p>BIP49</p></td>
<td><p>ネストされた P2WPKH</p></td>
<td><p><code>m/49'/1'/0'</code></p></td>
</tr>
<tr>
<td><p>BIP84</p></td>
<td><p>P2WPKH</p></td>
<td><p><code>m/84'/0'/0'</code></p></td>
</tr>
<tr>
<td><p>BIP86</p></td>
<td><p>P2TR 単一キー</p></td>
<td><p><code>m/86'/0'/0'</code></p></td>
</tr>
</tbody>
</table>
++++

二つ目の解決策は、リカバリーコードと共にパス情報をバックアップし、どのスクリプトにどのパスが使用されているかを明確にすることです。この解決策を _明示的なパス_ と呼びます。

暗黙のパスの利点は、ユーザが使用するパスを記録しておく必要がないことです。ユーザが以前使用していたのと同じウォレットアプリケーションにリカバリーコードを入力すると、同じバージョンまたはそれ以上のバージョンであれば、以前使用していたのと同じパスのキーを自動的に再生成します。

暗黙のスクリプトの欠点は、その柔軟性の欠如です。リカバリーコードが入力されると、ウォレットアプリケーションはサポートするすべてのパスのキーを生成し、それらのキーに関与するトランザクションをブロックチェーンでスキャンしなければなりません。そうしないと、ユーザのすべてのトランザクションを見つけられない可能性があります。これは、多くの機能をサポートするウォレットで、それぞれが独自のパスを持っている場合に、ユーザがその機能の一部しか試していない場合には無駄になります。

バージョン番号を含まない暗黙的なパス復元コード（BIP39 や SLIP39 など）の場合、古いパスのサポートを削除した新しいウォレットアプリケーションでは、復元プロセス中にユーザに対して一部の資金が見つからない可能性があることを警告できません。逆に、ユーザが古いソフトウェアに復元コードを入力した場合も同様の問題が発生します。新しいパスに資金を受け取った可能性があるためです。Electrum v2 や Aezeed のようにバージョン情報を含む復元コードは、ユーザが古いまたは新しい復元コードを入力していることを検出し、適切なリソースに案内できます。

暗黙的なパスの最終的な結果として、普遍的な情報（標準化されたパスなど）やシードから派生した情報（鍵など）のみを含めることができます。特定のユーザに固有の重要な非決定論的情報は、復元コードを使用して復元することができません。例えば、アリス、ボブ、キャロルがそれぞれの署名のうち 2 人分でのみ資金を使えるように受け取った場合、アリスはボブまたはキャロルの署名だけで資金を使うことができますが、ブロックチェーン上で共同資金を見つけるためには両方の公開鍵が必要です。つまり、3 人全員がそれぞれの公開鍵をバックアップしなければなりません。マルチシグネチャやその他の高度なスクリプトが Bitcoin で一般的になるにつれて、暗黙的なパスの柔軟性の欠如はより重要になります。

明示的なパスの利点は、どの鍵をどのスクリプトで使用すべきかを正確に記述できることです。古いスクリプトをサポートする必要がなく、後方互換性や前方互換性の問題もありません。他のユーザの公開鍵のような追加情報も直接含めることができます。欠点は、復元コードと一緒に追加情報をバックアップする必要があることです。追加情報は通常、ユーザのセキュリティを損なうことはないため、復元コードほどの保護は必要ありませんが、プライバシーを低下させる可能性があり、ある程度の保護は必要です。

ほとんどのウォレットアプリケーションは、明示的なパスを使用する際に、BIPs 380, 381, 382, 383, 384, 385, 386, 389 で指定された _output script descriptors_ 標準（短縮して _descriptors_ と呼ばれます）を使用しています。デスクリプタはスクリプトとそれに使用する鍵（または鍵パス）を記述します。いくつかのデスクリプタの例は <<sample_descriptors>> に示されています。

++++
<table id="sample_descriptors">
<caption>Bitcoin Core ドキュメントからのサンプル記述子（省略あり）</caption>
<thead>
<tr>
<th>記述子</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>pkh(02c6…​9ee5)</code></p></td>
<td><p>提供された公開鍵のための P2PKH スクリプト</p></td>
</tr>
<tr>
<td><p><code>sh(multi(2,022f…​2a01,03ac…​ccbe))</code></p></td>
<td><p>これらの2つの鍵に対応する2つの署名を必要とする P2SH マルチシグネチャ</p></td>
</tr>
<tr>
<td><p><code>pkh([d34db33f/44'/0'/0']xpub6ERA…​RcEL/1/*)</code></p></td>
<td><p>BIP32 <code>d34db33f</code> のための P2PKH スクリプトで、パス <code>M/44'/0'/0'</code> にある拡張公開鍵 (xpub) <code>xpub6ERA…​RcEL</code> を使用し、その xpub の <code>M/1/*</code> にある鍵を使用します</p></td>
</tr>
</tbody>
</table>
++++

長い間、単一署名スクリプト専用に設計されたウォレットアプリケーションは、暗黙のパスを使用する傾向にありました。複数署名やその他の高度なスクリプト用に設計されたウォレットアプリケーションは、記述子を使用して明示的なパスのサポートを採用することが増えています。両方を行うアプリケーションは通常、暗黙のパスの標準に準拠し、また記述子を提供します。

=== ウォレット技術スタックの詳細

現代のウォレットの開発者は、ユーザがバックアップを作成し使用するのを助けるために、さまざまな技術から選ぶことができます。そして毎年新しいソリューションが登場します。この章の前半で説明した各オプションについて詳しく説明する代わりに、2023年初頭にウォレットで最も広く使用されていると考えられる技術スタックに焦点を当てます。

- BIP39 リカバリーコード
- BIP32 HD 鍵導出
- BIP44 スタイルの暗黙のパス

これらの標準はすべて2014年以前から存在しており、それらを使用するための追加リソースを見つけるのに問題はないでしょう。しかし、もし大胆な気持ちがあるなら、追加の機能や安全性を提供する可能性のある、より現代的な標準を調査することをお勧めします。

[[recovery_code_words]]
==== BIP39 リカバリーコード

BIP39 リカバリーコードは、決定性ウォレットを導出するためのシードとして使用されるランダムな数を表す（エンコードする）単語の列です。単語の列はシードを再作成するのに十分であり、そこからすべての導出された鍵を再作成できます。BIP39 リカバリーコードを実装したウォレットアプリケーションは、ウォレットを初めて作成する際にユーザに 12 から 24 の単語の列を表示します。この単語の列がウォレットのバックアップであり、同じまたは互換性のあるウォレットアプリケーションで、すべての鍵を復元し再作成するために使用できます。リカバリーコードは読みやすく、正確に書き写すことが容易なため、ユーザがバックアップを取りやすくします。

[TIP]
====
リカバリーコードは「ブレインウォレット」と混同されることがよくありますが、同じものではありません。主な違いは、ブレインウォレットはユーザが選んだ単語で構成されるのに対し、リカバリーコードはウォレットによってランダムに作成され、ユーザに提示される点です。この重要な違いにより、リカバリーコードははるかに安全です。なぜなら、人間は非常に不規則なランダム性の源だからです。
====

BIP39 はリカバリーコード標準の一つの実装であることに注意してください。BIP39 は Trezor ハードウェアウォレットの背後にある会社によって提案され、多くの他のウォレットアプリケーションと互換性がありますが、すべてではありません。

BIP39 はリカバリーコードとシードの作成を定義しており、ここでは 9 つのステップで説明します。明確にするために、プロセスは 2 つの部分に分けられています。ステップ 1 から 6 は <<generating_recovery_words>> に示され、ステップ 7 から 9 は <<recovery_to_seed>> に示されています。

[[generating_recovery_words]]
===== リカバリーコードの生成

リカバリーコードは、BIP39 で定義された標準化されたプロセスを使用してウォレットアプリケーションによって自動的に生成されます。ウォレットはエントロピーの源から始まり、チェックサムを追加し、次にエントロピーを単語リストにマッピングします。

1. 128 ビットから 256 ビットのランダムなシーケンス（エントロピー）を作成します。

2. ランダムシーケンスの SHA256 ハッシュの最初の (エントロピー長/32) ビットを取り、チェックサムを作成します。

3. チェックサムをランダムシーケンスの末尾に追加します。

4. 結果を 11 ビット長のセグメントに分割します。

5. 各 11 ビットの値を、2,048 語の事前定義された辞書から単語にマッピングします。

6. リカバリーコードは単語のシーケンスです。

<<generating_entropy_and_encoding>> は、エントロピーが BIP39 リカバリーコードを生成するためにどのように使用されるかを示しています。

[[generating_entropy_and_encoding]]
.エントロピーの生成とリカバリーコードとしてのエンコード
image::images/mbc3_0504.png["エントロピーの生成とリカバリーコードとしてのエンコード"]

<<table_4-5>> は、エントロピーデータのサイズとリカバリーコードの長さの関係を示しています。((("ウォレット", "リカバリーコード", "生成", startref="wallet-recovery-bip39-generate")))((("リカバリーコード", "生成", startref="recovery-code-bip39-generate")))((("BIP39 リカバリーコード", "生成", primary-sortas="BIP039", startref="bip39-recovery-generate")))((("エントロピー", "リカバリーコード生成", startref="entropy-recovery-generate"))) 単語で。

++++
<table id="table_4-5">
<caption>BIP39: エントロピーと単語の長さ</caption>
<thead>
<tr>
<th>エントロピー (ビット)</th>
<th>チェックサム (ビット)</th>
<th>エントロピー <strong>+</strong> チェックサム (ビット)</th>
<th>リカバリーコードの単語数</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>128</p></td>
<td><p>4</p></td>
<td><p>132</p></td>
<td><p>12</p></td>
</tr>
<tr>
<td><p>160</p></td>
<td><p>5</p></td>
<td><p>165</p></td>
<td><p>15</p></td>
</tr>
<tr>
<td><p>192</p></td>
<td><p>6</p></td>
<td><p>198</p></td>
<td><p>18</p></td>
</tr>
<tr>
<td><p>224</p></td>
<td><p>7</p></td>
<td><p>231</p></td>
<td><p>21</p></td>
</tr>
<tr>
<td><p>256</p></td>
<td><p>8</p></td>
<td><p>264</p></td>
<td><p>24</p></td>
</tr>
</tbody>
</table>
++++

[role="less_space pagebreak-before"]
[[recovery_to_seed]]
===== リカバリーコードからシードへ

((("ウォレット", "リカバリーコード", "シード生成", id="wallet-recovery-bip39-seed")))((("リカバリーコード", "シード生成", id="recovery-code-bip39-seed")))((("BIP39 リカバリーコード", "シード生成", primary-sortas="BIP039", id="bip39-recovery-seed")))((("エントロピー", "シード生成", id="entropy-seed-generate")))((("シード", "生成", id="seed-generate")))((("キー伸張関数", id="key-stretch")))リカバリーコードは、128 ビットから 256 ビットの長さのエントロピーを表します。このエントロピーは、https://oreil.ly/6lwbd[キー伸張関数 PBKDF2] を使用して、より長い（512 ビットの）シードを導出するために使用されます。生成されたシードは、決定性ウォレットを構築し、そのキーを導出するために使用されます。

キー・ストレッチング関数は、エントロピーと _salt_（「salt」）の 2 つのパラメータを取ります。キー・ストレッチング関数における salt の目的は、ブルートフォース攻撃を可能にするルックアップテーブルの構築を困難にすることです。BIP39 標準では、salt には別の目的があります。それは、シードを保護する追加のセキュリティ要素として機能するパスフレーズの導入を可能にすることです。これについては <<recovery_passphrase>> で詳しく説明します。

[TIP]
====
キー・ストレッチング関数は、2,048 回のハッシュを行うことで、ソフトウェアを使用したリカバリーコードへのブルートフォース攻撃をわずかに困難にします。特別なハードウェアには大きな影響はありません。攻撃者がユーザのリカバリーコード全体を推測する必要がある場合、コードの長さ（最低でも 128 ビット）は十分なセキュリティを提供します。しかし、攻撃者がユーザのコードの一部を知っている場合には、キー・ストレッチングが攻撃者が異なるリカバリーコードの組み合わせをチェックする速度を遅くすることで、いくらかのセキュリティを追加します。BIP39 のパラメータは、最初に公開されたほぼ 10 年前の時点でも現代の基準では弱いと考えられていましたが、これは低電力 CPU を持つハードウェア署名デバイスとの互換性を考慮して設計された結果である可能性が高いです。BIP39 の代替として、より強力なキー・ストレッチングパラメータを使用するものもあります。例えば、Aezeed の 32,768 回のハッシュを行うより複雑な Scrypt アルゴリズムなどですが、これらはハードウェア署名デバイスで実行するのに便利ではないかもしれません。
====

ステップ 7 から 9 で説明されるプロセスは、<<generating_recovery_words>> で以前に説明されたプロセスから続きます。

++++
<ol start="7">
  <li>PBKDF2 キー・ストレッチング関数の最初のパラメータは、ステップ 6 で生成された<em>エントロピー</em>です。</li>

  <li>PBKDF2 キー・ストレッチング関数の 2 番目のパラメータは<em>salt</em>です。salt は、文字列定数 "<code>mnemonic</code>" と、オプションのユーザ提供のパスフレーズ文字列を連結したものです。</li>

  <li>PBKDF2 は、HMAC-SHA512 アルゴリズムを使用して 2,048 回のハッシュを行い、リカバリーコードと salt パラメータをストレッチし、最終的に 512 ビットの値を生成します。その 512 ビットの値がシードです。</li>
</ol>
++++

<<fig_5_7>> は、リカバリーコードを使用してシードを生成する方法を示しています。

[[fig_5_7]]
.リカバリーコードからシードへ。
image::images/mbc3_0505.png["リカバリーコードからシードへ"]


表 pass:[<a data-type="xref" href="#bip39_128_no_pass"
data-xrefstyle="select: labelnumber">#bip39_128_no_pass</a>]、
pass:[<a data-type="xref" href="#bip39_128_w_pass"
data-xrefstyle="select: labelnumber">#bip39_128_w_pass</a>]、および
pass:[<a data-type="xref" href="#bip39_256_no_pass"
data-xrefstyle="select: labelnumber">#bip39_256_no_pass</a>] は、
リカバリーコードとそれが生成するシードのいくつかの例を示しています。

++++
<table id="bip39_128_no_pass">
<caption>128ビットエントロピー BIP39 リカバリーコード、パスフレーズなし、生成されるシード</caption>
<tbody>
<tr>
<td><p><strong>エントロピー入力 (128 bits)</strong></p></td>
<td><p><code>0c1e24e5917779d297e14d45f14e1a1a</code></p></td>
</tr>
<tr>
<td><p><strong>リカバリーコード (12 words)</strong></p></td>
<td><p><code>army van defense carry jealous true garbage claim echo media make crunch</code></p></td>
</tr>
<tr>
<td><p><strong>パスフレーズ</strong></p></td>
<td><p>(none)</p></td>
</tr>
<tr>
<td><p><strong>シード (512 bits)</strong></p></td>
<td><p><code>5b56c417303faa3fcba7e57400e120a0ca83ec5a4fc9ffba757fbe63fbd77a89a1a3be4</code>
<code>c67196f57c39a88b76373733891bfaba16ed27a813ceed498804c0570</code></p></td>
</tr>
</tbody>
</table>

<table id="bip39_128_w_pass" class="pagebreak-before less_space">
<caption>128ビットエントロピー BIP39 リカバリーコード、パスフレーズあり、生成されるシード</caption>
<tbody>
<tr>
<td><p><strong>エントロピー入力 (128 bits)</strong></p></td>
<td><p><code>0c1e24e5917779d297e14d45f14e1a1a</code></p></td>
</tr>
<tr>
<td><p><strong>リカバリーコード (12 words)</strong></p></td>
<td><p><code>army van defense carry jealous true garbage claim echo media make crunch</code></p></td>
</tr>
<tr>
<td><p><strong>パスフレーズ</strong></p></td>
<td><p>SuperDuperSecret</p></td>
</tr>
<tr>
<td><p><strong>シード (512 bits)</strong></p></td>
<td><p><code>3b5df16df2157104cfdd22830162a5e170c0161653e3afe6c88defeefb0818c793dbb28</code>
<code>ab3ab091897d0715861dc8a18358f80b79d49acf64142ae57037d1d54</code></p></td>
</tr>
</tbody>
</table>
<table id="bip39_256_no_pass">
<caption>256ビットエントロピー BIP39 リカバリーコード、パスフレーズなし、生成されるシード</caption>
<tbody>
<tr>
<td><p><strong>エントロピー入力 (256 bits)</strong></p></td>
<td><p><code>2041546864449caff939d32d574753fe684d3c947c3346713dd8423e74abcf8c</code></p></td>
</tr>
<tr>
<td><p><strong>リカバリーコード (24 words)</strong></p></td>
<td><p><code>cake apple borrow silk endorse fitness top denial coil riot stay wolf
luggage oxygen faint major edit measure invite love trap field dilemma oblige</code></p></td>
</tr>
<tr>
<td><p><strong>パスフレーズ</strong></p></td>
<td><p>(none)</p></td>
</tr>
<tr>
<td><p><strong>シード (512 bits)</strong></p></td>
<td><p><code>3269bce2674acbd188d4f120072b13b088a0ecf87c6e4cae41657a0bb78f5315b33b3</code>
<code>a04356e53d062e55f1e0deaa082df8d487381379df848a6ad7e98798404</code></p></td>
</tr>
</tbody>
</table>
++++

## どれくらいのエントロピーが必要ですか？

BIP32 は 128 から 512 ビットのシードを許可しています。BIP39 は 128 から 256 ビットのエントロピーを受け入れ、Electrum v2 は 132 ビットのエントロピーを受け入れ、Aezeed は 128 ビットのエントロピーを受け入れ、SLIP39 は 128 または 256 ビットを受け入れます。これらの数値の違いは、安全性のためにどれくらいのエントロピーが必要かを不明確にしています。この点を解明してみましょう。

BIP32 の拡張プライベートキーは、256 ビットのキーと 256 ビットのチェーンコードで構成され、合計 512 ビットです。つまり、最大で 2^512^ 通りの異なる拡張プライベートキーが存在します。512 ビット以上のエントロピーで始めても、512 ビットのエントロピーを含む拡張プライベートキーが得られるだけなので、前述の標準がそれを許可していたとしても、512 ビット以上を使用する意味はありません。

しかし、2^512^ 通りの異なる拡張プライベートキーがある一方で、通常のプライベートキーは（わずかに少ない）2^256^ 通りしかありません。そして、実際にビットコインを保護するのはこれらのプライベートキーです。つまり、シードに 256 ビット以上のエントロピーを使用しても、256 ビットのエントロピーを含むプライベートキーしか得られません。将来的に、拡張キーの追加のエントロピーが追加のセキュリティを提供するビットコイン関連のプロトコルが登場する可能性はありますが、現時点ではそうではありません。

ビットコインの公開鍵のセキュリティ強度は 128 ビットです。古典的なコンピュータ（この記事執筆時点で実際の攻撃に使用できる唯一の種類のコンピュータ）を持つ攻撃者は、他のユーザの公開鍵に対するプライベートキーを見つけるために、ビットコインの楕円曲線上で約 2^128^ 回の操作を行う必要があります。セキュリティ強度が 128 ビットであることの意味は、128 ビット以上のエントロピーを使用することに明らかな利点がないということです（ただし、生成されたプライベートキーが 2^256^ のプライベートキーの範囲全体から均一に選択されることを確認する必要があります）。

エントロピーが大きいことのもう一つの利点は、リカバリーコードの固定割合（ただしコード全体ではない）が攻撃者に見られた場合、エントロピーが大きいほど、彼らが見ていない部分を解読するのが難しくなることです。例えば、攻撃者が 128 ビットのコードの半分（64 ビット）を見た場合、残りの 64 ビットをブルートフォースすることが可能です。しかし、256 ビットのコードの半分（128 ビット）を見た場合、残りの半分をブルートフォースすることは現実的ではありません。この防御に頼ることはお勧めしません。リカバリーコードを非常に安全に保管するか、SLIP39 のような方法を使用して、個々のコードの安全性に依存せずにリカバリーコードを複数の場所に分散させることをお勧めします。

2023年現在、ほとんどの最新のウォレットは、リカバリーコードのために 128 ビットのエントロピー（または Electrum v2 の 132 ビットのように 128 に近い値）を生成します。

[[recovery_passphrase]]
===== BIP39 におけるオプションのパスフレーズ

BIP39 標準では、シードの導出にオプションのパスフレーズを使用することができます。パスフレーズを使用しない場合、リカバリーコードは定数文字列「mnemonic」を含むソルトでストレッチされ、特定の 512 ビットのシードが生成されます。パスフレーズを使用した場合、ストレッチ関数は同じリカバリーコードから*異なる*シードを生成します。実際、単一のリカバリーコードがあれば、あらゆる可能なパスフレーズが異なるシードを導きます。基本的に「間違った」パスフレーズは存在しません。すべてのパスフレーズが有効であり、それぞれが異なるシードを導き、膨大な数の未初期化ウォレットのセットを形成します。可能なウォレットのセットは非常に大きいため (2^512^)、ブルートフォース攻撃や偶然の推測で使用中のものを見つける実際的な可能性はありません。

[TIP]
====
BIP39 には「間違った」パスフレーズはありません。すべてのパスフレーズは何らかのウォレットに繋がりますが、以前に使用されていない限り空です。
====

オプションのパスフレーズは、次の 2 つの重要な機能を提供します：

- 記憶された第二の要素であり、リカバリーコード単体では無意味にし、偶然の盗難からリカバリーコードを保護します。技術に精通した盗難からの保護には、非常に強力なパスフレーズを使用する必要があります。

- もっともらしい否認、または「強制ウォレット」の一形態として、選択したパスフレーズが少額の資金を持つウォレットに導くものがあります。これは、攻撃者を資金の大部分を含む「本物の」ウォレットから注意をそらすために使用されます。

パスフレーズの使用は、紛失のリスクも伴うことに注意が必要です：

* ウォレットの所有者が無能力状態になったり死亡したりして、他の誰もパスフレーズを知らない場合、シードは無用のものとなり、ウォレットに保存されているすべての資金は永久に失われます。

* 逆に、所有者がシードと同じ場所にパスフレーズをバックアップしている場合、第二の要素の目的が失われます。

++++
<p class="fix_tracking2">
パスフレーズは非常に有用ですが、バックアップと復旧のための慎重に計画されたプロセスと組み合わせて使用するべきです。所有者が生存している可能性を考慮し、彼または彼女の家族が暗号通貨の遺産を回収できるようにすることが重要です。
</p>
++++

[[hd_wallet_details]]
==== シードからの HD ウォレットの作成

HD ウォレットは、単一の _ルートシード_ から作成されます。これは 128、256、または 512 ビットのランダムな数値です。通常、このシードは前のセクションで詳述した復旧コードによって生成または復号化されます。

HDウォレットのすべての鍵は、このルートシードから決定的に導出されます。これにより、互換性のある任意の HDウォレットでそのシードからウォレット全体を再作成することが可能です。このため、ルートシードが導出されるリカバリーコードだけを転送することで、数千または数百万の鍵を含む HDウォレットを簡単にバックアップ、復元、エクスポート、インポートできます。HDウォレットのマスターキーとマスターチェーンコードを作成するプロセスは、<<HDWalletFromSeed>>に示されています。

[[HDWalletFromSeed]]
.ルートシードからマスターキーとチェーンコードを作成する。
image::images/mbc3_0506.png["HDWalletFromRootSeed"]

ルートシードは HMAC-SHA512 アルゴリズムに入力され、生成されたハッシュが_マスタープライベートキー_ (_m_) と_マスターチェーンコード_ (_c_) を作成するために使用されます。

マスタープライベートキー (_m_) は、通常の楕円曲線乗算プロセス _m_ × _G_ を使用して、対応するマスターパブリックキー (_M_) を生成します。このプロセスは <<public_key_derivation>> で見たものです。

マスターチェーンコード (_c_) は、親鍵から子鍵を作成する関数にエントロピーを導入するために使用されます。この詳細は次のセクションで説明します。

===== プライベート子鍵の導出

HDウォレットは、親鍵から子鍵を導出するために_子鍵導出_ (CKD) 関数を使用します。

子鍵導出関数は、一方向ハッシュ関数に基づいており、次の要素を組み合わせます：

* 親プライベートまたはパブリックキー（非圧縮キー）
* チェーンコードと呼ばれるシード（256ビット）
* インデックス番号（32ビット）

チェーンコードはプロセスに決定的なランダムデータを導入するために使用されます。そのため、インデックスと子鍵を知っているだけでは他の子鍵を導出することはできません。子鍵を知っていても、チェーンコードがなければその兄弟鍵を見つけることはできません。初期のチェーンコードシード（ツリーのルート）はシードから作成され、その後の子チェーンコードは各親チェーンコードから導出されます。

これらの 3 つの項目（親キー、チェインコード、インデックス）は組み合わされ、以下のようにハッシュされて子キーを生成します。

親公開鍵、チェインコード、およびインデックス番号は組み合わされ、HMAC-SHA512 アルゴリズムでハッシュされて 512 ビットのハッシュを生成します。この 512 ビットのハッシュは 2 つの 256 ビットの半分に分割されます。ハッシュ出力の右半分の 256 ビットは子のチェインコードになります。ハッシュの左半分の 256 ビットは親秘密鍵に加算されて子秘密鍵を生成します。<<CKDpriv>> では、インデックスを 0 に設定して親の「ゼロ」（インデックスで最初の）子を生成する様子が示されています。

[[CKDpriv]]
.親秘密鍵を拡張して子秘密鍵を作成する。
image::images/mbc3_0507.png["ChildPrivateDerivation"]

インデックスを変更することで、親を拡張してシーケンス内の他の子（例：子 0、子 1、子 2 など）を作成できます。各親キーは 2,147,483,647 (2^31^) の子を持つことができます（2^31^ は利用可能な全 2^32^ 範囲の半分で、残りの半分はこの章で後述する特別なタイプの派生に予約されています）。

ツリーの 1 レベル下でこのプロセスを繰り返すと、各子は親となり、自分自身の子を無限の世代にわたって作成できます。

===== 派生した子キーの使用

子秘密鍵は非決定論的（ランダムな）キーと区別がつきません。派生関数は一方向関数であるため、子キーを使用して親キーを見つけることはできません。また、子キーを使用して兄弟を見つけることもできません。n 番目の子を持っていても、その兄弟（n–1 子や n+1 子など）やシーケンスの他の子を見つけることはできません。すべての子を派生できるのは親キーとチェインコードだけです。子チェインコードがなければ、子キーを使用して孫を派生することもできません。新しいブランチを開始して孫を派生するには、子秘密鍵と子チェインコードの両方が必要です。

では、子秘密鍵は単独で何に使えるのでしょうか？それは公開鍵とビットコインアドレスを作成するために使用できます。そして、そのアドレスに支払われたものを使うためにトランザクションに署名するために使用できます。


[TIP]
====
子の秘密鍵、対応する公開鍵、および Bitcoin アドレスは、ランダムに作成された鍵やアドレスと区別がつきません。これらがシーケンスの一部であるという事実は、それらを作成した HD ウォレット機能の外部からは見えません。一度作成されると、これらは「通常の」鍵として正確に機能します((("鍵生成", "HD (階層的決定性)", "秘密の子鍵の導出", startref="keygen-hd-private-child")))((("HD (階層的決定性)鍵生成", "秘密の子鍵の導出", startref="hd-keygen-private-child")))((("秘密の子鍵の導出", startref="private-child")))((("子鍵ペアの導出", "秘密鍵", startref="child-key-pair-private")))。
====

===== 拡張鍵

前に見たように((("鍵生成", "HD (階層的決定性)", "拡張鍵", id="keygen-hd-extend")))((("HD (階層的決定性)鍵生成", "拡張鍵", "説明", id="hd-keygen-extend")))((("拡張鍵", "説明", id="extend-key")))、鍵導出関数は、鍵、チェーンコード、および目的の子のインデックスという 3 つの入力に基づいて、ツリーの任意のレベルで子を作成するために使用できます。鍵とチェーンコードが 2 つの重要な要素であり、これらを組み合わせたものが _拡張鍵_ と呼ばれます。「拡張鍵」という用語は、子を導出するために使用できるため、「拡張可能な鍵」とも考えられます。

拡張鍵は、鍵とチェーンコードを単純に連結したものとして保存および表現されます。拡張鍵には 2 種類あります。拡張秘密鍵は、秘密鍵とチェーンコードの組み合わせであり、子の秘密鍵（およびそこから子の公開鍵）を導出するために使用できます。拡張公開鍵は、公開鍵とチェーンコードであり、<<public_key_derivation>>で説明されているように、子の公開鍵（_公開のみ_）を作成するために使用できます。

拡張鍵を、HD ウォレットのツリー構造における枝の根と考えてください。枝の根があれば、枝の残りを導出できます。拡張秘密鍵は完全な枝を作成できますが、拡張公開鍵は公開鍵の枝のみを作成できます。

拡張キーは base58check を使用してエンコードされ、異なる BIP32 互換ウォレット間で簡単にエクスポートおよびインポートできるようになっています。拡張キーの base58check コーディングでは、特別なバージョン番号を使用し、base58 文字でエンコードされたときに「xprv」および「xpub」というプレフィックスが付くようにして、簡単に識別できるようにしています。拡張キーは通常のアドレスよりも多くのバイトを含むため、これまでに見た他の base58check エンコードされた文字列よりもはるかに長くなっています。

以下は、base58check でエンコードされた拡張_秘密_キーの例です：

----
xprv9tyUQV64JT5qs3RSTJkXCWKMyUgoQp7F3hA1xzG6ZGu6u6Q9VMNjGr67Lctvy5P8oyaYAL9CA
WrUE9i6GoNMKUga5biW6Hx4tws2six3b9c
----

以下は、base58check でエンコードされた対応する拡張_公開_キーの例です：

----
xpub67xpozcx8pe95XVuZLHXZeG6XWXHpGq6Qv5cmNfi7cS5mtjJ2tgypeQbBs2UAR6KECeeMVKZBP
LrtJunSDMstweyLXhRgPxdp14sk9tJPW9
----

[role="less_space pagebreak-before"]
[[public__child_key_derivation]]
===== 公開子キーの導出

前述のように、HD ウォレットの非常に便利な特性は、秘密キーを持たずに公開親キーから公開子キーを導出できることです。このため、子公開キーを導出する方法は、子秘密キーから導出する方法と、親公開キーから直接導出する方法の二通りがあります。

したがって、拡張公開キーを使用して、その HD ウォレット構造のブランチ内のすべての_公開_キー（および公開キーのみ）を導出することができます。

このショートカットを使用すると、サーバーやアプリケーションが拡張公開キーのコピーを持ち、秘密キーを一切持たない公開キーのみのデプロイメントを作成できます。このようなデプロイメントは、無限の数の公開キーとビットコインアドレスを生成できますが、それらのアドレスに送られた資金を使うことはできません。一方、別のより安全なサーバーでは、拡張秘密キーを使用して対応するすべての秘密キーを導出し、トランザクションに署名して資金を使うことができます。

このソリューションの一般的な用途の一つは、eコマースアプリケーションを提供するウェブサーバに拡張公開鍵をインストールすることです。ウェブサーバは公開鍵導出機能を使用して、各トランザクション（例：顧客のショッピングカート）に対して新しいビットコインアドレスを作成できます。ウェブサーバは盗難のリスクがある秘密鍵を持たないため、安全です。HDウォレットがない場合、このようにするには、別の安全なサーバで何千ものビットコインアドレスを生成し、それをeコマースサーバに事前にロードする必要があります。この方法は面倒で、eコマースサーバが鍵を「使い切らない」ように常にメンテナンスが必要です。

.Mind the Gap
****
拡張公開鍵は約 40 億の直接子鍵を生成できます。これは、どの店舗やアプリケーションでも必要とする以上の数です。しかし、ウォレットアプリケーションが 40 億の鍵すべてを生成し、それらの鍵に関与するトランザクションをブロックチェーンでスキャンするのは非現実的な時間がかかります。そのため、ほとんどのウォレットは一度に少数の鍵を生成し、それらの鍵に関与する支払いをスキャンし、前の鍵が使用されると順次追加の鍵を生成します。例えば、アリスのウォレットは 100 の鍵を生成します。最初の鍵に支払いがあると、101 番目の鍵を生成します。

時々、ウォレットアプリケーションは誰かに鍵を配布し、その人が後で支払いをしないことを決めることがあります。これにより鍵チェーンにギャップが生じますが、ウォレットがそのギャップの後に鍵を生成していれば、後の支払いを見つけてさらに鍵を生成し続けることができるので問題ありません。支払いを受け取らずに問題を引き起こさない連続した未使用鍵の最大数を _ギャップリミット_ と呼びます。

ウォレットアプリケーションがギャップリミットまでのすべての鍵を配布し、それらの鍵が支払いを受け取っていない場合、新しい鍵の要求に対処するために次の三つのオプションがあります：

1. 要求を拒否し、これ以上の支払いを受け取れないようにすることです。これは明らかに好ましくないオプションですが、最も簡単に実装できます。

```markdown
2. ギャップ制限を超えて新しい鍵を生成できます。これにより、支払いを要求するすべての人がユニークな鍵を取得し、アドレスの再利用を防ぎ、プライバシーを向上させます。しかし、ウォレットを復元コードから復元する必要がある場合や、ウォレット所有者が同じ拡張公開鍵を使用して他のソフトウェアを使用している場合、これらの他のウォレットは拡張ギャップ以降に受け取った支払いを確認できません。

3. 以前に配布した鍵を再配布することができ、スムーズな復元を保証しますが、ウォレット所有者と取引相手のプライバシーを潜在的に低下させる可能性があります。

BTCPay Server のようなオンライン商人向けのオープンソースのプロダクションシステムは、非常に大きなギャップ制限を使用し、請求書を生成する速度を制限することでこの問題を回避しようとします。他の解決策として、支払者のウォレットに対して、実際の取引のための新しいアドレスを受け取る前に、再利用される可能性のあるアドレスに支払うトランザクションを構築（ただしブロードキャストしない）するように依頼することが提案されています。しかし、これらの他の解決策は、この執筆時点ではプロダクションで使用されていません。

****

この解決策のもう一つの一般的な応用は、コールドストレージやハードウェア署名デバイスです。このシナリオでは、拡張秘密鍵をペーパーウォレットやハードウェアデバイスに保存し、拡張公開鍵をオンラインに保持できます。ユーザは、秘密鍵を安全にオフラインで保管しながら、自由に「受け取り」アドレスを作成できます。資金を使うには、ユーザはオフラインのソフトウェアウォレットアプリケーションやハードウェア署名デバイスで拡張秘密鍵を使用できます。<<CKDpub>> は、親公開鍵を拡張して子公開鍵を導出するメカニズムを示しています。
```

[[CKDpub]]
.親公開鍵を拡張して子公開鍵を作成する
image::images/mbc3_0508.png["ChildPublicDerivation"]

==== ウェブストアで拡張公開鍵を使用する

HDウォレットがどのように使われるかを、ガブリエルのウェブストアを見てみましょう。

ガブリエルは最初、趣味としてシンプルなホスティングされた WordPress ページを基にウェブストアを立ち上げました。彼のストアは非常に基本的なもので、数ページと単一のビットコインアドレスを持つ注文フォームだけでした。

ガブリエルは、通常のウォレットで生成された最初のビットコインアドレスをストアのメインビットコインアドレスとして使用しました。顧客はフォームを使って注文を提出し、ガブリエルの公開されたビットコインアドレスに支払いを送信し、ガブリエルが処理するための注文詳細を含むメールをトリガーしました。毎週数件の注文しかなかったため、このシステムは十分に機能しましたが、ガブリエルや彼の顧客、支払いを受ける人々のプライバシーを弱めていました。

しかし、小さなウェブストアは非常に成功し、地元のコミュニティから多くの注文を引き寄せました。すぐにガブリエルは圧倒されました。同じアドレスにすべての注文が支払われるため、特に同じ金額の複数の注文が近接して入ると、注文と取引を正しく一致させることが難しくなりました。

通常のビットコイン取引で受取人が選択できるメタデータは、金額と支払いアドレスだけです。ユニークな識別子の請求書番号を保持するための件名やメッセージフィールドはありません。

ガブリエルのHDウォレットは、秘密鍵を知らなくても公開子鍵を導出できる能力を通じて、はるかに良い解決策を提供します。ガブリエルはウェブサイトに拡張公開鍵 (xpub) をロードすることができ、これを使って顧客の注文ごとにユニークなアドレスを導出できます。このユニークなアドレスはプライバシーを即座に改善し、各注文にユニークな識別子を与え、どの請求書が支払われたかを追跡するために使用できます。

HDウォレットを使用することで、ガブリエルは個人のウォレットアプリケーションから資金を使うことができますが、ウェブサイトにロードされた xpub はアドレスを生成して資金を受け取ることしかできません。この HDウォレットの機能は、非常に優れたセキュリティ機能です。ガブリエルのウェブサイトには秘密鍵が含まれていないため、ハッキングされても、将来ガブリエルが受け取る予定の資金しか盗まれません。過去に受け取った資金は影響を受けません。

ガブリエルは、Trezorハードウェア署名デバイスから xpub をエクスポートするために、ウェブベースの Trezorウォレットアプリケーションを使用します。公開鍵をエクスポートするには、Trezorデバイスを接続しておく必要があります。ほとんどのハードウェア署名デバイスは秘密鍵をエクスポートすることはありません。それらは常にデバイス上に残ります。

ガブリエルは、xpub を彼のウェブストアのビットコイン決済処理ソフトウェア、例えば広く使用されているオープンソースの BTCPay Server にコピーします。

===== 強化された子鍵導出

xpub から公開鍵のブランチを導出する能力は非常に便利ですが、潜在的なリスクも伴います。xpub へのアクセスは子秘密鍵へのアクセスを許可しません。しかし、xpub がチェーンコードを含んでいるため、もし子秘密鍵が知られたり、何らかの形で漏洩した場合、それをチェーンコードと組み合わせて他のすべての子秘密鍵を導出することができます。1つの漏洩した子秘密鍵と親チェーンコードがあれば、すべての子の秘密鍵が明らかになります。さらに悪いことに、子秘密鍵と親チェーンコードを使って親秘密鍵を推測することも可能です。

このリスクに対抗するために、HDウォレットは _強化された導出_ と呼ばれる代替の導出関数を提供します。これは親公開鍵と子チェーンコードの関係を断ち切ります。強化された導出関数は、親公開鍵の代わりに親秘密鍵を使用して子チェーンコードを導出します。これにより、親/子シーケンスに「ファイアウォール」が作られ、チェーンコードが親や兄弟の秘密鍵を危険にさらすことができなくなります。強化された導出関数は、通常の子秘密鍵導出とほとんど同じように見えますが、親公開鍵の代わりに親秘密鍵がハッシュ関数の入力として使用される点が異なります。これは <<CKDprime>> の図に示されています。


[[CKDprime]]
.ハード化された子鍵の導出；親公開鍵を省略します。
image::images/mbc3_0509.png["ChildHardPrivateDerivation"]

ハード化されたプライベート導出関数を使用すると、結果として得られる子プライベート鍵とチェーンコードは、通常の導出関数から得られるものとは完全に異なります。結果として得られる「ブランチ」の鍵は、チェーンコードが兄弟や親のプライベート鍵を明らかにするために悪用されることがないため、脆弱ではない拡張公開鍵を生成するために使用できます。したがって、ハード化された導出は、拡張公開鍵が使用されるレベルの上に「ギャップ」を作成するために使用されます。

簡単に言うと、xpub の利便性を利用して公開鍵のブランチを導出したい場合、チェーンコードが漏洩するリスクを避けるためには、通常の親ではなくハード化された親から導出するべきです。ベストプラクティスとして、マスター鍵のレベル 1 の子は常にハード化された導出を通じて導出され、マスター鍵の妥協を防ぎます。

===== 通常およびハード化された導出のためのインデックス番号

導出関数で使用されるインデックス番号 ((("ハード化された導出のためのインデックス番号")))は 32 ビット整数です。通常の導出関数を通じて作成された鍵とハード化された導出を通じて導出された鍵を簡単に区別するために、このインデックス番号は 2 つの範囲に分割されます。インデックス番号が 0 から 2^31^ &#x2013; 1 (0x0 から 0x7FFFFFFF) の間は、_通常の_ 導出のみに使用されます。インデックス番号が 2^31^ から 2^32^ &#x2013; 1 (0x80000000 から 0xFFFFFFFF) の間は、_ハード化された_ 導出のみに使用されます。したがって、インデックス番号が 2^31^ 未満の場合、子は通常であり、インデックス番号が 2^31^ 以上の場合、子はハード化されています。

インデックス番号を読みやすく表示しやすくするために、ハード化された子のインデックス番号はゼロから始まり、プライム記号が付けられます。したがって、最初の通常の子鍵は 0 と表示され、最初のハード化された子 (インデックス 0x80000000) は 0++'++ と表示されます。続いて、2 番目のハード化された鍵はインデックス 0x80000001 を持ち、1++'++ と表示されます。このようにして、HD ウォレットのインデックス i++'++ を見ると、それは 2^31^+i を意味します。通常の ASCII テキストでは、プライム記号は単一のアポストロフィまたは文字 _h_ に置き換えられます。シェルや他のコンテキストで単一のアポストロフィが特別な意味を持つ場合のような状況では、文字 _h_ を使用することが ((("プライベート子鍵導出", "ハード化された導出", startref="private-child-harden")))((("子鍵ペア導出", "ハード化された導出", startref="child-key-pair-harden")))((("ハード化された子鍵導出", startref="harden-child-key")))推奨されます。

===== HD ウォレットのキー識別子 (パス)

HD ウォレット内のキーは「パス」命名規則を使用して識別されます。ツリーの各レベルはスラッシュ (/) 文字で区切られます (<<table_4-8>> を参照)。マスタープライベートキーから派生したプライベートキーは "m" で始まります。マスターパブリックキーから派生したパブリックキーは "M" で始まります。したがって、マスタープライベートキーの最初の子プライベートキーは m/0 です。最初の子パブリックキーは M/0 です。最初の子の2番目の孫は m/0/1 となります。

キーの「系譜」は右から左に読み取られ、派生元のマスターキーに到達するまで続きます。たとえば、識別子 m/x/y/z は、キー m/x/y の z 番目の子であり、キー m/x の y 番目の子であり、m の x 番目の子であるキーを示します。

++++
<table id="table_4-8" class="pagebreak-before less_space">
<caption>HD ウォレットパスの例</caption>
<thead>
<tr>
<th>HD パス</th>
<th>説明されるキー</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>m/0</p></td>
<td><p>マスタープライベートキー (m) からの最初の (0) 子プライベートキー</p></td>
</tr>
<tr>
<td><p>m/0/0</p></td>
<td><p>最初の子 (m/0) からの最初の孫プライベートキー</p></td>
</tr>
<tr>
<td><p>m/0'/0</p></td>
<td><p>最初の <em>ハード化された</em> 子 (m/0') からの最初の通常の孫プライベートキー</p></td>
</tr>
<tr>
<td><p>m/1/0</p></td>
<td><p>2 番目の子 (m/1) からの最初の孫プライベートキー</p></td>
</tr>
<tr>
<td><p>M/23/17/0/0</p></td>
<td><p>24 番目の子からの 18 番目の孫からの最初の曾孫からの最初の玄孫パブリックキー</p></td>
</tr>
</tbody>
</table>
++++

===== HD ウォレットツリー構造のナビゲート

HD ウォレットツリー構造は非常に柔軟です。各親拡張キーは 40 億の子を持つことができます：20 億の通常の子と 20 億のハード化された子です。それぞれの子はさらに 40 億の子を持つことができ、以下同様です。ツリーは望むだけ深くすることができ、無限の世代を持つことができます。しかし、その柔軟性があるため、この無限のツリーをナビゲートするのは非常に難しくなります。特に、HD ウォレットを異なる実装間で転送するのは難しいです。なぜなら、ブランチやサブブランチへの内部組織の可能性が無限だからです。

2 つの BIP は、HD ウォレットツリーの構造に関するいくつかの提案された標準を作成することで、この複雑さに対する解決策を提供します。((("BIP43 HD ウォレットツリー構造", primary-sortas="BIP043")))BIP43 は、最初のハードンされた子インデックスを特別な識別子として使用し、ツリー構造の「目的」を示すことを提案しています。BIP43 に基づき、HD ウォレットはツリーのレベル 1 のブランチのみを使用し、そのインデックス番号が目的を定義することでツリーの残りの構造と名前空間を識別します。例えば、ブランチ m/i++&#x27;++/ のみを使用する HD ウォレットは特定の目的を示すことを意図しており、その目的はインデックス番号「i」によって識別されます。

その仕様を拡張して、((("BIP44 HD ウォレットツリー構造", primary-sortas="BIP044", id="bip44")))BIP44 は BIP43 の下で「目的」番号 +44'+ としてマルチアカウント構造を提案しています。BIP44 構造に従うすべての HD ウォレットは、ツリーの 1 つのブランチのみを使用することで識別されます：m/44++'++/。

BIP44 は、5 つの事前定義されたツリーレベルで構成される構造を指定しています：

-----
m / purpose' / coin_type' / account' / change / address_index
-----

最初のレベルの「目的」は常に ++44'++ に設定されます。2 番目のレベルの「coin_type」は暗号通貨の種類を指定し、各通貨が 2 番目のレベルの下に独自のサブツリーを持つマルチカレンシー HD ウォレットを可能にします。ビットコインは m/44++&apos;++/0++&apos;++、ビットコインテストネットは m/44++&apos;++/1++&apos;++ です。

ツリーの 3 番目のレベルは「アカウント」で、ユーザがウォレットを会計や組織の目的で別々の論理サブアカウントに分割することを可能にします。例えば、HD ウォレットには 2 つのビットコイン「アカウント」が含まれるかもしれません：m/44++&#x27;++/0++&#x27;++/0++&#x27;++ と m/44++&#x27;++/0++&#x27;++/1++&#x27;++。各アカウントは独自のサブツリーのルートです。

4 番目のレベルでは、「change」として、HD ウォレットには受信アドレスを作成するためのサブツリーと、変更アドレスを作成するためのサブツリーの 2 つがあります。前のレベルがハードンされた派生を使用していたのに対し、このレベルは通常の派生を使用します。これは、このレベルのツリーが非セキュアな環境で使用するために拡張公開鍵をエクスポートできるようにするためです。使用可能なアドレスは、ツリーの 5 番目のレベルである「address_index」として、4 番目のレベルの子として HD ウォレットによって派生されます。例えば、主要アカウントでの支払いのための 3 番目の受信アドレスは M/44++&#x27;++/0++&#x27;++/0++&#x27;++/0/2 になります。<<table_4-9>> にはさらにいくつかの例が示されています。

++++
<table id="table_4-9">
<caption>BIP44 HDウォレット構造の例</caption>
<thead>
<tr>
<th>HDパス</th>
<th>説明されるキー</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>M/44<code>'</code>/0<code>'</code>/0<code>'</code>/0/2</p></td>
<td><p>主要なビットコインアカウントの3番目の受取用公開鍵</p></td>
</tr>
<tr>
<td><p>M/44<code>'</code>/0<code>'</code>/3<code>'</code>/1/14</p></td>
<td><p>4番目のビットコインアカウントの15番目の変更アドレス用公開鍵</p></td>
</tr>
<tr>
<td><p>m/44<code>'</code>/2<code>'</code>/0<code>'</code>/0/1</p></td>
<td><p>Litecoinメインアカウントの2番目のプライベートキーで、トランザクションの署名に使用</p></td>
</tr>
</tbody>
</table>
++++

多くの人々は、ビットコインを盗難やその他の攻撃から守ることに焦点を当てていますが、ビットコインが失われる主な原因の一つ、あるいは _最も_ 主な原因はデータの損失です。ビットコインを使うために必要な鍵やその他の重要なデータが失われると、そのビットコインは永久に使えなくなります。誰もそれを取り戻すことはできません。この章では、現代のウォレットアプリケーションがデータの損失を防ぐために使用するシステムを見てきました。しかし、実際に利用可能なシステムを使って適切なバックアップを作成し、定期的にテストするのはあなた次第です。
