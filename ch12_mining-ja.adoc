[[mining]]
== マイニングとコンセンサス

「マイニング」という言葉はやや誤解を招くかもしれません。貴金属の採掘を連想させることで、マイニングの報酬、つまり各ブロックで新たに生成されるビットコインに注目が集まります。マイニングはこの報酬によって動機付けられていますが、マイニングの主な目的は報酬や新しいビットコインの生成ではありません。マイニングをビットコインが生成されるプロセスとしてのみ見ると、手段（インセンティブ）をプロセスの目的と誤解してしまいます。マイニングは、トランザクションが検証され、クリアされる分散型クリアリングハウスを支えるメカニズムです。マイニングはビットコインを特別なものにする発明の一つであり、P2Pデジタルキャッシュの基盤となる分散型コンセンサスメカニズムです。

マイニングはビットコインシステムを_保護_し、_中央集権的な権威なしに_ネットワーク全体のコンセンサスの出現を可能にします。新たに発行されるビットコインとトランザクション手数料の報酬は、マイナーの行動をネットワークのセキュリティと一致させるインセンティブスキームであり、同時に通貨供給を実施します。

[TIP]
====

マイニングはビットコインの_コンセンサスセキュリティ_を_分散化_するメカニズムの一つです。
====

マイナーは新しいトランザクションをグローバルなブロックチェーンに記録します。新しいブロックは、前回のブロック以降に発生したトランザクションを含み、平均して10分ごとに_マイニング_され、それによってこれらのトランザクションがブロックチェーンに追加されます。ブロックの一部となりブロックチェーンに追加されたトランザクションは_確認済み_と見なされ、ビットコインの新しい所有者は、これらのトランザクションで受け取ったビットコインを保護するために不可逆的な努力が払われたことを知ることができます。

さらに、ブロックチェーン内のトランザクションには、その位置によって定義される_トポロジカル順序_があります。一つのトランザクションは、より早いブロックに現れるか、同じブロック内でより早く現れる場合、他のトランザクションよりも早いとされます。ビットコインプロトコルでは、トランザクションは、ブロックチェーン内で以前に現れたトランザクションの出力を消費する場合にのみ有効であり（それが同じブロック内であっても、以前のブロックであっても）、それらの出力を消費した以前のトランザクションがない場合にのみ有効です。一つのブロックチェーン内で、トポロジカル順序の強制は、同じ出力を消費する二つの有効なトランザクションが存在しないことを保証し、_二重支出_の問題を排除します。

いくつかのプロトコルでは、ビットコインの上に構築されているものとして、ビットコイン取引のトポロジカル順序がイベントの順序を確立するために使用されます。このアイデアについては <<single_use_seals>> でさらに詳しく説明します。

マイナーは、マイニングによって提供されるセキュリティの見返りとして、2 種類の報酬を受け取ります。新しいブロックごとに作成される新しいビットコイン（_補助金_ と呼ばれます）と、ブロックに含まれるすべての取引からの取引手数料です。この報酬を得るために、マイナーは暗号ハッシュアルゴリズムに基づく課題を満たすために競争します。この問題の解決策は、プルーフ・オブ・ワークと呼ばれ、新しいブロックに含まれ、マイナーが多大な計算努力を費やした証拠として機能します。報酬を得るためにプルーフ・オブ・ワークアルゴリズムを解決し、ブロックチェーンに取引を記録する権利を得る競争が、ビットコインのセキュリティモデルの基盤です。

ビットコインの通貨供給は、中央銀行が紙幣を印刷して新しいお金を発行するプロセスに似ています。マイナーがブロックに追加できる新しく作成されたビットコインの最大量は、約 4 年ごと（正確には 210,000 ブロックごと）に減少します。2009 年 1 月には 1 ブロックあたり 50 ビットコインで始まり、2012 年 11 月には 1 ブロックあたり 25 ビットコインに半減しました。2016 年 7 月には再び 12.5 ビットコインに、2020 年 5 月には 6.25 ビットコインに半減しました。この公式に基づいて、マイニング報酬は指数関数的に減少し、約 2140 年にはすべてのビットコインが発行されます。2140 年以降、新しいビットコインは発行されません。

ビットコインのマイナーは取引手数料からも収益を得ます。すべての取引は、取引の入力と出力の間のビットコインの余剰として取引手数料を含むことができます。勝利したビットコインのマイナーは、勝利したブロックに含まれる取引の「お釣り」を得ることができます。今日では、手数料は通常、マイナーの収入のごく一部を占めるに過ぎず、大部分は新たに鋳造されたビットコインから来ています。しかし、報酬が時間とともに減少し、ブロックごとの取引数が増加するにつれて、マイニング収益のより大きな割合が手数料から来るようになります。徐々に、マイニング報酬は取引手数料によって支配され、これがマイナーにとっての主要なインセンティブとなります。2140 年以降、各ブロックの新しいビットコインの量はゼロになり、マイニングは取引手数料のみでインセンティブを受けることになります。

この章では、まず通貨供給メカニズムとしてのマイニングを検討し、その後、マイニングの最も重要な機能である、ビットコインのセキュリティを支える分散型コンセンサスメカニズムについて見ていきます。

マイニングとコンセンサスを理解するために、アリスのトランザクションがジンのマイニング機器によって受信され、ブロックに追加される過程を追跡します。その後、そのブロックがマイニングされ、ブロックチェーンに追加され、ビットコインネットワークによって受け入れられる過程を、((("mining", "operational overview", startref="mining-overview")))エマージェントコンセンサスを通じて追っていきます。

=== ビットコインの経済学と通貨の創造

ビットコインは、((("bitcoins", "mining", "currency creation", id="bitcoin-mining-create")))((("mining", "currency creation", id="mining-create")))((("currency creation", id="currency-create")))((("Bitcoin", "economics of", id="bitcoin-economics")))((("economics of Bitcoin", id="economics")))各ブロックの生成時に固定かつ減少する割合で鋳造されます。平均して10分ごとに生成される各ブロックには、何もないところから作られた完全に新しいビットコインが含まれています。21万ブロックごと、または約4年ごとに、通貨発行率は50%減少します。ネットワークの最初の4年間は、各ブロックに50の新しいビットコインが含まれていました。

最初の半減期はブロック 210,000 で発生しました。この本の出版後に予想される次の半減期は、ブロック 840,000 で発生し、おそらく 2024 年の 4 月か 5 月に生成されるでしょう。新しいビットコインの発行率は、32 回のこれらの _半減期_ を経て指数関数的に減少し、ブロック 6,720,000（おそらく 2137 年にマイニングされる）で最小通貨単位である 1 サトシに達します。最終的に、約 2140 年に 6.93 百万ブロック後、ほぼ 2,099,999,997,690,000 サトシ、つまりほぼ 2100 万ビットコインが発行されることになります。その後、ブロックには新しいビットコインは含まれず、マイナーは取引手数料のみで報酬を得ることになります。<<bitcoin_money_supply>> は、通貨発行が減少するにつれて、時間とともに流通するビットコインの総量を示しています。

[[bitcoin_money_supply]]
.幾何学的に減少する発行率に基づく時間経過に伴うビットコイン通貨の供給。
image::images/mbc3_1201.png["BitcoinMoneySupply"]


[NOTE]
====
ビットコインの採掘される最大数は、ビットコインの可能な採掘報酬の*上限*です。実際には、マイナーが意図的に報酬を満額受け取らずにブロックを採掘することがあります。そのようなブロックはすでに採掘されており、将来的にも採掘される可能性があるため、通貨の総発行量は少なくなります。
====

<<max_money>> のコードでは、発行されるビットコインの総量を計算します。

[[max_money]]
.発行されるビットコインの総量を計算するスクリプト
====
[source, python]
----
include::code/max_money.py[]
----
====

<<max_money_run>> は、このスクリプトを実行した際の出力を示しています。

[[max_money_run]]
.max_money.py スクリプトの実行
====
[source,bash]
----
$ python max_money.py
Total BTC to ever be created: 2099999997690000 Satoshis
----
====

有限で減少する発行量は、インフレーションに抵抗する固定された通貨供給を生み出します。中央銀行が無限に印刷できる法定通貨とは異なり、ビットコインの供給を膨らませる能力を持つ個々の当事者はいません。

.デフレ通貨
****
固定され減少する通貨発行の最も重要で議論される結果は、通貨が本質的に_デフレ_傾向にあることです。デフレは、供給と需要の不一致によって価値が上昇し、通貨の価値（および為替レート）が上がる現象です。価格のデフレはインフレーションの反対であり、時間とともにお金の購買力が増すことを意味します。

多くの経済学者は、デフレ経済はあらゆる手段を使って避けるべき災害であると主張します。それは、急速なデフレの期間には、人々が価格が下がることを期待してお金を使わずに貯め込む傾向があるからです。このような現象は、日本の「失われた10年」の間に起こり、需要の完全な崩壊が通貨をデフレスパイラルに押し込みました。

ビットコインの専門家は、デフレーションが必ずしも悪いものではないと主張しています。むしろ、デフレーションは需要の崩壊と関連付けられることが多いのです。なぜなら、それが私たちが研究できるデフレーションの最も明白な例だからです。無制限に通貨を発行できる法定通貨では、需要が完全に崩壊し、通貨を発行する意欲がない場合を除いて、デフレーションのスパイラルに陥ることは非常に困難です。ビットコインにおけるデフレーションは、需要の崩壊によって引き起こされるのではなく、予測可能な供給の制約によって引き起こされます。

デフレーションの肯定的な側面は、もちろんインフレーションの反対であることです。インフレーションは、通貨の緩やかで避けられない価値の低下を引き起こし、債務者（最大の債務者である政府自身を含む）を救済するために貯蓄者を罰する形の隠れた課税をもたらします。政府の管理下にある通貨は、後に貯蓄者の犠牲のもとに価値を低下させることで消去できる容易な債務発行のモラルハザードに苦しんでいます。

デフレーションの側面が、急速な経済収縮によって引き起こされない場合に問題となるのか、それともインフレーションや価値の低下からの保護がデフレーションのリスクを上回るために利点となるのかは、まだ明らかではありません。

=== 分散型コンセンサス

前章では、ブロックチェーン、つまりすべての取引のグローバルリストを見てきました。これは、ビットコインネットワーク内のすべての人が所有権の移転の権威ある記録として受け入れています。

しかし、誰も信頼することなく、ネットワーク内の全員が誰が何を所有しているかについての単一の普遍的な「真実」に同意することができるのでしょうか。すべての従来の支払いシステムは、基本的にすべての取引を検証し、クリアするクリアリングハウスサービスを提供する中央権限に依存する信頼モデルに依存しています。ビットコインには中央権限がありませんが、それでもすべてのフルノードは、権威ある記録として信頼できる公開ブロックチェーンの完全なコピーを持っています。ブロックチェーンは中央権限によって作成されるのではなく、ネットワーク内のすべてのノードによって独立して組み立てられます。ネットワーク内のすべてのノードが、不安定なネットワーク接続を介して送信される情報に基づいて、同じ結論に達し、他のすべてのノードと同じブロックチェーンのコピーを組み立てることができるのです。この章では、ビットコインネットワークが中央権限なしにグローバルコンセンサスを達成するプロセスを検討します。

サトシ・ナカモトの発明の一つは、_創発的コンセンサス_ のための分散型メカニズムです。創発的である理由は、コンセンサスが明示的に達成されるわけではないからです。選挙やコンセンサスが発生する固定の瞬間はありません。その代わりに、コンセンサスは、単純なルールに従う何千もの独立したノードの非同期的な相互作用の結果として創発的に生じるものです。通貨、取引、支払い、中央権限や信頼に依存しないセキュリティモデルを含むビットコインのすべての特性は、この発明から派生しています。

ビットコインの分散型コンセンサスは、ネットワーク全体のノードで独立して発生する4つのプロセスの相互作用から生じます。

- 各フルノードによる、包括的な基準に基づく各取引の独立した検証

- マイニングノードによる、取引の独立した集約と、プルーフ・オブ・ワークアルゴリズムを通じた計算の実証

- 各ノードによる新しいブロックの独立した検証とチェーンへの組み込み

- 各ノードによる、プルーフ・オブ・ワークを通じて最も累積計算が示されたチェーンの独立した選択

次のいくつかのセクションでは、これらのプロセスと、それらがどのように相互作用して、ビットコインのノードが権威ある、信頼された、公開された、グローバルなブロックチェーンを自分自身で組み立てることを可能にするネットワーク全体のコンセンサスの創発的特性を生み出すかを検討します。

[[tx_verification]]
=== 取引の独立した検証

<<c_transactions>> では、ウォレットソフトウェアが UTXO を集め、適切な認証データを提供し、新しい所有者に割り当てられた新しいアウトプットを構築することで取引を作成する方法を見ました。結果として得られる取引は、ビットコインネットワーク全体に伝播されるように、隣接するノードに送信されます。

しかし、トランザクションを隣接ノードに転送する前に、トランザクションを受信したすべての Bitcoin ノードはまずそのトランザクションを検証します。これにより、有効なトランザクションのみがネットワーク全体に伝播され、無効なトランザクションはそれを最初に受信したノードで破棄されます。

各ノードは、長いチェックリストに基づいてすべてのトランザクションを検証します：

- トランザクションの構文とデータ構造が正しいこと。

- 入力リストおよび出力リストが空でないこと。

- トランザクションの重みがブロックに収まる程度に低いこと。

- 各出力値および合計が許容範囲内（ゼロ以上、ただし 2100 万ビットコインを超えない）であること。

- ロックタイムが +INT_MAX+ と等しいか、ロックタイムおよびシーケンス値がロックタイムおよび BIP68 ルールに従って満たされていること。

- トランザクションに含まれる署名操作 (SIGOPS) の数が署名操作の制限を下回っていること。

- 消費される出力がメモリプール内の出力またはメインブランチのブロック内の未使用出力と一致すること。

- 各入力について、参照される出力トランザクションがコインベース出力である場合、少なくとも +COINBASE_MATURITY+ (100) 回の確認が必要です。絶対または相対ロックタイムも満たされている必要があります。ノードは、次のブロックに含まれる場合に成熟するため、成熟する前のブロックでトランザクションを中継することがあります。

- 入力値の合計が出力値の合計より少ない場合は拒否します。

- 各入力のスクリプトが対応する出力スクリプトに対して検証されること。

条件は時間とともに変化し、新しい機能を追加したり、新しい種類のサービス拒否攻撃に対処したりします。

各トランザクションを受信時に独立して検証し、伝播する前に検証することで、すべてのノードは有効（ただし未確認）のトランザクションのプールを構築します。これは _memory pool_ または _mempool_ として知られています。


=== マイニングノード

Bitcoinネットワーク上のいくつかのノードは、_マイナー_ と呼ばれる特殊なノードです。JingはBitcoinのマイナーで、彼は「マイニングリグ」と呼ばれる、Bitcoinをマイニングするために設計された特殊なコンピュータハードウェアシステムを運用してビットコインを稼いでいます。Jingの特殊なマイニングハードウェアは、フルノードを実行しているサーバーに接続されています。他のすべてのフルノードと同様に、JingのノードもBitcoinネットワーク上で未確認のトランザクションを受信し、伝播します。しかし、Jingのノードはこれらのトランザクションを新しいブロックに集約することも行います。

AliceがBobから購入を行った際に作成されたブロックを追ってみましょう (<<spending_bitcoin>> を参照)。この章の概念を示すために、Aliceのトランザクションを含むブロックがJingのマイニングシステムによってマイニングされたと仮定し、Aliceのトランザクションがこの新しいブロックの一部になる過程を追ってみましょう。

Jingのマイニングノードは、ブロックチェーンのローカルコピーを維持しています。Aliceが何かを購入する頃には、Jingのノードは最も多くのプルーフ・オブ・ワークを持つブロックチェーンに追いついています。Jingのノードはトランザクションをリスニングし、新しいブロックをマイニングしようとし、他のノードによって発見されたブロックもリスニングしています。Jingのノードがマイニングしている間に、Bitcoinネットワークを通じて新しいブロックを受信します。このブロックの到着は、そのブロックの探索の終わりと次のブロックを作成する探索の始まりを意味します。

前の数分間、Jingのノードは前のブロックの解決策を探している間、次のブロックの準備としてトランザクションを収集していました。現在、メモリプールには数千のトランザクションが収集されています。新しいブロックを受信し、それを検証すると、Jingのノードはメモリプール内のすべてのトランザクションと比較し、そのブロックに含まれていたものを削除します。メモリプールに残っているトランザクションは未確認で、新しいブロックに記録されるのを待っています。

Jingのノードはすぐに新しい部分的なブロック、次のブロックの候補を構築します。このブロックは _候補ブロック_ と呼ばれます。なぜなら、まだ有効なブロックではなく、有効なプルーフ・オブ・ワークを含んでいないからです。マイナーがプルーフ・オブ・ワークアルゴリズムに従って解決策を見つけることに成功した場合にのみ、ブロックは有効になります。

ジンのノードがメモリプールからすべてのトランザクションを集約すると、新しい候補ブロックには数千のトランザクションが含まれ、それぞれが彼が請求しようとするトランザクション手数料を支払います。

==== コインベーストランザクション

どのブロックにおいても最初のトランザクションは特別なトランザクションであり、_コインベーストランザクション_ と呼ばれます。このトランザクションはジンのノードによって構築され、彼のマイニング作業に対する _報酬_ を支払います。

ジンのノードはコインベーストランザクションを彼自身のウォレットへの支払いとして作成します。ジンがブロックをマイニングして得る報酬の総額は、ブロック補助金（2023年には6.25ビットコイン）とブロックに含まれるすべてのトランザクションからの手数料の合計です。

通常のトランザクションとは異なり、コインベーストランザクションは入力としてUTXOを消費（支出）しません。代わりに、_コインベース入力_ と呼ばれる1つの入力のみを持ち、これには暗黙的にブロック報酬が含まれています。コインベーストランザクションは少なくとも1つの出力を持たなければならず、ブロックに収まる限り多くの出力を持つことができます。2023年のコインベーストランザクションでは、2つの出力を持つことが一般的です：1つはゼロ値の出力で、+OP_RETURN+ を使用してブロック内のセグウィットトランザクションのすべての証人にコミットします。もう1つの出力はマイナーに報酬を支払います。

==== コインベース報酬と手数料

ジンのノードは、コインベーストランザクションを構築するために、まずトランザクション手数料の総額を計算します：

[latexmath]
++++
\begin{equation}
Total\:Fees = Sum(Inputs) - Sum(Outputs)
\end{equation}
++++

次に、Jing のノードは新しいブロックの正しい報酬を計算します。報酬はブロックの高さに基づいて計算され、1ブロックあたり 50 ビットコインから始まり、210,000 ブロックごとに半分に減少します。

この計算は、Bitcoin Core クライアントの関数 +GetBlockSubsidy+ で確認できます。詳細は <<getblocksubsidy_source>> をご覧ください。

[[getblocksubsidy_source]]
.ブロック報酬の計算&#x2014;関数 [.plain]#+GetBlockSubsidy+,# Bitcoin Core クライアント, [.plain]#main.cpp#
====
[role="c_less_space"]
[source, cpp]
----
CAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams)
{
    int halvings = nHeight / consensusParams.nSubsidyHalvingInterval;
    // 右シフトが未定義の場合、ブロック報酬をゼロに強制します。
    if (halvings >= 64)
        return 0;

    CAmount nSubsidy = 50 * COIN;
    // 補助金は 210,000 ブロックごとに半分になります。
    nSubsidy >>= halvings;
    return nSubsidy;
}
----
====

初期補助金は、50 を +COIN+ 定数 (100,000,000 サトシ) で掛けることによりサトシで計算されます。これにより、初期報酬 (+nSubsidy+) は 50 億サトシに設定されます。

次に、関数は現在のブロックの高さを半減期 (+SubsidyHalvingInterval+) で割ることにより、発生した +halvings+ の数を計算します。

次に、関数はバイナリ右シフト演算子を使用して、各半減期ごとに報酬 [.keep-together]#(+nSubsidy+)# を 2 で割ります。ブロック 277,316 の場合、これは 50 億サトシの報酬を一度 (1 回の半減) バイナリ右シフトし、25 億サトシ、つまり 25 ビットコインになります。33 回目の半減後、補助金はゼロに切り捨てられます。バイナリ右シフト演算子は、複数回の繰り返し除算よりも効率的であるため使用されます。潜在的なバグを避けるために、63 回の半減後はシフト操作をスキップし、補助金を 0 に設定します。

最後に、コインベース報酬 (+nSubsidy+) はトランザクション手数料 (+nFees+) に加算され、その合計が返されます。

[TIP]
====
Jing のマイニングノードがコインベーストランザクションを書き込む場合、Jing が自分に 100 または 1,000 ビットコインを「報酬」として与えるのを何が止めるのでしょうか？答えは、膨らんだ報酬は他のすべての人によってブロックが無効と見なされ、Jing の PoW に使用された電力が無駄になるということです。Jing は、ブロックが ((("rewards", startref="reward-coinbase")))((("transaction fees", "in coinbase transactions", secondary-sortas="coinbase transactions", startref="transaction-fee-coinbase")))すべての人に受け入れられた場合にのみ報酬を使うことができます。
====


==== コインベーストランザクションの構造

これらの計算をもとに、ジンのノードは自身にブロック報酬を支払うためのコインベーストランザクションを構築します。

コインベーストランザクションは特別な形式を持っています。以前の UTXO を消費するためのトランザクション入力を指定する代わりに、「コインベース」入力を持っています。トランザクション入力については <<inputs>> で検討しました。通常のトランザクション入力とコインベーストランザクション入力を比較してみましょう。<<table_8-1>> は通常のトランザクションの構造を示し、<<table_8-2>> はコインベーストランザクションの入力の構造を示しています。

++++
<table id="table_8-1">
<caption>「通常の」トランザクション入力の構造</caption>
<thead>
<tr>
<th>サイズ</th>
<th>フィールド</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>32 バイト</p></td>
<td><p>トランザクションハッシュ</p></td>
<td><p>消費する UTXO を含むトランザクションへのポインタ</p></td>
</tr>
<tr>
<td><p>4 バイト</p></td>
<td><p>出力インデックス</p></td>
<td><p>消費する UTXO のインデックス番号、最初は 0</p></td>
</tr>
<tr>
<td><p>1–9 バイト (compactSize)</p></td>
<td><p>スクリプトサイズ</p></td>
<td><p>続くスクリプトのバイト長</p></td>
</tr>
<tr>
<td><p>可変</p></td>
<td><p>入力スクリプト</p></td>
<td><p>UTXO 出力スクリプトの条件を満たすスクリプト</p></td>
</tr>
<tr>
<td><p>4 バイト</p></td>
<td><p>シーケンス番号</p></td>
<td><p>BIP68 タイムロックやトランザクション置換信号に使用される多目的フィールド</p></td>
</tr>
</tbody>
</table>
<table id="table_8-2">
<caption>コインベーストランザクション入力の構造</caption>
<thead>
<tr>
<th>サイズ</th>
<th>フィールド</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>32 バイト</p></td>
<td><p>トランザクションハッシュ</p></td>
<td><p>すべてのビットがゼロ：トランザクションハッシュ参照ではない</p></td>
</tr>
<tr>
<td><p>4 バイト</p></td>
<td><p>出力インデックス</p></td>
<td><p>すべてのビットが 1：0xFFFFFFFF</p></td>
</tr>
<tr>
<td><p>1 バイト</p></td>
<td><p>コインベースデータサイズ</p></td>
<td><p>コインベースデータの長さ、2 から 100 バイト</p></td>
</tr>
<tr>
<td><p>可変</p></td>
<td><p>コインベースデータ</p></td>
<td><p>追加のナンスやマイニングタグに使用される任意のデータ；v2 ブロックではブロック高さで始まる必要があります</p></td>
</tr>
<tr>
<td><p>4 バイト</p></td>
<td><p>シーケンス番号</p></td>
<td><p>0xFFFFFFFF に設定</p></td>
</tr>
</tbody>
</table>
++++

コインベーストランザクションでは、最初の二つのフィールドは UTXO 参照を表さない値に設定されます。「トランザクションハッシュ」の代わりに、最初のフィールドは 32 バイトすべてがゼロに設定されます。「出力インデックス」は 4 バイトすべてが 0xFF (10 進数で 255) に設定されます。入力スクリプトは、次に説明するように、マイナーが使用するデータフィールドであるコインベースデータに置き換えられます。

[[duplicate_transactions]]
==== コインベースデータ

コインベーストランザクションには入力スクリプトフィールドがありません。その代わりに、このフィールドはコインベースデータに置き換えられ、2 バイトから 100 バイトの間でなければなりません。最初の数バイトを除いて、コインベースデータの残りはマイナーが任意の方法で使用できます。それは任意のデータです。

例えば、ジェネシスブロックでは、サトシ・ナカモトがコインベースデータに「The Times 03/Jan/2009 Chancellor on brink of second bailout for banks」というテキストを追加し、このブロックが作成された最も早い日付の証拠として、またメッセージを伝えるために使用しました。現在では、マイナーはしばしばコインベースデータを使用して、追加のナンス値やマイニングプールを識別する文字列を含めています。

[role="less_space pagebreak-before"]
コインベースの最初の数バイトは以前は任意でしたが、現在はそうではありません。BIP34 によれば、バージョン 2 のブロック（バージョンフィールドが 2 以上に設定されているブロック）は、コインベースフィールドの最初にスクリプトの「プッシュ」操作としてブロックの高さを含めなければなりません。

=== ブロックヘッダの構築

ブロックヘッダを構築するために、マイニングノードは <<block_header_structure_ch10>> にリストされているように、6 つのフィールドを埋める必要があります。

++++
<table id="block_header_structure_ch10">
<caption>ブロックヘッダの構造</caption>
<thead>
<tr>
<th>サイズ</th>
<th>フィールド</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>4 bytes</p></td>
<td><p>バージョン</p></td>
<td><p>多目的ビットフィールド</p></td>
</tr>
<tr>
<td><p>32 bytes</p></td>
<td><p>前のブロックハッシュ</p></td>
<td><p>チェーン内の前の（親）ブロックのハッシュへの参照</p></td>
</tr>
<tr>
<td><p>32 bytes</p></td>
<td><p>マークルルート</p></td>
<td><p>このブロックのトランザクションのマークルツリーのルートとなるハッシュ</p></td>
</tr>
<tr>
<td><p>4 bytes</p></td>
<td><p>タイムスタンプ</p></td>
<td><p>このブロックの概算作成時間（Unix Epochからの秒数）</p></td>
</tr>
<tr>
<td><p>4 bytes</p></td>
<td><p>ターゲット</p></td>
<td><p>このブロックのプルーフ・オブ・ワークアルゴリズムのターゲット</p></td>
</tr>
<tr>
<td><p>4 bytes</p></td>
<td><p>ナンス</p></td>
<td><p>プルーフ・オブ・ワークアルゴリズムに使用されるカウンタ</p></td>
</tr>
</tbody>
</table>
++++

バージョンフィールドは元々整数フィールドであり、BIP 34、66、65で定義された Bitcoin ネットワークの 3 つのアップグレードに使用されました。各アップグレードのたびに、バージョン番号が増加しました。後のアップグレードでは、バージョンフィールドがビットフィールドとして定義され、_versionbits_ と呼ばれ、最大 29 のアップグレードが同時に進行中であることを可能にしました。詳細は <<bip9>> を参照してください。さらに後には、マイナーが一部の versionbits を補助ナンスフィールドとして使用し始めました。

[TIP]
====
BIP 34、66、65 で定義されたプロトコルアップグレードはその順序で発生しました。BIP66（厳密な DER）は BIP65（+OP_CHECKTIMELOCKVERIFY+）の前に発生したため、Bitcoin 開発者はしばしばそれらを数値順ではなくその順序でリストします。
====

今日では、versionbits フィールドは、コンセンサスプロトコルのアップグレードが進行中でない限り意味を持ちません。その場合、versionbits がどのように使用されているかを判断するために、そのドキュメントを読む必要があります。

次に、マイニングノードは「前のブロックハッシュ」（[.keep-together]#+prevhash+# としても知られる）を追加する必要があります。それは、ネットワークから受信した前のブロックのブロックヘッダのハッシュであり、Jing のノードが受け入れ、彼の候補ブロックの _親_ として選択したものです。

[TIP]
====
特定の _親_ ブロックを選択することにより、候補ブロックヘッダの Previous Block Hash フィールドで示されるように、Jing はその特定のブロックで終わるチェーンを延長するために自身のマイニングパワーをコミットしています。
====

次のステップは、マークルツリーを使用してすべてのトランザクションをコミットすることです。各トランザクションは、その証人トランザクション識別子 (_wtxid_) を使用して地形順にリストされ、最初のトランザクション（コインベース）の wtxid の代わりに 32 バイトの 0x00 が立ちます。<<merkle_trees>> で見たように、wtxid の数が奇数の場合、最後の wtxid は自分自身とハッシュされ、各ノードには1つのトランザクションのハッシュが含まれます。トランザクションハッシュはペアで組み合わされ、ツリーの各レベルが作成され、すべてのトランザクションがツリーの「ルート」に1つのノードに要約されるまで続きます。マークルツリーのルートは、すべてのトランザクションを単一の 32 バイトの値に要約し、これが _witness root hash_ です。

witness root hash はコインベーストランザクションの出力に追加されます。このステップは、ブロック内のトランザクションのいずれも証人構造を含む必要がない場合はスキップできます。各トランザクション（コインベーストランザクションを含む）は、そのトランザクション識別子 (txid) を使用してリストされ、2番目のマークルツリーを構築するために使用され、そのルートがブロックヘッダがコミットするマークルルートになります。

次に、Jing のマイニングノードは、1970年1月1日午前0時 UTC/GMT から経過した秒数に基づく Unix "epoch" タイムスタンプとしてエンコードされた 4 バイトのタイムスタンプを追加します。

Jing のノードは次に、nBits ターゲットを埋めます。これは、このブロックを有効にするために必要な PoW のコンパクトな表現に設定する必要があります。ターゲットは「ターゲットビット」メトリックとしてブロックに格納され、これはターゲットの仮数-指数エンコーディングです。エンコーディングには 1 バイトの指数と 3 バイトの仮数（係数）が含まれます。たとえば、ブロック 277,316 では、ターゲットビット値は +0x1903a30c+ です。最初の部分 +0x19+ は16進数の指数で、次の部分 +0x03a30c+ は係数です。ターゲットの概念は <<target>> で説明され、「ターゲットビット」の表現は <<target_bits>> で説明されています。

最終フィールドは nonce で、これはゼロに初期化されます。

他のフィールドがすべて埋められると、候補ブロックのヘッダーが完成し、マイニングのプロセスを開始できます。目標は、ターゲットよりも小さいハッシュを生成するヘッダーを見つけることです。マイニングノードは、要件を満たすバージョンが見つかるまで、ヘッダーの何十億、何兆ものバリエーションをテストする必要があります。

[role="less_space pagebreak-before"]
=== ブロックのマイニング

ジンのノードによって候補ブロックが構築されたので、ジンのハードウェアマイニングリグがブロックを「マイニング」し、ブロックを有効にするプルーフ・オブ・ワークアルゴリズムの解を見つける時が来ました。この本を通じて、ビットコインシステムのさまざまな側面で使用される暗号ハッシュ関数を学んできました。SHA256 ハッシュ関数は、ビットコインのマイニングプロセスで使用される関数です。

最も単純な言葉で言えば、マイニングとは、候補ブロックヘッダーを繰り返しハッシュし、1 つのパラメータを変更し、結果のハッシュが特定のターゲットと一致するまで続けるプロセスです。ハッシュ関数の結果は事前に決定することはできず、特定のハッシュ値を生成するパターンを作成することもできません。このハッシュ関数の特徴により、特定のターゲットに一致するハッシュ結果を生成する唯一の方法は、入力を変更しながら何度も試行し、偶然に望ましいハッシュ結果が現れるまで続けることです。

==== プルーフ・オブ・ワークアルゴリズム

ハッシュアルゴリズムは、任意の長さのデータ入力を受け取り、固定長の決定論的な結果を生成します。これを _ダイジェスト_ と呼びます。ダイジェストは入力に対するデジタルコミットメントです。特定の入力に対して、結果のダイジェストは常に同じであり、同じハッシュアルゴリズムを実装する誰もが簡単に計算および検証できます。暗号ハッシュアルゴリズムの重要な特徴は、同じダイジェストを生成する 2 つの異なる入力を見つけることが計算上不可能であることです（これを _衝突_ と呼びます）。その結果として、ランダムな入力を試す以外に、望ましいダイジェストを生成するように入力を選択することもほぼ不可能です。

SHA256 ハッシュ関数を使用すると、入力のサイズに関係なく出力は常に 256 ビットの長さになります。例えば、「Hello, World!」というフレーズの SHA256 ハッシュを計算してみましょう。

----
$ echo "Hello, world!" | sha256sum
d9014c4624844aa5bac314773d6b689ad467fa4e1d1a50a1b8a99d5a95f72ff5  -
----

この 256 ビットの出力（16 進数で表現される）は、そのフレーズの _ハッシュ_ または _ダイジェスト_ であり、フレーズのすべての部分に依存します。文字、句読点、またはその他の文字を 1 つ追加するだけで、異なるハッシュが生成されます。

このようなシナリオで使用される変数は _ナンス_ と呼ばれます。ナンスは暗号関数の出力を変化させるために使用され、この場合はフレーズに対する SHA256 コミットメントの出力を変化させます。

このアルゴリズムを使ってチャレンジを作成するために、ターゲットを設定しましょう。ゼロで始まる 16 進数のハッシュを生成するフレーズを見つけます。幸いなことに、これは <<sha256_example_generator_output2>> に示されているように難しくありません。

[[sha256_example_generator_output2]]
.簡単なプルーフ・オブ・ワークの実装
====
----
$ for nonce in $( seq 100 ) ; do echo "Hello, world! $nonce" | sha256sum ; done
3194835d60e85bf7f728f3e3f4e4e1f5c752398cbcc5c45e048e4dbcae6be782  -
bfa474bbe2d9626f578d7d8c3acc1b604ec4a7052b188453565a3c77df41b79e  -
[...]
f75a100821c34c84395403afd1a8135f685ca69ccf4168e61a90e50f47552f61  -
09cb91f8250df04a3db8bd98f47c7cecb712c99835f4123e8ea51460ccbec314  -
----
====

フレーズ "Hello, World! 32" は、次のハッシュを生成し、私たちの基準に合致します：+09cb91f8250df04a3db8bd98f47c7cecb712c99835f4123e8ea51460ccbec314+。これを見つけるのに 32 回の試行が必要でした。確率的には、ハッシュ関数の出力が均等に分布している場合、16 回のハッシュごとに 0 を 16 進数のプレフィックスとして持つ結果が見つかると予想されます（16 進数の 0 から F のうち 1 つ）。数値的には、+0x1000000000000000000000000000000000000000000000000000000000000000+ より小さいハッシュ値を見つけることを意味します。このしきい値を _ターゲット_ と呼び、ターゲットよりも数値的に小さいハッシュを見つけることが目標です。ターゲットを下げると、ターゲットより小さいハッシュを見つける作業はますます難しくなります。

++++
<p class="fix_tracking3">
簡単な例えを挙げると、プレイヤーがサイコロを繰り返し投げて、指定された目標よりも少ない目を出そうとするゲームを想像してください。最初のラウンドでは目標は 12 です。ダブル 6 を出さない限り、勝ちます。次のラウンドでは目標は 11 です。プレイヤーは 10 以下を出さなければならず、これも簡単なタスクです。数ラウンド後、目標が 5 まで下がったとしましょう。この時点で、サイコロの目の半分以上が目標を超えて無効になります。目標が低くなるほど、勝つためにはより多くのサイコロを投げる必要があります。最終的に目標が 3（最小値）になると、36 回に 1 回、つまり約 3% の確率でしか勝つことができません。
</p>
++++

サイコロゲームの目標が 3 であることを知っている観察者の視点から見ると、誰かが勝利の投げを成功させた場合、平均して 36 回の投げを試みたと推測できます。言い換えれば、目標によって課された難易度から成功するために必要な作業量を推定できます。アルゴリズムが SHA256 のような決定論的な関数に基づいている場合、入力自体が目標以下の結果を生成するために一定の作業量が行われたことの _証明_ となります。したがって、_プルーフ・オブ・ワーク_ です。

[TIP]
====
各試行がランダムな結果を生むにもかかわらず、任意の結果の確率は事前に計算できます。したがって、指定された難易度の結果は特定の作業量の証明となります。
====

<<sha256_example_generator_output2>> では、勝利の "nonce" は 32 であり、この結果は誰でも独立して確認できます。誰でも "Hello, world!" というフレーズに 32 という数字をサフィックスとして追加し、ハッシュを計算して、それが目標以下であることを確認できます：

----
$ echo "Hello, world! 32" | sha256sum
09cb91f8250df04a3db8bd98f47c7cecb712c99835f4123e8ea51460ccbec314  -
----

++++
<p class="fix_tracking3">
検証には 1 回のハッシュ計算しか必要ありませんが、動作する nonce を見つけるためには 32 回のハッシュ計算が必要でした。目標が低い（難易度が高い）場合、適切な nonce を見つけるためにはさらに多くのハッシュ計算が必要ですが、誰でも検証するためには 1 回のハッシュ計算で済みます。そして目標を知ることで、誰でも統計を使って難易度を推定し、そのような nonce を見つけるために必要な作業量を大まかに知ることができます。
</p>
++++

[TIP]
====
PoW はターゲットよりも小さいハッシュを生成しなければなりません。ターゲットが高いほど、ターゲットよりも小さいハッシュを見つけるのが容易になります。ターゲットが低いほど、ターゲットよりも小さいハッシュを見つけるのが難しくなります。ターゲットと難易度は反比例の関係にあります。
====

++++
<p class="fix_tracking3">
Bitcoin の PoW は、<a data-type="xref" href="#sha256_example_generator_output2">#sha256_example_generator_output2</a> に示されているチャレンジと非常に似ています。マイナーはトランザクションで満たされた候補ブロックを構築します。次に、マイナーはこのブロックのヘッダーのハッシュを計算し、それが現在の<em>ターゲット</em>よりも小さいかどうかを確認します。ハッシュがターゲットよりも小さくない場合、マイナーはノンスを変更し（通常は 1 ずつ増やすだけです）、再試行します。現在の Bitcoin ネットワークの難易度では、マイナーは十分に低いブロックヘッダーハッシュを得るためのノンスを見つけるまでに非常に多くの試行を行う必要があります。
</p>
++++

[[target_bits]]
==== ターゲット表現

//TODO:use visual representation like I did on bitcoin.org

ブロックヘッダー ((("mining", "proof-of-work algorithm", startref="mining-proof")))((("hash functions", "proof-of-work algorithm", startref="hash-proof")))((("proof-of-work algorithm", startref="proof-mining")))((("mining", "target representation", id="mining-target")))((("targets", "representation of", id="target-represent")))((("proof-of-work algorithm", "target representation", id="proof-target")))は「ターゲットビット」または単に「ビット」と呼ばれる表記でターゲットを含んでおり、ブロック 277,316 では +0x1903a30c+ の値を持っています。この表記は、PoW ターゲットを係数/指数形式で表現し、最初の 2 桁の 16 進数が指数で、次の 6 桁の 16 進数が係数です。このブロックでは、指数は +0x19+ で、係数は +0x03a30c+ です。

この表現から難易度ターゲットを計算するための公式は次のとおりです：

++++
<ul class="simplelist">
  <li>target = coefficient × 2<sup>(8 × (exponent – 3))</sup></li>
</ul>
++++

この公式を使用し、難易度ビットの値 0x1903a30c を用いると、次のようになります：

++++
<ul class="simplelist">
  <li>target = 0x03a30c × 2<sup>0x08 × (0x19 – 0x03)</sup></li>
</ul>
++++

これは次のようになります：

++++
<ul class="simplelist">
  <li>22,829,202,948,393,929,850,749,706,076,701,368,331,072,452,018,388,575,715,328</li>
</ul>
++++

また、16進数では：

++++
<ul class="simplelist">
  <li>0x0000000000000003A30C00000000000000000000000000000000000000000000</li>
</ul>
++++

これは、高さ 277,316 の有効なブロックが、ターゲットよりも小さいブロックヘッダハッシュを持つものであることを意味します。バイナリでその数は、先頭に 60 ビット以上のゼロが設定されている必要があります。この難易度レベルでは、1 兆ハッシュ毎秒 (1 テラハッシュ毎秒または 1 TH/sec) を処理する単一のマイナーが解を見つけるのは、平均して 8,496 ブロックごと、または 59 日ごとに 1 回です。((("mining", "target representation", startref="mining-target")))((("targets", "representation of", startref="target-represent")))((("proof-of-work algorithm", "target representation", startref="proof-target")))

[[target]]
==== 難易度調整のためのリターゲット

見たように、((("mining", "adjusting difficulty", id="mining-difficulty")))((("targets", "adjusting difficulty", id="target-difficulty")))((("proof-of-work algorithm", "adjusting difficulty", id="proof-difficulty")))((("difficulty", "adjusting", id="difficulty-adjust")))ターゲットは難易度を決定し、それによってプルーフ・オブ・ワークアルゴリズムの解を見つけるのにかかる時間に影響を与えます。これにより、明らかな疑問が生じます：なぜ難易度は調整可能なのか、誰がそれを調整するのか、そしてどのように？

ビットコインのブロックは平均して 10 分ごとに生成されます。これはビットコインの心拍であり、通貨発行の頻度と取引決済の速度を支えています。これは短期的だけでなく、数十年にわたって一定でなければなりません。この期間中、コンピュータの性能は急速に向上し続けると予想されます。さらに、マイニングへの参加者数や彼らが使用するコンピュータも常に変化します。ブロック生成時間を 10 分に保つためには、これらの変化を考慮してマイニングの難易度を調整する必要があります。実際、プルーフ・オブ・ワークのターゲットは、10 分のブロック間隔目標を達成するために定期的に調整される動的なパラメータです。簡単に言えば、現在のマイニングパワーが 10 分のブロック間隔をもたらすようにターゲットが設定されます。

では、完全に分散化されたネットワークでどのようにこのような調整が行われるのでしょうか。リターゲットは自動的に、そして各ノードで独立して行われます。2,016 ブロックごとに、すべてのノードが PoW をリターゲットします。実際の時間間隔と、1 ブロックあたり 10 分という目標時間間隔の比率が計算され、目標に対して比例した調整（上方または下方）が行われます。簡単に言うと、ネットワークが 10 分よりも早くブロックを見つけている場合、難易度が上がります（目標が下がります）。ブロック発見が予想より遅い場合、難易度が下がります（目標が上がります）。

この方程式は次のように要約できます：

----
New Target = Old Target * (20,160 minutes / Actual Time of Last 2015 Blocks)
----

[NOTE]
====
目標のキャリブレーションは 2,016 ブロックごとに行われますが、元の Bitcoin ソフトウェアのオフバイワンエラーのため、実際には前の 2,015 ブロックの総時間に基づいており（本来は 2,016 ブロックであるべきですが）、その結果、リターゲットが 0.05% 高い難易度に偏ることになります。
====

<<retarget_code>> は Bitcoin Core クライアントで使用されるコードを示しています。

[[retarget_code]]
.Retargeting the proof of work: [.plain]#++CalculateNextWorkRequired()++# in [.plain]#pow.cpp#
====
[source,cpp]
----

   // Limit adjustment step
    int64_t nActualTimespan = pindexLast->GetBlockTime() - nFirstBlockTime;
    LogPrintf("  nActualTimespan = %d  before bounds\n", nActualTimespan);
    if (nActualTimespan < params.nPowTargetTimespan/4)
        nActualTimespan = params.nPowTargetTimespan/4;
    if (nActualTimespan > params.nPowTargetTimespan*4)
        nActualTimespan = params.nPowTargetTimespan*4;

    // Retarget
    const arith_uint256 bnPowLimit = UintToArith256(params.powLimit);
    arith_uint256 bnNew;
    arith_uint256 bnOld;
    bnNew.SetCompact(pindexLast->nBits);
    bnOld = bnNew;
    bnNew *= nActualTimespan;
    bnNew /= params.nPowTargetTimespan;

    if (bnNew > bnPowLimit)
        bnNew = bnPowLimit;

----
====

パラメータ +Interval+（2,016 ブロック）および +TargetTimespan+（2 週間として 1,209,600 秒）は _chainparams.cpp_ に定義されています。

難易度の極端な変動を避けるために、リターゲット調整はサイクルごとに4倍未満でなければなりません。必要なターゲット調整が4倍を超える場合、4倍に調整され、それ以上にはなりません。さらなる調整は次のリターゲット期間で行われます。なぜなら、不均衡は次の2,016ブロックを通じて持続するからです。したがって、ハッシュパワーと難易度の間に大きな不一致がある場合、それを均衡させるには数回の2,016ブロックサイクルが必要になるかもしれません。

ターゲットはトランザクションの数やトランザクションの価値とは独立していることに注意してください。これは、ビットコインを保護するために費やされるハッシュパワー、したがって電力がトランザクションの数とは完全に独立していることを意味します。ビットコインは、今日のレベルからハッシュパワーを増やすことなくスケールアップし、安全性を保つことができます。ハッシュパワーの増加は、新しいマイナーが市場に参入するにつれて市場の力を表しています。報酬を追求する誠実な行動をするマイナーの管理下に十分なハッシュパワーがある限り、「乗っ取り」攻撃を防ぐのに十分であり、したがってビットコインを保護するのに十分です。

マイニングの難易度は、電力のコストと電力を支払うために使用される通貨に対するビットコインの為替レートに密接に関連しています。高性能なマイニングシステムは、現在のシリコン製造技術で可能な限り効率的であり、電力を可能な限り高い速度でハッシュ計算に変換します。マイニング市場における主な影響は、ビットコインでの1キロワット時の電力の価格です。これは、マイニングの収益性を決定し、したがってマイニング市場に参入または退出するインセンティブを決定します。

[[mtp]]
=== Median Time Past (MTP)

ビットコインでは、壁時計時間とコンセンサス時間の間に微妙ですが非常に重要な違いがあります。ビットコインは分散型ネットワークであり、各参加者が独自の時間の視点を持っています。ネットワーク上のイベントは、どこでも瞬時に発生するわけではありません。ネットワークの遅延は各ノードの視点に考慮されなければなりません。最終的にすべてが同期され、共通のブロックチェーンが作成されます。ビットコインは、過去に存在したブロックチェーンの状態について、10分ごとにコンセンサスに達します。

++++
<p class="fix_tracking">
ブロックヘッダに設定されるタイムスタンプはマイナーによって設定されます。分散型ノード間の時計の精度の違いを考慮するために、コンセンサスルールによってある程度の自由度が許されています。しかし、これによりマイナーがブロック内の時間について嘘をつく不幸なインセンティブが生まれます。例えば、マイナーが未来の時間を設定すると、難易度を下げることができ、より多くのブロックを採掘して将来のマイナーのために予約されているブロック補助金の一部を獲得できます。また、いくつかのブロックに過去の時間を設定できれば、他のブロックには現在の時間を使用し、難易度を操作する目的でブロック間の時間が長いように見せかけることができます。
</p>
++++

操作を防ぐために、Bitcoin には二つのコンセンサスルールがあります。一つ目は、どのノードも未来の時間が二時間以上先のブロックを受け入れないというものです。二つ目は、どのノードも最後の 11 ブロックの中央値の時間以下のブロックを受け入れないというもので、これを _median time past_ (MTP) と呼びます。

BIP68 の相対タイムロックのアクティベーションの一環として、トランザクションのタイムロック（絶対および相対）の「時間」の計算方法にも変更がありました。以前は、マイナーはブロックの時間以下のタイムロックを持つ任意のトランザクションをブロックに含めることができました。それにより、マイナーは可能な限り最新の時間（未来の二時間以内）を使用するインセンティブがあり、より多くのトランザクションが彼らのブロックに適格となりました。

嘘をつくインセンティブを取り除き、タイムロックのセキュリティを強化するために、BIP113 が提案され、相対タイムロックの BIP と同時にアクティベートされました。MTP はすべてのタイムロック計算に使用されるコンセンサス時間となりました。約二時間前の中間点を取ることで、任意のブロックのタイムスタンプの影響が減少します。11 ブロックを組み込むことで、単一のマイナーがタイムロックがまだ成熟していないトランザクションから手数料を得るためにタイムスタンプを操作することはできません。

MTP はロックタイム、+CLTV+、シーケンス、および +CSV+ の時間計算の実装を変更します。MTP によって計算されるコンセンサス時間は通常、壁時計時間より約一時間遅れています。タイムロックトランザクションを作成する場合、ロックタイム、シーケンス、+CLTV+、および +CSV+ にエンコードする希望の値を見積もる際にこれを考慮する必要があります。


=== ブロックの採掘に成功する

++++
<p class="fix_tracking">
前述のとおり、Jing のノードは候補ブロックを構築し、採掘の準備を整えています。Jing は、アプリケーション固有の集積回路を備えたハードウェア採掘装置をいくつか持っており、何十万もの集積回路がビットコインの二重 SHA256 アルゴリズムを並列で驚異的な速度で実行しています。これらの特殊な機械の多くは、USB またはローカルエリアネットワークを介して彼の採掘ノードに接続されています。次に、Jing のデスクトップで動作している採掘ノードがブロックヘッダを彼の採掘ハードウェアに送信し、毎秒数兆のヘッダのバリエーションをテストし始めます。ノンスが 32 ビットしかないため、すべてのノンスの可能性（約 40 億）を使い果たした後、採掘ハードウェアはブロックヘッダを変更し（コインベースのエクストラノンススペース、バージョンビット、またはタイムスタンプを調整）、ノンスカウンタをリセットして新しい組み合わせをテストします。</p>
++++

特定のブロックの採掘を開始してからほぼ 11 分後、ハードウェア採掘機の一つが解を見つけ、採掘ノードに送り返します。

すぐに、Jing の採掘ノードはブロックをすべてのピアに送信します。ピアはそれを受け取り、検証し、新しいブロックを伝播します。ブロックがネットワーク全体に広がると、各ノードはそれを自分のブロックチェーンのコピーに追加し、新しい高さに拡張します。採掘ノードがブロックを受け取り、検証すると、同じ高さでブロックを見つける努力を放棄し、Jing のブロックを「親」として使用してチェーン内の次のブロックを計算し始めます。Jing の新たに発見されたブロックの上に構築することにより、他の採掘者は実質的に彼のブロックとそれが拡張するチェーンを支持するために採掘力を使用しています。

次のセクションでは、各ノードがブロックを検証し、最も作業量の多いチェーンを選択して、分散型ブロックチェーンを形成するコンセンサスを作成するプロセスを見ていきます。


=== 新しいブロックの検証

ビットコインのコンセンサスメカニズムにおける第三のステップは、ネットワーク上のすべてのノードによる新しいブロックの独立した検証です。新しく解決されたブロックがネットワークを移動する際、各ノードはそれを検証するための一連のテストを実行します。この独立した検証により、コンセンサスルールに従ったブロックのみがブロックチェーンに組み込まれ、その結果としてマイナーが報酬を得ることが保証されます。ルールに違反するブロックは拒否され、マイナーは報酬を失うだけでなく、プルーフ・オブ・ワークの解決策を見つけるために費やした努力も無駄になります。つまり、ブロックを作成するためのすべてのコストを負担しながら、報酬を得ることができません。

ノードが新しいブロックを受け取ると、そのブロックを検証するために、すべての条件を満たさなければならない長いリストに照らしてチェックします。そうでなければ、そのブロックは拒否されます。これらの条件は、Bitcoin Core クライアントの +CheckBlock+ および +CheckBlockHeader+ 関数で確認でき、以下を含みます：

- ブロックデータ構造が構文的に有効である。

- ブロックヘッダーハッシュがターゲットより小さい（プルーフ・オブ・ワークを強制する）。

- ブロックのタイムスタンプが MTP と未来の 2 時間の間にある（時間誤差を許容する）。

- ブロックの重さが許容範囲内である。

- 最初のトランザクション（および唯一の最初のもの）がコインベーストランザクションである。

- ブロック内のすべてのトランザクションが <<tx_verification>> で議論されたトランザクションチェックリストを使用して有効である。

ネットワーク上のすべてのノードによる各新しいブロックの独立した検証は、マイナーが不正を行えないようにします。前のセクションでは、マイナーがブロック内で新しく作成されたビットコインを自分に与えるトランザクションを書き、トランザクション手数料を請求する方法を見ました。なぜマイナーは正しい報酬の代わりに千ビットコインのトランザクションを書かないのでしょうか？それは、すべてのノードが同じルールに従ってブロックを検証するからです。無効なコインベーストランザクションはブロック全体を無効にし、その結果としてブロックが拒否され、そのトランザクションは決してブロックチェーンの一部にならないからです。マイナーは、すべてのノードが従う共有ルールに基づいてブロックを構築し、PoW の正しい解決策でマイニングしなければなりません。そのために、彼らはマイニングに多くの電力を費やし、不正を行えば、すべての電力と努力が無駄になります。これが、独立した検証が分散型コンセンサスの重要な要素である理由です。

```markdown
//FIXME:normalize terminology between "block-finding race", "mining
//race", and "forks"
[[forks]]
=== Assembling and Selecting Chains of Blocks

Bitcoin の分散型コンセンサスメカニズムの最終段階は、ブロックをチェーンに組み立て、最も多くのプルーフ・オブ・ワーク (PoW) を持つチェーンを選択することです。

_最良のブロックチェーン_ とは、最も多くの累積 PoW が関連付けられた有効なブロックチェーンのことです。
最良のチェーンには、最良のチェーン上のブロックの「兄弟」であるブロックを持つ枝も含まれることがあります。これらのブロックは有効ですが、最良のチェーンの一部ではありません。これらは、将来的にこれらの二次チェーンのいずれかが主要なチェーンになる可能性があるため、参考のために保持されます。兄弟ブロックが発生するのは、通常、同じ高さで異なるブロックがほぼ同時にマイニングされた結果です。

新しいブロックが受信されると、ノードはそれを既存のブロックチェーンに追加しようとします。ノードはブロックの「前のブロックハッシュ」フィールドを確認します。これはブロックの親への参照です。次に、ノードは既存のブロックチェーンでその親を見つけようとします。ほとんどの場合、親は最良のチェーンの「先端」であり、この新しいブロックは最良のチェーンを拡張します。

新しいブロックが最良のチェーンを拡張しない場合もあります。その場合、ノードは新しいブロックのヘッダーを二次チェーンに接続し、次に二次チェーンの作業量を以前の最良のチェーンと比較します。もし二次チェーンが現在最良のチェーンである場合、ノードはそれに応じて確認済みトランザクションと利用可能な UTXO の見方を _再編成_ します。ノードがマイナーである場合、今度はこの新しい、より多くのプルーフ・オブ・ワークを持つチェーンを拡張する候補ブロックを構築します。

最も多くの累積作業量を持つ有効なチェーンを選択することで、すべてのノードは最終的にネットワーク全体のコンセンサスを達成します。チェーン間の一時的な不一致は、より多くの作業が追加され、可能なチェーンのいずれかが拡張されることで最終的に解決されます。
```

[TIP]
====
このセクションで説明するブロックチェーンのフォークは、グローバルネットワークにおける伝送遅延の結果として自然に発生します。意図的に引き起こされるフォークについては、この章の後半で取り上げます。
====

フォークはほとんどの場合、1 ブロック以内に解決されます。偶発的なフォークが 2 ブロックに拡大する可能性もありますが、それは前のフォークの「反対側」にいるマイナーがほぼ同時にブロックを見つけた場合に限られます。しかし、そのようなことが起こる可能性は低いです。

ビットコインの 10 分間隔のブロックは、迅速な確認時間とフォークの確率との間の設計上の妥協点です。ブロック時間が短くなると、トランザクションがより早くクリアされるように見えますが、ブロックチェーンのフォークがより頻繁に発生することになります。一方、ブロック時間が長くなるとフォークの数は減りますが、決済が遅く感じられるようになります。

[NOTE]
====
どちらがより安全でしょうか：ブロック間の平均時間が 10 分のブロックに含まれるトランザクションと、ブロック間の平均時間が 1 分でその上に 9 ブロックが構築されたブロックに含まれるトランザクション。答えは、どちらも同じくらい安全です。そのトランザクションを二重支出しようとする悪意のあるマイナーは、同等のプルーフ・オブ・ワークを持つチェーンを作成するために、ネットワーク全体のハッシュレートの 10 分間に相当する作業を行う必要があります。

ブロック間の時間が短くなることは、早期の決済をもたらしません。その唯一の利点は、保証を受け入れることに同意する人々に対して弱い保証を提供することです。たとえば、3 分間のマイナーが最良のブロックチェーンに同意することを十分なセキュリティと見なす場合、1 分間隔のブロックを持つシステムで 3 ブロックを待つ方が、10 分間隔のブロックを持つシステムよりも好ましいでしょう。ブロック間の時間が短くなるほど、偶発的なフォークに無駄になるマイナーの作業が増えます（他の問題もあります）。そのため、多くの人々はビットコインの 10 分間隔のブロックを短いブロック間隔よりも好みます。
====


=== マイニングとハッシュくじ

ビットコインのマイニングは非常に競争の激しい産業です。ビットコインの存在する年数ごとにハッシュパワーは指数関数的に増加しています。ある年には、技術の完全な変化を反映する成長が見られました。例えば、2010年と2011年には、多くのマイナーが CPU マイニングから GPU マイニングやフィールドプログラマブルゲートアレイ (FPGA) マイニングに切り替えました。2013年には、ASIC マイニングの導入により、マイニングパワーが大きく飛躍しました。これは、マイニング専用に設計されたシリコンチップ上にダブル SHA256 関数を直接配置することによって実現されました。このような最初のチップは、2010年のビットコインネットワーク全体よりも多くのマイニングパワーを単一のボックスで提供できました。

執筆時点では、ビットコインマイニング機器においてこれ以上の大きな飛躍はないと考えられています。なぜなら、この産業はムーアの法則の最前線に達しているからです。ムーアの法則は、計算密度が約18か月ごとに倍増することを示しています。それでもなお、ネットワークのマイニングパワーは急速に進化し続けています。

[[extra_nonce]]
==== エクストラノンスソリューション

2012年以降、マイニングはブロックヘッダーの構造における基本的な制限を解決するために進化してきました。ビットコインの初期には、マイナーはノンスを繰り返し試行することで、ターゲット以下のハッシュを見つけることができました。難易度が上がると、マイナーはしばしば 40 億のノンス値をすべて試してもブロックを見つけられませんでした。しかし、これは経過時間を考慮してブロックのタイムスタンプを更新することで簡単に解決されました。タイムスタンプはヘッダーの一部であるため、この変更によりマイナーは異なる結果でノンスの値を再度試行することができました。しかし、マイニングハードウェアが 4 GH/秒を超えると、このアプローチはますます難しくなりました。なぜなら、ノンス値が 1 秒以内に使い果たされてしまうからです。ASIC マイニング機器が TH/秒のハッシュレートを超え始めると、マイニングソフトウェアは有効なブロックを見つけるためにノンス値のためのより多くのスペースを必要としました。タイムスタンプを少し伸ばすことはできましたが、未来に移動しすぎるとブロックが無効になってしまいます。ブロックヘッダーに新しい変動源が必要でした。

広く実装された解決策の一つは、コインベーストランザクションを追加ノンス値のソースとして使用することでした。コインベーススクリプトは 2 バイトから 100 バイトのデータを格納できるため、マイナーはそのスペースを追加ノンススペースとして使用し、有効なブロックを見つけるためにより広範囲のブロックヘッダ値を探索できるようになりました。コインベーストランザクションはマークルツリーに含まれているため、コインベーススクリプトの変更はマークルルートの変更を引き起こします。8 バイトの追加ノンスと 4 バイトの「標準」ノンスにより、マイナーはタイムスタンプを変更せずに毎秒 2^96^ (8 の後に 28 個のゼロが続く) の可能性を探索できます。

今日広く使用されているもう一つの解決策は、BIP320 で説明されているように、ブロックヘッダの versionbits フィールドの最大 16 ビットをマイニングに使用することです。各マイニング機器が独自のコインベーストランザクションを持っている場合、これは個々のマイニング機器がブロックヘッダの変更だけで最大 281 TH/s を実行できることを意味します。これにより、マイニング機器とプロトコルは、4 億ハッシュごとにコインベーストランザクションの追加ノンスをインクリメントするよりも簡単になります。これは、マークルツリーの左側全体を根まで再計算する必要があります。

[[mining_pools]]
==== マイニングプール

この非常に競争の激しい環境では、個々のマイナーが単独で作業する（ソロマイナーとも呼ばれる）ことはほとんど不可能です。電気代やハードウェアコストを相殺するためにブロックを見つける可能性は非常に低く、宝くじを引くようなギャンブルを意味します。最速の消費者向け ASIC マイニングシステムでさえ、発電所の近くにある巨大な倉庫に何万台ものシステムを積み重ねた商業運営には太刀打ちできません。多くのマイナーは現在、マイニングプールを形成し、ハッシュパワーをプールして報酬を何千人もの参加者で分け合っています。プールに参加することで、マイナーは全体の報酬の小さな部分を得ることになりますが、通常は毎日報酬を受け取ることができ、不確実性を減らします。

具体的な例を見てみましょう。あるマイナーが、現在のネットワーク全体のハッシュレートの 0.0001% のハッシュレートを持つマイニングハードウェアを購入したと仮定します。プロトコルの難易度が変わらない場合、そのマイナーは約 20 年に一度新しいブロックを見つけることになります。それは報酬を得るまでに待つには非常に長い時間かもしれません。しかし、そのマイナーが他のマイナーと一緒に、ネットワーク全体のハッシュレートの 1% を持つマイニングプールで協力すれば、1 日に 1 ブロック以上を平均して見つけることができます。そのマイナーは報酬の一部（プールが課す手数料を差し引いた額）しか受け取れないため、1 日あたりの受け取り額は少額になります。20 年間毎日マイニングを行えば、（プールの手数料を除いて）自分で平均的なブロックを見つけた場合と同じ額を稼ぐことになります。唯一の根本的な違いは、受け取る支払いの頻度です。

マイニングプールは、特化したプールマイニングプロトコルを通じて、何百人または何千人ものマイナーを調整します。個々のマイナーは、プールにアカウントを作成した後、プールサーバーに接続するようにマイニング機器を設定します。彼らのマイニングハードウェアは、マイニング中にプールサーバーに接続されたままで、他のマイナーと努力を同期させます。こうして、プールのマイナーはブロックをマイニングする努力を共有し、報酬も共有します。

成功したブロックは、個々のマイナーではなくプールのビットコインアドレスに報酬を支払います。プールサーバーは、報酬のシェアが一定の閾値に達すると、定期的にマイナーのビットコインアドレスに支払いを行います。通常、プールサーバーはプールマイニングサービスを提供するために報酬のパーセンテージ手数料を課します。

プールに参加するマイナーは、候補ブロックの解決策を探す作業を分担し、マイニングへの貢献に対して「シェア」を獲得します。マイニングプールは、シェアを獲得するための目標（難易度を下げたもの）を設定し、通常はビットコインネットワークの目標よりも 1,000 倍以上簡単です。プール内の誰かがブロックを成功裏にマイニングすると、報酬はプールによって獲得され、その努力に貢献したシェアの数に比例してすべてのマイナーと共有されます。

多くのプールは、大規模・小規模、プロ・アマチュアを問わず、どんなマイナーにも開放されています。そのため、プールには小さなマイニングマシンを持つ参加者もいれば、高性能なマイニングハードウェアでいっぱいのガレージを持つ参加者もいます。数十キロワットの電力でマイニングしている人もいれば、メガワットの電力を消費するデータセンターを運営している人もいます。マイニングプールは、どのようにして個々の貢献度を測定し、公平に報酬を分配し、チートの可能性を排除するのでしょうか？その答えは、Bitcoin のプルーフ・オブ・ワークアルゴリズムを使用して各プールマイナーの貢献度を測定することですが、難易度を下げて、最小のプールマイナーでも頻繁にシェアを獲得できるようにすることです。シェアを獲得するための難易度を下げることで、プールは各マイナーが行った作業量を測定します。プールマイナーがプールターゲットよりも小さいブロックヘッダーハッシュを見つけるたびに、その結果を見つけるためのハッシュ作業を行ったことを証明します。そのヘッダーは最終的にコインベーストランザクションにコミットされ、マイナーがプールにブロック報酬を支払うコインベーストランザクションを使用したことを証明できます。各プールマイナーには、わずかに異なるコインベーストランザクションテンプレートが与えられ、それぞれが異なる候補ブロックヘッダーをハッシュするため、作業の重複を防ぎます。

シェアを見つけるための作業は、統計的に測定可能な方法で、Bitcoin ネットワークのターゲットよりも低いハッシュを見つけるための全体的な努力に貢献します。低価値のハッシュを見つけようとする何千ものマイナーが、最終的には Bitcoin ネットワークのターゲットを満たすほど低いハッシュを見つけることになります。

サイコロゲームのアナロジーに戻りましょう。サイコロプレイヤーが 4 未満を出すことを目標にサイコロを投げている場合（全体のネットワーク難易度）、プールはより簡単なターゲットを設定し、プールプレイヤーが 8 未満を出す回数をカウントします。プールプレイヤーが 8 未満を出すと（プールシェアターゲット）、シェアを獲得しますが、ゲームターゲット（4 未満）を達成していないため、ゲームには勝ちません。プールプレイヤーは、より簡単なプールターゲットをはるかに頻繁に達成し、シェアを非常に定期的に獲得しますが、ゲームに勝つという難しいターゲットを達成することはありません。時々、プールプレイヤーの一人が 4 未満のサイコロの合計を出し、プールが勝ちます。その後、獲得したシェアに基づいてプールプレイヤーに収益を分配できます。8 以下のターゲットは勝利ではありませんが、プレイヤーのサイコロの投げ方を公平に測定する方法であり、時折 4 未満の投げを生み出します。

同様に、マイニングプールは（より高く、より簡単な）プールターゲットを設定し、個々のプールマイナーがプールターゲットより小さいブロックヘッダーハッシュを見つけることで頻繁にシェアを獲得できるようにします。時折、これらの試みの一つがビットコインネットワークターゲットより小さいブロックヘッダーハッシュを生成し、有効なブロックとなり、プール全体が勝利します。

===== 管理されたプール

ほとんどの((("managed pools", id="manage-pool")))マイニングプールは「管理された」もので、プールサーバーを運営する会社や個人が存在します。プールサーバーの所有者は _プールオペレーター_ と呼ばれ、プールマイナーの収益の一部を手数料として徴収します。

プールサーバーは、プールマイナーの活動を調整するための専門的なソフトウェアとプールマイニングプロトコルを実行します。プールサーバーは一つ以上のフルビットコインノードにも接続されています。これにより、プールサーバーはプールマイナーに代わってブロックやトランザクションを検証し、フルノードを運用する負担を軽減します。フルノードを運用せずにマイニングできることは、管理されたプールに参加するもう一つの利点です。

プールマイナーは、Stratum((("Stratum")))などのマイニングプロトコルを使用してプールサーバーに接続します（バージョン 1 またはバージョン 2 のいずれか）。Stratum v1 は、候補ブロックヘッダーのテンプレートを含むブロック _テンプレート_ を作成します。プールサーバーは、トランザクションを集約し、コインベーストランザクション（追加のナンススペース付き）を追加し、マークルルートを計算し、前のブロックハッシュにリンクすることで候補ブロックを構築します。その後、候補ブロックのヘッダーがテンプレートとして各プールマイナーに送信されます。各プールマイナーは、ビットコインネットワークターゲットよりも高い（簡単な）ターゲットでブロックテンプレートを使用してマイニングし、成功した結果をプールサーバーに送り返してシェアを獲得します。

Stratum v2 は、プール内の個々のマイナーが自分のブロックに含めるトランザクションを選択できるオプションを提供し、これを自分のフルノードを使用して選択できます。

===== ピアツーピアマイニングプール (P2Pool)

Stratum v1 を使用する管理されたプール((("P2Pool (peer-to-peer mining pool)", id="p2pool")))は、プールオペレーターがプールの努力を二重支出トランザクションやブロックの無効化に向ける可能性があるため、不正行為の可能性を生み出します（<<consensus_attacks>>を参照）。さらに、集中化されたプールサーバーは単一障害点を表します。プールサーバーがダウンしたり、サービス拒否攻撃によって遅延したりすると、プールマイナーはマイニングできません。2011年に、これらの集中化の問題を解決するために、新しいプールマイニング方法が提案され、実装されました。それが、中央オペレーターのいないピアツーピアマイニングプールである P2Pool です。

P2Pool は、プールサーバの機能を分散化し、((("share chains"))) _シェアチェーン_ と呼ばれる並列のブロックチェーンのようなシステムを実装することで機能します。シェアチェーンは、Bitcoin ブロックチェーンよりも低い難易度で動作するブロックチェーンです。シェアチェーンは、プールマイナーがシェアチェーン上で 30 秒ごとに 1 つのシェアブロックをマイニングすることで、分散型プールで協力することを可能にします。シェアチェーン上の各ブロックは、作業に貢献したプールマイナーに対する比例配分のシェア報酬を記録し、前のシェアブロックからシェアを引き継ぎます。シェアブロックの 1 つが Bitcoin ネットワークのターゲットも達成した場合、それは伝播され、Bitcoin ブロックチェーンに含まれ、勝利したシェアブロックに先行するすべてのシェアに貢献したプールマイナー全員に報酬が与えられます。基本的に、プールサーバがプールマイナーのシェアと報酬を追跡する代わりに、シェアチェーンは Bitcoin のブロックチェーンコンセンサスメカニズムのような分散型コンセンサスメカニズムを使用して、すべてのプールマイナーがすべてのシェアを追跡できるようにします。

P2Pool マイニングは、プールマイニングよりも複雑です。なぜなら、プールマイナーは Bitcoin フルノードと P2Pool ノードソフトウェアをサポートするために十分なディスクスペース、メモリ、インターネット帯域幅を持つ専用のコンピュータを運用する必要があるからです。P2Pool マイナーは、マイニングハードウェアをローカルの P2Pool ノードに接続し、プールサーバの機能をシミュレートしてマイニングハードウェアにブロックテンプレートを送信します。P2Pool では、個々のプールマイナーがソロマイナーのようにトランザクションを集約して自分自身の候補ブロックを構築し、その後シェアチェーン上で協力してマイニングします。P2Pool はハイブリッドアプローチであり、ソロマイニングよりもはるかに細かい支払いを受けることができるという利点がありますが、管理されたプールのようにプールオペレータに過度のコントロールを与えることはありません。

P2Pool はマイニングプールオペレータによる権力の集中を減少させますが、シェアチェーン自体に対する 51% 攻撃に対して脆弱である可能性があります。P2Pool のより広範な採用は、Bitcoin 自体の 51% 攻撃問題を解決するものではありません。むしろ、P2Pool は多様化されたマイニングエコシステムの一部として、Bitcoin を全体的により堅牢にします。この記事の執筆時点では、P2Pool は使用されなくなっていますが、Stratum v2 などの新しいプロトコルにより、個々のマイナーが((("mining", "competitiveness of", startref="mining-competitive")))((("mining", "mining pools", startref="mining-mining-pools")))((("mining pools", startref="mining-pools")))((("P2Pool (peer-to-peer mining pool)", startref="p2pool")))ブロックに含めるトランザクションを選択できるようになります。

[[consensus_attacks]]
=== ハッシュレート攻撃

Bitcoin の合意形成メカニズムは、理論的には、ハッシュパワーを不正または破壊的な目的で使用しようとするマイナー（またはプール）によって攻撃される可能性があります。合意形成メカニズムは、自己利益のために誠実に行動するマイナーの多数に依存しています。しかし、もしマイナーまたはマイナーのグループがマイニングパワーの大部分を獲得できる場合、彼らは Bitcoin ネットワークのセキュリティと可用性を妨害するために合意形成メカニズムを攻撃することができます。

ハッシュレート攻撃は、将来の合意形成に最も大きな影響を与えることに注意が必要です。最良のブロックチェーン上の確認済みトランザクションは、時間が経つにつれて不変性が増していきます。理論的には、どの深さでもフォークを達成することができますが、実際には非常に深いフォークを強制するために必要な計算力は膨大であり、古いブロックを変更するのは非常に困難です。ハッシュレート攻撃は、秘密鍵や署名アルゴリズムのセキュリティには影響を与えません。

合意形成メカニズムに対する攻撃シナリオの一つは、「多数攻撃」または「51%攻撃」と呼ばれるものです。このシナリオでは、ネットワーク全体のハッシュパワーの過半数（例えば 51%）を制御するマイナーのグループが Bitcoin を攻撃するために共謀します。攻撃するマイナーは、ブロックの過半数をマイニングする能力を持ち、ブロックチェーンに意図的な「フォーク」を引き起こし、トランザクションを二重支出したり、特定のトランザクションやアドレスに対してサービス拒否攻撃を実行したりすることができます。フォーク／二重支出攻撃とは、攻撃者が以前に確認されたブロックをフォークして無効にし、別のチェーンに再収束させることです。十分なパワーがあれば、攻撃者は 6 つ以上のブロックを連続して無効にし、（6 回の確認を受けた）不変と考えられていたトランザクションを無効にすることができます。二重支出は攻撃者自身のトランザクションに対してのみ行うことができ、攻撃者は有効な署名を生成できます。トランザクションを無効にすることで、攻撃者が不可逆的な交換支払いまたは製品を支払わずに取得できる場合、自己のトランザクションを二重支出することは利益をもたらす可能性があります。

51%攻撃の実例を見てみましょう。第1章では、アリスとボブの間の取引を見ました。売り手であるボブは、迅速な顧客サービスの利便性と比較して、小額商品の二重支払いのリスクが低いため、確認（ブロックでのマイニング）を待たずに支払いを受け入れることにしています。これは、コーヒーショップが25ドル以下の金額に対して署名なしでクレジットカード支払いを受け入れるのと似ています。クレジットカードのチャージバックのリスクは低い一方で、署名を得るために取引を遅らせるコストは比較的大きいからです。対照的に、ビットコインでより高価な商品を販売することは、買い手が同じ入力（UTXO）の一つを使って競合する取引を放送し、商人への支払いをキャンセルする二重支払い攻撃のリスクを伴います。51%攻撃は、攻撃者が新しいチェーンで自分の取引を二重支払いし、古いチェーンでの対応する取引を取り消すことを可能にします。

//TODO:多数派攻撃と少数派「再編成」攻撃を区別する。

この例では、悪意のある攻撃者マロリーがキャロルのギャラリーに行き、サトシ・ナカモトをプロメテウスとして描いた美しい絵画のセットを購入します。キャロルは、マロリーに25万ドル相当のビットコインで絵画を販売します。キャロルは取引の6回以上の確認を待たずに、1回の確認後に絵画を包装してマロリーに渡します。マロリーは共犯者のポールと協力し、ポールは大規模なマイニングプールを運営しており、マロリーの取引がブロックに含まれるとすぐに攻撃を開始します。ポールはマイニングプールに、マロリーの取引を含むブロックと同じブロック高さを再マイニングするよう指示し、マロリーの支払いをキャロルにする代わりに、同じ入力を二重支払いする取引に置き換えます。この二重支払い取引は同じUTXOを消費し、キャロルに支払う代わりにマロリーのウォレットに戻します。これにより、マロリーはビットコインを保持できるようになります。ポールはさらにブロックをマイニングするようにマイニングプールを指示し、二重支払い取引を含むチェーンを元のチェーンよりも長くします（マロリーの取引を含むブロックの下でフォークを引き起こします）。ブロックチェーンのフォークが新しい（より長い）チェーンに有利に解決されると、二重支払いされた取引がキャロルへの元の支払いを置き換えます。キャロルは3枚の絵画を失い、支払いもありません。この間、ポールのマイニングプールの参加者は、自動化されたマイナーでマイニングを行っているため、二重支払いの試みを監視できず、無意識のままでいるかもしれません。

この種の攻撃から守るために、高額商品を販売する商人は、購入者に商品を渡す前に少なくとも6回の確認を待つ必要があります。場合によっては、6回以上の確認を待つことが推奨されることもあります。あるいは、商人はエスクローのマルチシグネチャアカウントを使用し、そのアカウントに資金が入った後に数回の確認を待つべきです。確認が多くなるほど、ブロックチェーンを再編成してトランザクションを無効にすることが難しくなります。高額商品に関しては、購入者が24時間の配達待ち（約144回の確認に相当）をしなければならない場合でも、ビットコインによる支払いは依然として便利で効率的です。

二重支払い攻撃に加えて、コンセンサス攻撃のもう一つのシナリオは、特定の参加者（特定のビットコインアドレス）へのサービス拒否です。マイニングパワーの過半数を持つ攻撃者は、トランザクションを検閲することができます。他のマイナーが採掘したブロックに含まれている場合、攻撃者は意図的にフォークしてそのブロックを再採掘し、特定のトランザクションを再度除外することができます。この種の攻撃は、攻撃者がマイニングパワーの過半数を制御している限り、特定のアドレスまたはアドレスのセットに対する持続的なサービス拒否を引き起こす可能性があります。

```
//TODO: update to not use 51% attack name (see other TODO in this
//chapter)
```

その名前にもかかわらず、51%攻撃シナリオは実際にはハッシュパワーの51%を必要としません。実際には、より少ない割合のハッシュパワーでもこの種の攻撃を試みることができます。51%の閾値は、そのような攻撃がほぼ確実に成功するレベルに過ぎません。ハッシュレート攻撃は基本的に次のブロックを巡る綱引きであり、「強い」グループが勝つ可能性が高くなります。ハッシュパワーが少ない場合、他のマイナーが「正直な」マイニングパワーでいくつかのブロックを生成するため、成功の確率は低くなります。攻撃者が持つハッシュパワーが多いほど、意図的に作成できるフォークが長くなり、最近の過去のブロックを無効にしたり、将来のブロックを制御したりすることができます。セキュリティ研究グループは、さまざまな種類のハッシュレート攻撃がハッシュパワーの30%程度で可能であると主張するために、統計モデリングを使用しています。

マイニングプールによって引き起こされる管理の中央集権化は、マイニングプール運営者による営利目的の攻撃のリスクをもたらしています。管理されたプールでは、プール運営者が候補ブロックの構築を制御し、どのトランザクションを含めるかも制御します。これにより、プール運営者はトランザクションを除外したり、二重支払いトランザクションを導入したりする力を持つことになります。このような権力の乱用が限定的かつ微妙に行われた場合、プール運営者は気付かれることなくハッシュレート攻撃から利益を得ることが考えられます。

しかし、すべての攻撃者が利益を動機とするわけではありません。潜在的な攻撃シナリオの一つとして、攻撃者が利益を得る可能性なしにビットコインネットワークを混乱させることを意図する場合があります。ビットコインを麻痺させることを目的とした悪意のある攻撃は、莫大な投資と秘密裏の計画を必要としますが、資金が豊富な、最も可能性の高い国家支援の攻撃者によって開始される可能性があります。あるいは、資金が豊富な攻撃者が、マイニングハードウェアを同時に集め、プール運営者を妥協させ、サービス拒否攻撃で他のプールを攻撃することでビットコインを攻撃することも考えられます。これらのシナリオは理論的には可能です。

間違いなく、深刻なハッシュレート攻撃は短期的にビットコインへの信頼を損ない、価格の大幅な下落を引き起こす可能性があります。しかし、ビットコインネットワークとソフトウェアは常に進化しているため、攻撃はビットコインコミュニティによる対策に直面することになります。

[[consensus_changes]]
=== コンセンサスルールの変更

コンセンサスのルールは、トランザクションとブロックの有効性を決定します。これらのルールは、すべてのビットコインノード間の協力の基礎であり、すべてのローカルな視点を単一の一貫したブロックチェーンに収束させる責任を負っています。

コンセンサスルールは短期的には不変であり、すべてのノードで一貫している必要がありますが、長期的には不変ではありません。ビットコインシステムを進化させ、開発するために、ルールは新機能、改善、またはバグ修正を受け入れるために時折変更されることがあります。しかし、従来のソフトウェア開発とは異なり、コンセンサスシステムのアップグレードははるかに困難であり、すべての参加者間の調整が必要です。

[[hard_forks]]
==== ハードフォーク

<<forks>> では、ビットコインネットワークが一時的に分岐し、ネットワークの一部が異なるブロックチェーンの枝を短期間追従する様子を見ました。これはネットワークの通常の動作の一部として自然に発生し、一つ以上のブロックが採掘された後にネットワークが共通のブロックチェーンに収束することを確認しました。

ネットワークが二つのチェーンを追従するように分岐する別のシナリオがあります。それはコンセンサスルールの変更です。このタイプのフォークは _ハードフォーク_ と呼ばれます。フォークの後、ネットワークが単一のチェーンに収束しない可能性があるためです。代わりに、二つのチェーンが独立して進化することができます。ハードフォークは、ネットワークの一部が他の部分とは異なるコンセンサスルールのセットで動作しているときに発生します。これはバグが原因で発生することもあれば、コンセンサスルールの実装を意図的に変更した結果として発生することもあります。

ハードフォークはコンセンサスルールを変更するために使用できますが、システム内のすべての参加者間での調整が必要です。新しいコンセンサスルールにアップグレードしないノードは、コンセンサスメカニズムに参加できず、ハードフォークの瞬間に別のチェーンに追いやられます。したがって、ハードフォークによって導入された変更は「前方互換性がない」と考えることができ、アップグレードされていないシステムは新しいコンセンサスルールのためにブロックを処理できなくなります。

具体的な例を用いて、ハードフォークの仕組みを見てみましょう。

<<blockchainwithforks>> は二つのフォークを持つブロックチェーンを示しています。ブロック高 4 で、一つのブロックフォークが発生します。これは <<forks>> で見た自発的なフォークのタイプです。ブロック 5 の採掘により、ネットワークは一つのチェーンに収束し、フォークは解決されます。

[[blockchainwithforks]]
.フォークを持つブロックチェーン。
image::images/mbc3_1202.png[フォークを持つブロックチェーン]

しかしその後、ブロック高 6 で、コンセンサスルールの変更を伴う新しいクライアントの実装がリリースされます。ブロック高 7 から、この新しい実装を実行しているマイナーは新しいタイプのビットコインを受け入れます。これを「フーコイン」と呼びましょう。その直後、新しい実装を実行しているノードがフーコインを含むトランザクションを作成し、更新されたソフトウェアを持つマイナーがこのトランザクションを含むブロック 7b を採掘します。

ソフトウェアをアップグレードして foocoin を検証するようにしていないノードやマイナーは、今やブロック 7b を処理できなくなります。彼らの視点から見ると、foocoin を含むトランザクションとそのトランザクションを含むブロック 7b の両方が、古いコンセンサスルールに基づいて評価されるため無効です。これらのノードはトランザクションとブロックを拒否し、それらを伝播しません。古いルールを使用しているマイナーはブロック 7b を受け入れず、ブロック 6 を親とする候補ブロックを採掘し続けます。実際、古いルールを使用しているマイナーは、接続しているすべてのノードが古いルールに従ってブロックを伝播していない場合、ブロック 7b を受け取ることさえないかもしれません。最終的に、彼らは古いルールの下で有効で、foocoin を含むトランザクションを含まないブロック 7a を採掘できるようになります。

この時点から、2 つのチェーンは分岐し続けます。"b" チェーンのマイナーは foocoin を含むトランザクションを受け入れ、採掘し続けますが、"a" チェーンのマイナーはこれらのトランザクションを無視し続けます。たとえブロック 8b が foocoin トランザクションを含んでいなくても、"a" チェーンのマイナーはそれを処理できません。彼らにとって、それは無効なブロックに見えます。なぜなら、その親である "7b" が有効なブロックとして認識されていないからです。

===== ハードフォーク：ソフトウェア、ネットワーク、マイニング、チェーン

ソフトウェア開発者にとって、「フォーク」という用語は別の意味を持ち、「ハードフォーク」という用語に混乱を加えます。オープンソースソフトウェアでは、フォークは開発者のグループが異なるソフトウェアロードマップを選択し、オープンソースプロジェクトの競合実装を開始することを指します。コンセンサスルールのバグとコンセンサスルールの意図的な変更という、ハードフォークにつながる 2 つの状況についてはすでに説明しました。コンセンサスルールの意図的な変更の場合、ソフトウェアフォークがハードフォークに先行します。しかし、このタイプのハードフォークが発生するためには、コンセンサスルールの新しいソフトウェア実装が開発され、採用され、開始される必要があります。

コンセンサスルールの変更を試みたソフトウェアフォークの例として、Bitcoin XT や Bitcoin Classic があります。しかし、これらのプログラムはどちらもハードフォークには至りませんでした。ソフトウェアフォークは必要な前提条件ですが、それ自体ではハードフォークが発生するための十分条件ではありません。ハードフォークが発生するためには、競合する実装が採用され、新しいルールがマイナー、ウォレット、仲介ノードによって有効化される必要があります。逆に、Bitcoin Core の代替実装やソフトウェアフォークの中には、コンセンサスルールを変更せず、バグがない限り、ネットワーク上で共存し、ハードフォークを引き起こすことなく相互運用できるものも多数あります。

コンセンサスルールは、トランザクションやブロックの検証において、明白かつ明示的な方法で異なる場合があります。また、Bitcoin スクリプトやデジタル署名などの暗号プリミティブに適用されるコンセンサスルールの実装において、より微妙な方法で異なる場合もあります。最後に、システムの制限や実装の詳細によって課される暗黙のコンセンサス制約により、予期しない方法でコンセンサスルールが異なる場合もあります。後者の例として、Bitcoin Core 0.7 から 0.8 へのアップグレード中に発生した予期しないハードフォークがあり、これはブロックを保存するために使用されていた Berkeley DB 実装の制限によって引き起こされました。

概念的には、ハードフォークは 4 つの段階で進行すると考えることができます：ソフトウェアフォーク、ネットワークフォーク、マイニングフォーク、チェーンフォークです。このプロセスは、開発者によって修正されたコンセンサスルールを持つクライアントの代替実装が作成されるときに始まります。

このフォークされた実装がネットワークに展開されると、一定の割合のマイナー、ウォレットユーザ、および中間ノードがこの実装を採用して実行する可能性があります。最初に、ネットワークがフォークします。元のコンセンサスルールに基づくノードは、新しいルールの下で作成されたトランザクションやブロックを拒否します。さらに、元のコンセンサスルールに従うノードは、これらの無効なトランザクションやブロックを送信しているノードから切断される可能性があります。その結果、ネットワークは 2 つに分割されるかもしれません。古いノードは古いノードにのみ接続し、新しいノードは新しいノードにのみ接続されます。新しいルールに基づく単一のブロックがネットワークを通じて波及し、2 つのネットワークへの分割を引き起こします。

新しいマイナーは新しいブロックの上にマイニングするかもしれませんが、古いマイナーは古いルールに基づいた別のチェーンをマイニングします。分割されたネットワークでは、異なるコンセンサスルールで動作するマイナーが互いのブロックを受け取ることはおそらくないでしょう。なぜなら、彼らは二つの別々のネットワークに接続されているからです。

===== マイナーの分岐と難易度

マイナーが二つの異なるチェーンをマイニングするように分岐すると、ハッシュパワーはチェーン間で分割されます。マイニングパワーは二つのチェーン間でどのような割合でも分割される可能性があります。新しいルールは少数派によってのみ、またはマイニングパワーの大多数によってのみ従われるかもしれません。

例えば、80%対20%の分割を仮定し、マイニングパワーの大多数が新しいコンセンサスルールを使用しているとします。また、フォークがリターゲティング期間の直後に発生すると仮定します。

二つのチェーンはそれぞれリターゲティング期間から難易度を引き継ぎます。新しいコンセンサスルールには、以前利用可能だったマイニングパワーの80%がコミットされます。このチェーンの視点から見ると、マイニングパワーは前の期間に比べて突然20%減少したことになります。ブロックは平均して12.5分ごとに見つかり、このチェーンを拡張するために利用可能なマイニングパワーの20%の減少を表しています。このブロック発行率は（ハッシュパワーに変化がない限り）2,016ブロックがマイニングされるまで続きます。これは約25,200分（1ブロックあたり12.5分）、つまり17.5日かかります。17.5日後、リターゲットが行われ、難易度は再び10分ごとのブロックを生成するように調整されます（このチェーンのハッシュパワーの減少に基づいて20%減少）。

少数派のチェーンは、古いルールの下でハッシュパワーのわずか 20% でマイニングを行うため、はるかに困難な作業に直面します。このチェーンでは、ブロックは平均して 50 分ごとにマイニングされることになります。難易度は 2,016 ブロックの間調整されず、これには 100,800 分、つまり約 10 週間かかります。ブロックごとの容量が固定されていると仮定すると、1 時間あたりに記録できるトランザクションのブロック数が減少するため、トランザクション容量も 5 分の 1 に減少します。

===== Contentious hard forks

これは、分散型コンセンサスのためのソフトウェア開発の夜明けです。他の開発における革新がソフトウェアの方法と製品の両方を変え、新しい方法論、新しいツール、そして新しいコミュニティを生み出したように、コンセンサスソフトウェアの開発もまた、コンピュータサイエンスの新しいフロンティアを表しています。ビットコイン開発の議論、実験、試練から、新しい開発ツール、実践、方法論、コミュニティが生まれるでしょう。

ハードフォークは、少数派にアップグレードするか少数派チェーンに留まるかを強いるため、リスクがあると見なされています。システム全体を 2 つの競合するシステムに分割するリスクは、多くの人にとって受け入れがたいリスクと見なされています。その結果、ネットワーク全体からのほぼ全会一致の支持がない限り、コンセンサスルールのアップグレードを実施するためにハードフォークのメカニズムを使用することに多くの開発者が消極的です。ほぼ全会一致の支持がないハードフォークの提案は、システムの分割を危険にさらすことなく試みるにはあまりにも論争的であると見なされます。

すでにハードフォークのリスクに対処するための新しい方法論が登場しています。次のセクションでは、ソフトフォークとコンセンサスの変更をシグナリングおよびアクティベーションする方法について見ていきます。

==== Soft Forks

すべてのコンセンサスルールの変更がハードフォークを引き起こすわけではありません。前方互換性のないコンセンサスの変更のみがフォークを引き起こします。変更が未修正のクライアントでも以前のルールの下でトランザクションやブロックを有効と見なすように実装されている場合、フォークなしで変更が行われることができます。

用語 _ソフトフォーク_ は、このアップグレード方法を「ハードフォーク」と区別するために導入されました。実際には、ソフトフォークはフォークではありません。ソフトフォークは、アップグレードされていないクライアントが新しいルールに従って動作し続けることを可能にする、コンセンサスルールへの前方互換の変更です。

ソフトフォークの一つの側面として、ソフトフォークのアップグレードはコンセンサスルールを制約するためにのみ使用でき、拡張するためには使用できないという点があります。前方互換性を保つためには、新しいルールの下で作成されたトランザクションやブロックが古いルールの下でも有効でなければなりませんが、その逆は成り立ちません。新しいルールは有効なものを制限することしかできません。そうでなければ、古いルールの下で拒否されたときにハードフォークを引き起こしてしまいます。

ソフトフォークはさまざまな方法で実装できます。この用語は特定の方法を指定するものではなく、共通点を持つ一連の方法を指します。それは、すべてのノードがアップグレードを必要とせず、アップグレードされていないノードをコンセンサスから排除しないという点です。

Bitcoin では、NOP オペコードの再解釈に基づいて 2 つのソフトフォークが実装されました。Bitcoin Script には将来の使用のために予約された 10 個のオペコード、NOP1 から NOP10 がありました。コンセンサスルールの下では、スクリプトにこれらのオペコードが存在することは無効な操作として解釈され、何の効果もありません。NOP オペコードの後の実行は、それが存在しなかったかのように続行されます。

したがって、ソフトフォークは NOP コードの意味を変更して新しい意味を持たせることができます。例えば、BIP65 (+CHECKLOCKTIMEVERIFY+) は NOP2 オペコードを再解釈しました。BIP65 を実装しているクライアントは NOP2 を +OP_CHECKLOCKTIMEVERIFY+ として解釈し、このオペコードを含むロックスクリプトに絶対ロックタイムのコンセンサスルールを課します。この変更はソフトフォークです。なぜなら、BIP65 の下で有効なトランザクションは、BIP65 を実装していない（知らない）クライアントでも有効だからです。古いクライアントにとって、そのスクリプトには無視される NOP コードが含まれています。

===== ソフトフォークに対する批判

NOP オペコードに基づくソフトフォークは比較的議論が少ないです。NOP オペコードは、非破壊的なアップグレードを可能にすることを目的として Bitcoin Script に配置されました。

しかし、多くの開発者は、他の方法によるソフトフォークのアップグレードが許容できないトレードオフをもたらすと懸念しています。ソフトフォークの変更に対する一般的な批判には以下のものがあります。

技術的負債：ソフトフォークはハードフォークのアップグレードよりも技術的に複雑であるため、_技術的負債_ を導入します。技術的負債とは、過去の設計上のトレードオフのために将来的なコードの保守コストが増加することを指します。コードの複雑さは、バグやセキュリティの脆弱性の可能性を高めます。

検証の緩和：未修正のクライアントは、変更されたコンセンサスルールを評価せずにトランザクションを有効と見なします。実際には、未修正のクライアントは新しいルールに対して盲目であるため、コンセンサスルールの全範囲を使用して検証していません。これは NOP ベースのアップグレードや他のソフトフォークのアップグレードにも当てはまります。

不可逆的なアップグレード：ソフトフォークは追加のコンセンサス制約を持つトランザクションを作成するため、実際には不可逆的なアップグレードとなります。ソフトフォークのアップグレードがアクティベートされた後に逆転された場合、新しいルールの下で作成されたトランザクションは、古いルールの下で資金の損失を引き起こす可能性があります。例えば、CLTV トランザクションが古いルールで評価されると、タイムロックの制約がなく、いつでも使用可能です。したがって、批評家は、バグのために逆転しなければならなかった失敗したソフトフォークは、ほぼ確実に資金の損失につながると主張しています。

[[softforksignaling]]
===== ブロックバージョンによるソフトフォークのシグナリング

ソフトフォークは未修正のクライアントがコンセンサス内で動作し続けることを可能にするため、ソフトフォークを「アクティベート」するための一つのメカニズムは、マイナーが新しいコンセンサスルールを施行する準備ができていることをシグナルすることです。すべてのマイナーが新しいルールを施行すれば、未修正のノードがアップグレードされたノードが拒否するブロックを受け入れるリスクはありません。このメカニズムは BIP34 によって導入されました。

===== BIP34: シグナリングとアクティベーション

BIP34 は、特定のコンセンサスルール変更に対する準備ができたことをマイナーがシグナルできるようにするために、ブロックバージョンフィールドを使用しました。BIP34 の前は、ブロックバージョンは _コンセンサス_ によってではなく、_慣習_ によって「1」に設定されていました。

BIP34 は、コインベーストランザクションのコインベースフィールド（入力）にブロックの高さを含めることを要求するコンセンサスルールの変更を定義しました。BIP34 の前は、コインベースにはマイナーが含めることを選んだ任意のデータを含めることができました。BIP34 のアクティベーション後、有効なブロックはコインベースの先頭に特定のブロックの高さを含め、ブロックバージョン番号が「2」以上である必要がありました。

BIP34 のルールを施行する準備ができたことをシグナルするために、マイナーはブロックバージョンを「1」ではなく「2」に設定しました。これにより、すぐにバージョン「1」のブロックが無効になるわけではありませんでした。アクティベーション後、バージョン「1」のブロックは無効となり、すべてのバージョン「2」のブロックはコインベースにブロックの高さを含める必要がありました。

BIP34 は、1,000 ブロックのローリングウィンドウに基づく二段階のアクティベーションメカニズムを定義しました。マイナーは、バージョン番号を「2」としてブロックを構築することで、BIP34 に対する個々の準備をシグナルしました。厳密に言えば、これらのブロックはまだコインベーストランザクションにブロックの高さを含めるという新しいコンセンサスルールに従う必要はありませんでした。なぜなら、コンセンサスルールはまだアクティベートされていなかったからです。コンセンサスルールは二段階でアクティベートされました：

- もし 75%（直近の 1,000 ブロックのうち 750 ブロック）がバージョン「2」でマークされている場合、バージョン「2」のブロックはコインベーストランザクションにブロックの高さを含めなければならず、そうでなければ無効として拒否されます。バージョン「1」のブロックはネットワークによってまだ受け入れられ、ブロックの高さを含める必要はありません。この期間中、古いコンセンサスルールと新しいコンセンサスルールは共存します。

- 95%（直近 1,000 ブロックのうち 950 ブロック）がバージョン「2」になると、バージョン「1」ブロックはもはや有効と見なされません。バージョン「2」ブロックは、コインベースにブロックの高さが含まれている場合にのみ有効です（前の閾値に従います）。その後、すべてのブロックは新しいコンセンサスルールに従わなければならず、すべての有効なブロックはコインベーストランザクションにブロックの高さを含める必要があります。

BIP34 ルールの下でのシグナリングとアクティベーションが成功した後、このメカニズムはソフトフォークをアクティベートするためにさらに 2 回使用されました：

- https://oreil.ly/Xes2l[BIP66]
  厳密な DER エンコーディングの署名は、ブロックバージョン「3」で BIP34 スタイルのシグナリングによってアクティベートされました。

- https://oreil.ly/pk8tz[BIP65]
  +CHECKLOCKTIMEVERIFY+ は、ブロックバージョン「4」で BIP34 スタイルのシグナリングによってアクティベートされました。

BIP65 のアクティベーション後、BIP34 のシグナリングとアクティベーションメカニズムは廃止され、次に説明する BIP9 シグナリングメカニズムに置き換えられました。

[role="less_space pagebreak-before"]
[[bip9]]
===== BIP9: シグナリングとアクティベーション

BIP34、BIP66、BIP65 によって使用された ((("consensus rules", "soft forks", "BIP9 signaling/activation", tertiary-sortas="BIP009", id="consensus-soft-bip9")))((("forks", "soft forks", "BIP9 signaling/activation", tertiary-sortas="BIP009", id="fork-soft-bip9")))((("soft forks", "BIP9 signaling/activation", secondary-sortas="BIP009", id="soft-fork-bip9")))((("signaling", "BIP9", secondary-sortas="BIP009", id="signal-bip9")))((("activation (soft forks)", "BIP9", secondary-sortas="BIP009", id="activation-bip9")))((("BIP9 signaling/activation", primary-sortas="BIP009", id="bip9-ch12")))メカニズムは、3 つのソフトフォークをアクティベートするのに成功しました。しかし、いくつかの制限があったため、置き換えられました。

- ブロックバージョンの整数値を使用することで、一度に一つのソフトフォークしかアクティベートできず、ソフトフォーク提案間の調整と優先順位付けや順序の合意が必要でした。

- さらに、ブロックバージョンがインクリメントされるため、変更を拒否してから別の変更を提案する明確な方法がありませんでした。古いクライアントがまだ稼働している場合、新しい変更のシグナリングを以前に拒否された変更のシグナリングと誤解する可能性がありました。

- 各新しい変更は、将来の変更のために利用可能なブロックバージョンを不可逆的に減少させました。

BIP9 はこれらの課題を克服し、将来の変更の実装速度と容易さを向上させるために提案されました。

BIP9 はブロックバージョンを整数ではなくビットフィールドとして解釈します。ブロックバージョンが元々バージョン 1 から 4 まで整数として使用されていたため、ビットフィールドとして使用できるのは 29 ビットのみです。これにより、29 の異なる提案に対して独立して同時に準備完了をシグナルすることができます。

BIP9 はまた、シグナリングとアクティベーションの最大時間を設定します。この方法により、マイナーは永遠にシグナルを出し続ける必要がありません。提案が +TIMEOUT+ 期間内（提案で定義）にアクティベートされない場合、その提案は拒否されたと見なされます。提案は異なるビットでシグナリングを再提出し、アクティベーション期間を更新することができます。

さらに、+TIMEOUT+ が経過し、機能がアクティベートまたは拒否された後、シグナリングビットは混乱なく別の機能に再利用できます。したがって、最大 29 の変更を並行してシグナルすることができます。+TIMEOUT+ の後、ビットは新しい変更を提案するために「リサイクル」できます。

[NOTE]
====
シグナリングビットは再利用またはリサイクルできますが、投票期間が重ならない限り、BIP9 の著者はビットの再利用は必要な場合にのみ行うことを推奨しています。古いソフトウェアのバグにより予期しない動作が発生する可能性があります。要するに、29 ビットが一度使用されるまでは再利用を期待すべきではありません。
====

提案された変更は、以下のフィールドを含むデータ構造によって識別されます。


name:: 提案を区別するために使用される短い説明です。多くの場合、提案を説明する BIP を「bipN」として示し、N は BIP 番号です。

bit:: 0 から 28 までのビットで、マイナーがこの提案の承認を示すためにブロックバージョンで使用します。

starttime:: シグナリングが開始される時間 (MTP に基づく) で、この時点以降、ビットの値は提案の準備完了を示すものとして解釈されます。

endtime:: 変更がアクティベーションの閾値に達していない場合に拒否されたと見なされる時間 (MTP に基づく) です。

BIP34 とは異なり、BIP9 は 2,016 ブロックの難易度再調整期間に基づいて、全体の間隔でアクティベーションシグナリングをカウントします。各再調整期間において、提案に対するシグナリングブロックの合計が 95% (2,016 のうち 1,916) を超える場合、提案は 1 つの再調整期間後にアクティベートされます。

BIP9 は、提案のさまざまな段階と遷移を示す提案状態図を提供します。これは <<bip9states>> に示されています。


[[bip9states]]
.BIP9 状態遷移図。
image::images/mbc3_1203.png[BIP9 提案状態遷移図]


提案は、Bitcoin ソフトウェアでそのパラメータが既知 (定義済み) になると +DEFINED+ 状態で開始されます。開始時間以降の MTP を持つブロックに対して、提案状態は +STARTED+ に遷移します。再調整期間内に投票閾値を超え、タイムアウトが超過していない場合、提案状態は +LOCKED_IN+ に遷移します。1 つの再調整期間後、提案は +ACTIVE+ になります。提案はその状態に達すると永続的に +ACTIVE+ 状態に留まります。タイムアウトが経過する前に投票閾値に達しなかった場合、提案状態は +FAILED+ に変わり、拒否された提案を示します。+FAILED+ 提案はその状態に永続的に留まります。

BIP9 は、+CHECKSEQUENCEVERIFY+ と関連する BIPs (68, 112, 113) のアクティベーションのために初めて実装されました。「csv」と名付けられた提案は 2016 年 7 月に成功裏にアクティベートされました。

https://oreil.ly/FoCsz[BIP9 (タイムアウトと遅延を伴うバージョンビット)] に定義されている標準です。

===== BIP8: 強制ロックインと早期アクティベーション

BIP9 は CSV 関連のソフトフォークで成功裏に使用されましたが、次のソフトフォークのコンセンサス変更の実装でも、マイナーによるアクティベーションを試みました。しかし、_segwit_ と呼ばれるそのソフトフォーク提案に反対する人々がいて、数か月間、非常に少数のマイナーしか segwit の実施準備を示しませんでした。

後に、一部のマイナー、特に反対者に関連するマイナーが、_covert ASICBoost_ と呼ばれる機能を使用して他のマイナーに対して隠れた優位性を持っている可能性があることが判明しました。意図せずに、segwit は covert ASICBoost の使用能力を妨げていました。もし segwit がアクティベートされると、それを使用しているマイナーはその隠れた優位性を失うことになります。

コミュニティがこの利益相反を発見した後、一部のユーザは、特定のルールに従わない限りマイナーからのブロックを受け入れないという力を行使したいと決めました。ユーザが最終的に望んだルールは、segwit によって追加された新しいルールでしたが、ユーザは、十分な数のマイナーがその準備を示した場合に segwit のルールを施行する予定の多数のノードを利用して努力を倍増させたいと考えました。ある匿名の開発者が BIP148 を提案しました。これは、実装するノードが、特定の日付から segwit がアクティベートされるまで、segwit に対してシグナルを送らないすべてのブロックを拒否することを要求するものでした。

実際に BIP148 コードを実行したユーザは限られていましたが、多くの他のユーザもその意図に賛同しており、BIP148 にコミットする準備ができていたようです。BIP148 が発効する数日前、ほとんどのマイナーが segwit のルールを施行する準備ができていることを示し始めました。segwit はその約 2 週間後にロックインの閾値に達し、その約 2 週間後に有効化されました。

多くのユーザは、マイナーが 1 年間シグナルを出さないことで有効化の試みを成功させないようにできるのは BIP9 の欠陥であると考えるようになりました。彼らは、特定のブロック高でソフトフォークが有効化されることを保証するメカニズムを望んでいましたが、同時にマイナーが早期にロックインの準備ができていることを示すことも可能にしたいと考えていました。

そのために開発された方法が BIP8 で、これは BIP9 に似ていますが、マイナーがソフトフォーク提案を施行する準備ができていることを示さなければならない +MUST_SIGNAL+ 期間を定義しています。

2021 年に taproot 提案を有効化しようとするために BIP8 を使用したソフトウェアが公開され、少なくとも少数のユーザがそのソフトウェアを実行した証拠があります。そのユーザの中には、マイナーに taproot を有効化させるために BIP8 を使用する意欲が、最終的にそれが有効化された理由であると主張する人もいます。彼らは、もし taproot が迅速に有効化されなかった場合、他のユーザも BIP8 を実行し始めていたと主張しています。残念ながら、何が起こったかを証明する方法はなく、BIP8 が taproot の有効化にどれだけ貢献したかを確実に言うことはできません。

===== スピーディトライアル：早期失敗か、最終的な成功か

BIP9 自体は提案に対する広範な支持にもかかわらず、segwit のアクティベーションには至らなかったように見えましたが、多くのプロトコル開発者にとって BIP9 自体が失敗であるとは明確ではありませんでした。前述のように、マイナーが最初に segwit の支持を示さなかったのは、一度限りの利益相反が主な原因であり、将来的には適用されない可能性がありました。ある人々にとっては、BIP9 を再度試す価値があるように思われました。他の人々は反対し、BIP8 を使用したいと考えていました。

特定のアクティベーションアイデアに最も関心を持つ人々の間で数か月にわたる議論の後、taproot をアクティベートするための妥協案が提案されました。BIP9 の修正版が提案され、マイナーに taproot ルールを施行する意図を示すための非常に短い時間を与えることになりました。シグナリングが成功しなかった場合、別のアクティベーションメカニズムが使用される可能性がありました（または、アイデアが放棄される可能性もありました）。シグナリングが成功した場合、施行は約 6 か月後に指定されたブロック高で開始されることになりました。このメカニズムは、それを推進した人の一人によって _スピーディトライアル_ と名付けられました。

スピーディトライアルアクティベーションが試みられ、マイナーは迅速に taproot のルールを施行する意志を示し、約 6 か月後に taproot は無事にアクティベートされました。スピーディトライアルの支持者にとって、それは明確な成功でした。他の人々は BIP8 が使用されなかったことに失望していました。

スピーディトライアルが将来のソフトフォークのアクティベーション試行に再び使用されるかどうかは明確ではありません。

==== コンセンサスソフトウェア開発

コンセンサスソフトウェアは進化を続けており、コンセンサスルールを変更するためのさまざまなメカニズムについて多くの議論があります。その性質上、ビットコインは変更に対する調整とコンセンサスに非常に高いハードルを設定しています。分散型システムとして、ネットワークの参加者に意志を押し付けることができる「権威」は存在しません。権力はマイナー、プロトコル開発者、ウォレット開発者、取引所、商人、エンドユーザなどの複数の構成員の間に分散されています。これらの構成員のいずれかが一方的に決定を下すことはできません。例えば、マイナーは単純多数（51%）でトランザクションを検閲することができますが、他の構成員の同意によって制約されています。彼らが一方的に行動した場合、他の参加者は彼らのブロックを受け入れることを拒否し、経済活動を少数派チェーンに維持するかもしれません。経済活動（トランザクション、商人、ウォレット、取引所）がなければ、マイナーは空のブロックで価値のない通貨を採掘することになります。この権力の分散は、すべての参加者が調整しなければ変更が行えないことを意味します。現状維持はこのシステムの安定した状態であり、非常に大多数の強いコンセンサスがある場合にのみ、わずかな変更が可能です。ソフトフォークの 95% の閾値はこの現実を反映しています。

コンセンサス開発において完璧な解決策は存在しないことを認識することが重要です。ハードフォークとソフトフォークの両方にはトレードオフがあります。ある種の変更に対してはソフトフォークがより良い選択かもしれませんし、他の変更に対してはハードフォークがより良い選択かもしれません。完璧な選択は存在せず、どちらもリスクを伴います。コンセンサスソフトウェア開発の一貫した特徴は、変更が難しく、コンセンサスが妥協を強いることです。

これをコンセンサスシステムの弱点と見る人もいますが、いずれはこれがシステムの最大の強みであると感じるかもしれません。

この本のこの時点で、ビットコインシステム自体についての話は終わりました。残っているのは、ビットコインの上に構築されたソフトウェア、ツール、その他のプロトコルです。
