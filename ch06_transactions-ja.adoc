[[c_transactions]]
== トランザクション

通常、現金を物理的に移動させる方法は、ビットコインを移動させる方法とはほとんど似ていません。物理的な現金はベアラートークンです。アリスがボブに支払う際には、ドル紙幣のようなトークンをいくつか手渡します。それに比べて、ビットコインは物理的にもデジタルデータとしても存在しません。アリスはボブにビットコインを手渡したり、メールで送ったりすることはできません。

代わりに、アリスがボブに土地の支配権を移転する方法を考えてみてください。彼女は物理的に土地を持ち上げてボブに手渡すことはできません。むしろ、アリスが所有する土地を記述する何らかの記録（通常は地方自治体によって管理されている）が存在します。アリスはその土地をボブに移転するために、政府に記録を更新してボブがその土地を所有していると記載させます。

ビットコインも同様の方法で動作します。すべてのビットコインフルノードには、アリスがいくつかのビットコインを管理していることを示すデータベースが存在します。アリスはフルノードにデータベースを更新させ、アリスのビットコインの一部がボブによって管理されるようにすることでボブに支払います。アリスがフルノードにデータベースを更新させるために使用するデータは、_トランザクション_ と呼ばれます。これは、アリスやボブの身元を直接使用せずに行われます。詳細は <<c_authorization_authentication>> で説明します。

この章では、ビットコイントランザクションを分解し、その各部分を調べて、どのようにして非常に表現力豊かで驚くほど信頼性の高い価値の移転を可能にしているかを見ていきます。

[[tx_structure]]
=== シリアライズされたビットコイントランザクション

<<exploring_and_decoding_transactions>> では、ビットコインコアを使用して、txindex オプションを有効にし、アリスからボブへの支払いを含むトランザクションのコピーを取得しました。<<alice_tx_serialized_reprint>> に示すように、その支払いを含むトランザクションを再度取得しましょう。

[[alice_tx_serialized_reprint]]
.アリスのシリアライズされたトランザクション
====
----
$ bitcoin-cli getrawtransaction 466200308696215bbc949d5141a49a41\
38ecdfdfaa2a8029c1f9bcecd1f96177


Bitcoin Core のシリアライズ形式は特別です。なぜなら、これはトランザクションへのコミットメントを行い、Bitcoin の P2P ネットワークを通じてそれらを中継するために使用される形式だからです。しかし、それ以外のプログラムは、同じデータをすべて送信する限り、異なる形式を使用することができます。ただし、Bitcoin Core の形式は送信するデータに対して合理的にコンパクトで、解析が簡単なので、多くの他の Bitcoin プログラムもこの形式を使用しています。

[TIP]
====
私たちが知っている限り、他に広く使用されているトランザクションシリアライズ形式は、部分的に署名されたビットコイントランザクション (PSBT) 形式だけです。これは BIP 174 と 370 (他の BIP で文書化された拡張機能を含む) で文書化されています。PSBT は、信頼できないプログラムがトランザクションテンプレートを生成し、それを必要な秘密鍵やその他の機密データを持つ信頼できるプログラム (ハードウェア署名デバイスなど) が検証および更新できるようにします。これを達成するために、PSBT はトランザクションに関する大量のメタデータを保存することを許可しており、標準のシリアライズ形式よりもはるかにコンパクトではありません。この本では PSBT について詳しくは説明しませんが、複数の鍵での署名をサポートする予定のウォレット開発者には強くお勧めします。
====

<<alice_tx_serialized_reprint>> に 16 進数で表示されているトランザクションは、<<alice_tx_byte_map>> にバイトマップとして複製されています。32 バイトを表示するのに 64 の 16 進文字が必要であることに注意してください。このマップはトップレベルのフィールドのみを示しています。トランザクションに現れる順番でそれぞれを調べ、それらが含む追加のフィールドについて説明します。


[[alice_tx_byte_map]]
.Alice のトランザクションのバイトマップ
image::images/mbc3_0601.png["Alice のトランザクションのバイトマップ"]

[[version]]
=== バージョン

シリアル化されたビットコインのトランザクションの最初の四バイトは、そのバージョンです。ビットコイントランザクションの元のバージョンはバージョン 1 (0x01000000) でした。ビットコインのすべてのトランザクションは、バージョン 1 トランザクションのルールに従わなければならず、その多くのルールはこの本全体で説明されています。

バージョン 2 のビットコイントランザクションは、BIP68 ソフトフォークの変更でビットコインのコンセンサスルールに導入されました。BIP68 はシーケンスフィールドに追加の制約を課しますが、それらの制約はバージョン 2 以上のトランザクションにのみ適用されます。バージョン 1 のトランザクションは影響を受けません。同じソフトフォークの一部である BIP112 は、オペコード (++OP_CHECKSEQUENCEVERIFY++) をアップグレードしました。これは、バージョン 2 未満のトランザクションの一部として評価されると失敗します。それら二つの変更を除けば、バージョン 2 トランザクションはバージョン 1 トランザクションと同一です。

[role="less_space pagebreak-before"]
.事前署名されたトランザクションの保護
****
トランザクションをネットワークにブロードキャストしてブロックチェーンに含める前の最後のステップは、それに署名することです。しかし、トランザクションに署名してもすぐにブロードキャストしないことが可能です。その事前署名されたトランザクションを数ヶ月または数年保存しておき、後でブロードキャストする際にブロックチェーンに追加できると信じることができます。その間に、資金を使うための代替トランザクションに署名するのに必要な秘密鍵（または鍵）へのアクセスを失うこともあります。これは仮定の話ではありません。ビットコイン上に構築されたいくつかのプロトコル、特に Lightning Network は、事前署名された [.keep-together]#トランザクション# に依存しています。

これは、プロトコル開発者がビットコインのコンセンサスプロトコルのアップグレードをユーザに支援する際の課題を生み出します。BIP68 がシーケンスフィールドに対して行ったような新しい制約を追加することは、いくつかの事前署名されたトランザクションを無効にする可能性があります。同等のトランザクションのための新しい署名を作成する方法がない場合、事前署名されたトランザクションで使われる資金は永久に失われます。

この問題は、バージョン番号などのアップグレード用にいくつかのトランザクション機能を予約しておくことで解決されます。BIP68 の前に事前署名されたトランザクションを作成していた人は、バージョン 1 のトランザクションを使用していたはずなので、BIP68 の追加制約をバージョン 2 以上のトランザクションにのみ適用することは、事前署名されたトランザクションを無効にしないはずです。

事前署名されたトランザクションを使用するプロトコルを実装する場合、将来のアップグレード用に予約されている機能を使用しないようにしてください。Bitcoin Core のデフォルトのトランザクションリレーポリシーでは、予約された機能の使用は許可されていません。そのポリシーに準拠しているかどうかをテストするには、Bitcoin mainnet 上で Bitcoin Core の +testmempoolaccept+ RPC を使用できます。

現在、バージョン 3 のトランザクションを使用し始める提案が広く検討されています。この提案は、コンセンサスルールを変更することを目的としておらず、Bitcoin フルノードがトランザクションをリレーする際のポリシーのみを変更しようとしています。この提案の下では、バージョン 3 のトランザクションは、後述する特定のサービス拒否 (DoS) 攻撃を防ぐために追加の制約を受けることになります <<transaction_pinning>>。

### 拡張マーカーとフラグ

例として示したシリアライズされたトランザクションの次の 2 つのフィールドは、Bitcoin のコンセンサスルールに対する Segregated Witness (Segwit) ソフトフォークの変更の一部として追加されました。このルールは BIP141 と BIP143 に従って変更されましたが、_拡張シリアライズ形式_ は BIP144 で定義されています。

トランザクションにウィットネス構造が含まれている場合 (これについては <<witness_structure>> で説明します)、マーカーはゼロ (0x00) でなければならず、フラグはゼロ以外でなければなりません。現在の P2P プロトコルでは、フラグは常に 1 (0x01) であるべきです。代替フラグは後のプロトコルアップグレード用に予約されています。

トランザクションがウィットネススタックを必要としない場合、マーカーとフラグは存在してはいけません。これは、現在 _レガシーシリアライゼーション_ と呼ばれる、ビットコインのトランザクションシリアライゼーション形式の元のバージョンと互換性があります。詳細は <<legacy_serialization>> を参照してください。

レガシーシリアライゼーションでは、マーカーバイトは入力の数 (ゼロ) として解釈されます。トランザクションはゼロ入力を持つことができないため、マーカーは現代のプログラムに拡張シリアライゼーションが使用されていることを示します。フラグフィールドも同様の信号を提供し、将来シリアライゼーション形式を更新するプロセスを簡素化します。

[[inputs]]
=== 入力

入力フィールドにはいくつかの他のフィールドが含まれていますので、<<alice_tx_input_map>> でそれらのバイトのマップを示すことから始めましょう。

[[alice_tx_input_map]]
.アリスのトランザクションの入力フィールド内のバイトのマップ
image::images/mbc3_0602.png["アリスのトランザクションの入力フィールド内のバイトのマップ"]

==== トランザクション入力リストの長さ

トランザクション入力リストは、トランザクション内の入力の数を示す整数で始まります。最小値は 1 です。明示的な最大値はありませんが、トランザクションの最大サイズに関する制限により、トランザクションは数千の入力に制限されます。この数は compactSize 符号なし整数としてエンコードされます。

[role="less_space pagebreak-before"]
.CompactSize 符号なし整数
****
ビットコインにおける符号なし整数は、しばしば低い値を持ちますが、時には高い値を持つこともあり、通常は compactSize データ型を使用してエンコードされます。CompactSize は可変長整数のバージョンであるため、時には var_int や varint とも呼ばれます（例えば、BIP 37 や 144 のドキュメントを参照してください）。

[WARNING]
====
さまざまなプログラムで異なる種類の可変長整数が使用されています。これは、異なる Bitcoin プログラムでも同様です。例えば、Bitcoin Core はその UTXO データベースを +VarInts+ と呼ばれるデータ型を使ってシリアライズしますが、これは compactSize とは異なります。さらに、Bitcoin ブロックヘッダの nBits フィールドは +Compact+ として知られるカスタムデータ型を使ってエンコードされており、compactSize とは無関係です。Bitcoin トランザクションのシリアライズや Bitcoin P2P プロトコルの他の部分で使用される可変長整数について話すときは、常に compactSize という完全な名前を使用します。
====

0 から 252 までの数値に対して、compactSize 符号なし整数は C 言語のデータ型 +uint8_t+ と同一であり、これはおそらくプログラマにとって馴染みのあるネイティブエンコーディングです。その他の数値については、0xffffffffffffffff までの範囲で、数値の長さを示すバイトが数値の前に付加されますが、それ以外は通常の C 言語でエンコードされた符号なし整数のように見えます：

++++
<table>
<thead>
<tr>
<th>Value</th>
<th>Bytes used</th>
<th>Format</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>≥ <code>0</code> &amp;&amp; ≤ <code>252</code> (<code>0xfc</code>)</p></td>
<td><p><code>1</code></p></td>
<td><p><code>uint8_t</code></p></td>
</tr>
<tr>
<td><p>≥ <code>253</code> &amp;&amp; ≤ <code>0xffff</code></p></td>
<td><p>3</p></td>
<td><p><code>0xfd</code> followed by the number as <code>uint16_t</code></p></td>
</tr>
<tr>
<td><p>≥ <code>0x10000</code> &amp;&amp; ≤ <code>0xffffffff</code></p></td>
<td><p><code>5</code></p></td>
<td><p><code>0xfe</code> followed by the number as <code>uint32_t</code></p></td>
</tr>
<tr>
<td><p>≥ <code>0x100000000</code> &amp;&amp; ≤ <code>0xffffffffffffffff</code></p></td>
<td><p><code>9</code></p></td>
<td><p><code>0xff</code> followed by the number as <code>uint64_t</code></p></td>
</tr>
</tbody>
</table>
++++
****

トランザクション内の各入力は、_outpoint_ フィールド、長さがプレフィックスされた _input script_ フィールド、および _sequence_ の 3 つのフィールドを含む必要があります。

これらのフィールドについては、次のセクションで見ていきます。一部の入力には witness スタックも含まれますが、これはトランザクションの最後にシリアライズされるため、後で検討します。

[[outpoints]]
==== アウトポイント

ビットコインのトランザクションは、フルノードに対してコイン所有情報のデータベースを更新するように要求するものです。アリスが自分のビットコインの一部をボブに移転するためには、まず彼女がそのビットコインを受け取った以前の移転をフルノードに見つけてもらう必要があります。ビットコインの管理はトランザクションのアウトプットで割り当てられるため、アリスはアウトポイントフィールドを使って以前のアウトプットを指し示します。各インプットには単一のアウトポイントが含まれていなければなりません。

アウトポイントには、アリスが今使おうとしているビットコインを受け取ったトランザクションの 32 バイトの txid が含まれています。この txid はビットコインの内部ハッシュのバイト順で表されます。詳細は <<internal_and_display_order>> を参照してください。

トランザクションには複数のアウトプットが含まれることがあるため、アリスはそのトランザクションから使用する特定のアウトプットを識別する必要があります。これを _アウトプットインデックス_ と呼びます。アウトプットインデックスはゼロから始まる 4 バイトの符号なし整数です。

フルノードがアウトポイントに遭遇すると、その情報を使って参照されたアウトプットを見つけようとします。フルノードはブロックチェーン内の以前のトランザクションのみを確認する必要があります。例えば、アリスのトランザクションがブロック 774,958 に含まれている場合、フルノードは彼女のアウトポイントが参照する以前のアウトプットをそのブロックおよびそれ以前のブロックでのみ探します。後のブロックは確認しません。ブロック 774,958 内では、アリスのトランザクションより前にブロックに配置されたトランザクションのみを確認します。これはブロックのマークルツリーのリーフの順序によって決まります（<<merkle_trees>> を参照）。

以前のアウトプットを見つけると、フルノードはそこからいくつかの重要な情報を取得します：

- その以前のアウトプットに割り当てられたビットコインの量。これらのビットコインはすべてこのトランザクションで移転されます。例のトランザクションでは、以前のアウトプットの価値は 100,000 サトシでした。

- その前の出力に対する承認条件です。これらは、その前の出力に割り当てられたビットコインを使用するために満たすべき条件です。

- 確認済みトランザクションの場合、そのトランザクションを確認したブロックの高さと、そのブロックの中央値過去時間 (MTP) です。これは、相対タイムロック (<<relative_timelocks>> で説明) とコインベーストランザクションの出力 (<<coinbase_transactions>> で説明) に必要です。

- 前の出力がブロックチェーンに存在する (または既知の未確認トランザクションとして存在する) こと、そして他のトランザクションがそれを使用していないことの証明です。ビットコインのコンセンサスルールの一つは、有効なブロックチェーン内で同じ出力が複数回使用されることを禁止しています。これは、*二重支払い* に対するルールです。アリスは、同じ前の出力を使ってボブとキャロルに別々のトランザクションで支払うことはできません。同じ前の出力を使用しようとする二つのトランザクションは、*競合トランザクション* と呼ばれます。なぜなら、有効なブロックチェーンに含めることができるのはそのうちの一つだけだからです。

異なるフルノード実装によって、前の出力を追跡するための異なるアプローチが試みられてきました。現在、Bitcoin Core は、必要な情報をすべて保持しつつディスクスペースを最小限に抑えるために最も効果的と考えられる解決策を使用しています。それは、すべての UTXO とその確認ブロックの高さなどの重要なメタデータを保存するデータベースを保持することです。新しいトランザクションのブロックが到着するたびに、それらが使用するすべての出力が UTXO データベースから削除され、彼らが作成するすべての出力がデータベースに追加されます。

[[internal_and_display_order]]
.内部および表示バイト順
****
ビットコインは、ハッシュ関数の出力である _ダイジェスト_ をさまざまな方法で使用します。ダイジェストは、ブロックやトランザクションの一意の識別子を提供し、アドレス、ブロック、トランザクション、署名などのコミットメントに使用され、ビットコインのプルーフ・オブ・ワーク関数で繰り返し使用されます。場合によっては、ハッシュダイジェストがユーザに一つのバイト順で表示され、内部では異なるバイト順で使用されるため、混乱を招くことがあります。たとえば、例のトランザクションのアウトポイントからの前の出力 txid を考えてみましょう。

```
----
eb3ae38f27191aa5f3850dc9cad00492b88b72404f9da135698679268041c54a
----

この txid を使って Bitcoin Core でそのトランザクションを取得しようとすると、エラーが発生し、バイト順を逆にする必要があります。

----
$ bitcoin-cli getrawtransaction \
  eb3ae38f27191aa5f3850dc9cad00492b88b72404f9da135698679268041c54a
error code: -5
error message:
No such mempool or blockchain transaction. 
Use gettransaction for wallet transactions.

$ echo eb3ae38f27191aa5f3850dc9cad00492b88b72404f9da135698679268041c54a \
  | fold -w2 | tac | tr -d "\n"
4ac541802679866935a19d4f40728bb89204d0cac90d85f3a51a19278fe33aeb

$ bitcoin-cli getrawtransaction \
  4ac541802679866935a19d4f40728bb89204d0cac90d85f3a51a19278fe33aeb
02000000000101c25ae90c9f3d40cc1fc509ecfd54b06e35450702...
----

この奇妙な動作は、初期の Bitcoin ソフトウェアの https://oreil.ly/01JH2[設計上の決定] の意図しない結果である可能性があります。実際のところ、Bitcoin ソフトウェアの開発者は、ユーザに表示するトランザクションおよびブロック識別子のバイト順を逆にすることを覚えておく必要があります。

この本では、トランザクションやブロック内に現れるデータを _内部バイト順_ と呼びます。ユーザに表示される形式を _表示バイト順_ と呼びます。一般的な用語のセットとして、内部バージョンを _リトルエンディアンバイト順_、表示バージョンを _ビッグエンディアンバイト順_ と呼ぶこともあります。
****

==== インプットスクリプト

インプットスクリプトフィールドは、レガシートランザクション形式の名残です。私たちの例のトランザクションインプットは、インプットスクリプトにデータを必要としないネイティブセグウィット出力を消費するため、インプットスクリプトの長さプレフィックスはゼロ (0x00) に設定されています。

レガシー出力を消費する長さプレフィックス付きインプットスクリプトの例として、この記事執筆時点での最新ブロックから任意のトランザクションを使用します。

----
6b483045022100a6cc4e8cd0847951a71fad3bc9b14f24d44ba59d19094e0a8c
fa2580bb664b020220366060ea8203d766722ed0a02d1599b99d3c95b97dab8e
41d3e4d3fe33a5706201210369e03e2c91f0badec46c9c903d9e9edae67c167b
9ef9b550356ee791c9a40896
----
```

長さのプレフィックスは、シリアライズされた入力スクリプトフィールドの長さを示す compactSize の符号なし整数です。この場合、1 バイト (0x6b) で、入力スクリプトが 107 バイトであることを示しています。スクリプトの解析と使用については、<<c_authorization_authentication>> で詳しく説明します。

[[sequence]]
==== シーケンス

トランザクションの入力の最後の 4 バイトは、その入力の _シーケンス_ 番号です。このフィールドの使用法と意味は、時代とともに変化してきました。

[[original_tx_replacement]]
===== 元のシーケンスベースのトランザクション置換

シーケンスフィールドは、もともと同じトランザクションの複数のバージョンを作成し、後のバージョンが確認候補として前のバージョンを置き換えることを可能にするために設計されました。シーケンス番号はトランザクションのバージョンを追跡します。

例えば、アリスとボブがカードゲームで賭けをしたいと考えているとします。彼らはまず、それぞれが署名したトランザクションを作成し、両者の署名が必要なスクリプトを持つ出力にお金を預けます。これは _マルチシグネチャ_ スクリプト (_マルチシグ_ と略されます) で、_セットアップトランザクション_ と呼ばれます。その後、彼らはその出力を消費するトランザクションを作成します。

- トランザクションの最初のバージョンは、nSequence 0 (0x00000000) で、アリスとボブに最初に預けたお金を返します。これは _払い戻しトランザクション_ と呼ばれます。この時点では、どちらも払い戻しトランザクションをブロードキャストしません。問題が発生した場合にのみ必要です。

- アリスがカードゲームの最初のラウンドに勝ったので、トランザクションの第 2 バージョンはシーケンス 1 で、アリスに支払われる金額を増やし、ボブの取り分を減らします。彼らは更新されたトランザクションに両方とも署名します。再び、問題が発生しない限り、このバージョンのトランザクションをブロードキャストする必要はありません。

- Bob が第 2 ラウンドに勝利したため、シーケンスが 2 に増加し、Alice のシェアが減少し、Bob のシェアが増加します。彼らは再び署名しますが、ブロードキャストはしません。

- シーケンスが増加し、資金が再分配され、結果として得られるトランザクションに署名されるがブロードキャストされないラウンドがさらに多く続いた後、彼らはトランザクションを最終化することに決めます。資金の最終残高でトランザクションを作成し、シーケンスを最大値 (0xffffffff) に設定してトランザクションを最終化します。このバージョンのトランザクションをブロードキャストし、それがネットワーク全体に中継され、最終的にマイナーによって確認されます。

シーケンスの置換ルールがどのように機能するかを、別のシナリオを考えることで見ることができます。

- Alice がシーケンス 0xffffffff の最終トランザクションをブロードキャストし、その後 Bob が彼の残高が高かった以前のトランザクションの 1 つをブロードキャストしたと想像してみてください。Bob のバージョンのトランザクションはシーケンス番号が低いため、元の Bitcoin コードを使用しているフルノードはそれをマイナーに中継せず、元のコードを使用しているマイナーもそれをマイニングしません。

- 別のシナリオでは、Bob が Alice が最終バージョンをブロードキャストする数秒前に以前のバージョンのトランザクションをブロードキャストしたと想像してみてください。ノードは Bob のバージョンを中継し、マイナーはそれをマイニングしようとしますが、Alice のバージョンがより高いシーケンス番号で到着すると、ノードはそれも中継し、元の Bitcoin コードを使用しているマイナーは Bob のバージョンの代わりにそれをマイニングしようとします。Bob が運良く Alice のバージョンが到着する前にブロックが発見されない限り、確認されるのは Alice のバージョンのトランザクションです。

このタイプのプロトコルは、現在 _ペイメントチャネル_ と呼ばれています。Bitcoin の創設者は、彼に帰属されるメールの中で、これらを _高頻度トランザクション_ と呼び、それをサポートするためにプロトコルに追加された多くの機能を説明しました。後でこれらの他の機能について学び、現代のペイメントチャネルのバージョンが今日の Bitcoin でどのようにますます使用されているかを発見します。

純粋にシーケンスベースのペイメントチャネルにはいくつかの問題がありました。最初の問題は、低いシーケンスのトランザクションを高いシーケンスのトランザクションに置き換えるルールがソフトウェアポリシーの問題に過ぎなかったことです。マイナーがあるバージョンのトランザクションを他のバージョンよりも優先する直接的なインセンティブはありませんでした。第二の問題は、最初にトランザクションを送信した人が運良くそれを確認される可能性があり、たとえそれが最高シーケンスのトランザクションでなくても確認されることがあるということです。運が悪くて数パーセントの確率で失敗するセキュリティプロトコルは、あまり効果的なプロトコルとは言えません。

第三の問題は、トランザクションのあるバージョンを異なるバージョンに無制限に置き換えることが可能だったことです。各置き換えは、ネットワーク上のすべてのリレーするフルノードの帯域幅を消費します。例えば、この記事を書いている時点では、約 50,000 のリレーするフルノードがあります。攻撃者が毎分 1,000 件の置き換えトランザクションを 1 件あたり 200 バイトで作成すると、個人の帯域幅は約 20 KB しか使用しませんが、フルノードネットワークの帯域幅は毎分約 10 GB 使用します。トランザクションが確認されたときに発生する手数料と 20 KB/分の帯域幅のコストを除けば、攻撃者はフルノードオペレーターに大きな負担をかけるためのコストを支払う必要はありません。

この攻撃のリスクを排除するために、シーケンスベースのトランザクション置き換えの元のタイプは、ビットコインソフトウェアの初期バージョンで無効化されました。数年間、ビットコインのフルノードは、特定の入力（アウトポイントで示される）を含む未確認のトランザクションを、同じ入力を含む異なるトランザクションで置き換えることを許可しませんでした。しかし、その状況は永遠には続きませんでした。

[[sequence-bip125]]
===== オプトイン トランザクション置き換えシグナリング

元のシーケンスベースのトランザクション置き換えが悪用の可能性があるため無効化された後、解決策が提案されました。ビットコインコアや他のリレーするフルノードソフトウェアをプログラムして、より高いトランザクション手数料率を支払うトランザクションが、より低い手数料率を支払う競合するトランザクションを置き換えることを許可するというものです。これは _replace by fee_、略して _RBF_ と呼ばれます。一部のユーザや企業は、トランザクション置き換えのサポートをビットコインコアに再度追加することに反対しましたので、置き換えをサポートするために再びシーケンスフィールドを使用するという妥協がなされました。

BIP125 に記載されているように、シーケンスが 0xfffffffe 未満の値に設定されている入力を持つ未確認トランザクションは（つまり、最大値より少なくとも 2 低い）、署名者がより高い手数料率を支払う競合トランザクションによって置き換え可能であることをネットワークに示します。Bitcoin Core はこれらの未確認トランザクションを置き換えることを許可し、他のトランザクションの置き換えを引き続き禁止しました。これにより、置き換えに反対するユーザや企業は、BIP125 シグナルを含む未確認トランザクションを無視して、それらが確認されるまで待つことができました。

現代のトランザクション置き換えポリシーには、手数料率やシーケンスシグナル以上のものがあり、それについては <<rbf>> で説明します。

[[relative_timelocks]]
===== コンセンサスで強制される相対的なタイムロックとしてのシーケンス

<<version>> で学んだように、BIP68 ソフトフォークはバージョン番号 2 以上のトランザクションに新しい制約を追加しました。その制約はシーケンスフィールドに適用されます。

シーケンス値が 2^31^ 未満のトランザクション入力は、相対的なタイムロックを持つと解釈されます。このようなトランザクションは、前の出力（アウトポイントで参照される）が相対的なタイムロックの期間だけ経過した後にのみブロックチェーンに含めることができます。例えば、相対的なタイムロックが 30 ブロックの入力を持つトランザクションは、同じブロックチェーン上で出力が消費されるブロックとその間に少なくとも 29 ブロックがあるブロックでのみ確認されることができます。シーケンスは入力ごとのフィールドであるため、トランザクションには任意の数のタイムロックされた入力を含めることができ、それらすべてが十分に経過している必要があります。無効化フラグにより、相対的なタイムロックを持つ入力（シーケンス < 2^31^）と相対的なタイムロックを持たない入力（シーケンス ≥ 2^31^）の両方を含むトランザクションを作成することができます。

シーケンス値はブロックまたは秒単位で指定されます。タイプフラグは、ブロックをカウントする値と秒単位で時間をカウントする値を区別するために使用されます。タイプフラグは 23 番目の最下位ビット（つまり、値 1<<22）に設定されます。タイプフラグが設定されている場合、シーケンス値は 512 秒の倍数として解釈されます。タイプフラグが設定されていない場合、シーケンス値はブロック数として解釈されます。

シーケンスを相対的なタイムロックとして解釈する場合、最下位 16 ビットのみが考慮されます。フラグ (ビット 32 と 23) が評価されると、シーケンス値は通常 16 ビットのマスク (例：`sequence & 0x0000FFFF`) で「マスク」されます。512 秒の倍数はブロック間の平均時間にほぼ等しいため、16 ビット (2^16^) からのブロックおよび秒単位での最大相対タイムロックは 1 年以上になります。

<<bip_68_def_of_nseq>> は、BIP68 によって定義されたシーケンス値のバイナリレイアウトを示しています。

[[bip_68_def_of_nseq]]
.BIP68 によるシーケンスエンコーディングの定義 (出典：BIP68)。
image::images/mbc3_0603.png["BIP68 definition of sequence encoding"]

シーケンスを使用して相対的なタイムロックを設定するトランザクションは、<<sequence-bip125>> で説明されているように、手数料によるオプトイン置換のシグナルも送信します。

=== Outputs

トランザクションの ((("transactions", "outputs", id="transaction-output")))((("outputs", id="output-transaction")))outputs フィールドには、特定の出力に関連するいくつかのフィールドが含まれています。入力フィールドと同様に、アリスがボブに支払う例のトランザクションからの出力フィールドの特定のバイトを見ていきます。これらのバイトのマップは <<output-byte-map>> に示されています。

[[output-byte-map]]
.アリスのトランザクションからの出力フィールドのバイトマップ。
image::images/mbc3_0604.png["A byte map of the outputs field from Alice's transaction"]

==== Outputs Count

トランザクションの入力セクションの開始と同様に、((("transactions", "outputs", "count")))((("outputs", "count")))outputs フィールドは、このトランザクションの出力数を示すカウントから始まります。これは compactSize 整数であり、ゼロより大きくなければなりません。

この例のトランザクションには 2 つの出力があります。

==== 金額

特定の出力の最初のフィールドはその _金額_ です。Bitcoin Core では「value」とも呼ばれます。これは 8 バイトの符号付き整数で、転送するサトシの数を示します。サトシはオンチェーンのビットコイントランザクションで表現できる最小単位のビットコインです。1 ビットコインには 1 億サトシがあります。

ビットコインのコンセンサスルールでは、出力の値は 0 から 2100 万ビットコイン（2.1 京サトシ）までの範囲であることが許可されています。

//TODO:describe early integer overflow problem

[[uneconomical_outputs]]
===== 非経済的な出力と許可されていないダスト

価値がないにもかかわらず、ゼロ値の出力は他の出力と同じルールで使用することができます。しかし、出力を使用すること（トランザクションの入力として使用すること）はトランザクションのサイズを増加させ、それに伴い支払うべき手数料の額も増加します。出力の値が追加の手数料のコストよりも少ない場合、その出力を使用することは経済的に意味がありません。このような出力は _非経済的な出力_ として知られています。

ゼロ値の出力は常に非経済的な出力です。それを使用するトランザクションの手数料率がゼロであっても、トランザクションに何の価値も提供しません。しかし、多くの他の低い値の出力も意図せずに非経済的になることがあります。たとえば、今日のネットワークの典型的な手数料率では、出力がトランザクションに追加する価値がそれを使用するコストを上回るかもしれませんが、明日には手数料率が上昇し、その出力が非経済的になるかもしれません。

<<outpoints>> で説明されているように、すべての UTXO を追跡する必要があるため、各 UTXO はフルノードを運用するのを少し難しくします。重要な価値を含む UTXO については、最終的にそれを使用するインセンティブがあるため、問題にはなりません。しかし、非経済的な UTXO を管理する人にはそれを使用するインセンティブがないため、フルノードの運用者にとって永続的な負担となる可能性があります。ビットコインの分散化は多くの人がフルノードを運用する意欲に依存しているため、Bitcoin Core などのいくつかのフルノード実装は、未確認トランザクションのリレーとマイニングに影響を与えるポリシーを使用して非経済的な出力の作成を抑制しています。

[role="less_space pagebreak-before"]
新たな非経済的なアウトプットを生成するトランザクションの中継やマイニングに対するポリシーは、非常に小さな値のアウトプットを非常に小さなサイズの粒子に例えて、_ダスト_ ポリシーと呼ばれています。Bitcoin Core のダストポリシーは複雑で、いくつかの任意の数値を含んでいるため、私たちが知っている多くのプログラムは単に 546 サトシ未満のアウトプットをダストと見なし、デフォルトでは中継またはマイニングされないと仮定しています。ダストの制限を下げる提案や、それに対抗する制限を上げる提案が時折ありますので、事前に署名されたトランザクションや多人数プロトコルを使用する開発者は、この本の出版以降にポリシーが変更されていないか確認することをお勧めします。

[TIP]
====
Bitcoin の誕生以来、すべてのフルノードはすべての UTXO のコピーを保持する必要がありましたが、それが常にそうであるとは限りません。いくつかの開発者は Utreexo というプロジェクトに取り組んでおり、フルノードがデータそのものではなく UTXO セットへのコミットメントを保存できるようにしています。最小限のコミットメントは 1 キロバイトか 2 キロバイト程度である可能性があり、これは執筆時点で Bitcoin Core が保存している 5 ギガバイト以上と比較できます。

しかし、Utreexo でも、特にマイナーや新しいブロックを迅速に検証する必要がある他のオペレーションにサービスを提供するノードは、すべての UTXO データを保存する必要があります。つまり、ほとんどのノードが Utreexo を使用する可能性のある未来においても、非経済的なアウトプットはフルノードにとって依然として問題となる可能性があります。
====

Bitcoin Core のダストに関するポリシールールには一つの例外があります。+OP_RETURN+ で始まるアウトプットスクリプト、いわゆる _データキャリアアウトプット_ は、ゼロの値を持つことができます。+OP_RETURN+ オペコードは、その後に何が来てもスクリプトを即座に失敗させるため、これらのアウトプットは決して使用されることがありません。つまり、フルノードはそれらを追跡する必要がないため、Bitcoin Core はこれを利用して、ユーザがブロックチェーンに任意の少量のデータを保存できるようにしつつ、UTXO データベースのサイズを増やさないようにしています。アウトプットが使用不可能であるため、それらは非経済的ではありません。割り当てられたサトシは永久に使用不可能になるため、量をゼロにすることを許可することで、サトシが破壊されないようにしています。

==== Output Scripts

出力額の後には、_出力スクリプト_ の長さを示す compactSize 整数が続きます。このスクリプトには、ビットコインを使用するために満たす必要がある条件が含まれています。ビットコインのコンセンサスルールによれば、出力スクリプトの最小サイズはゼロです。

出力スクリプトのコンセンサスで許可される最大サイズは、チェックされるタイミングによって異なります。トランザクションの出力における出力スクリプトのサイズに明確な制限はありませんが、後のトランザクションは 10,000 バイト以下のスクリプトでのみ以前の出力を使用できます。暗黙的に、出力スクリプトはそれを含むトランザクションとほぼ同じ大きさにすることができ、トランザクションはそれを含むブロックとほぼ同じ大きさにすることができます。

[[anyone-can-spend]]
[TIP]
====
長さがゼロの出力スクリプトは、++OP_TRUE++ を含む入力スクリプトによって使用できます。誰でもその入力スクリプトを作成できるため、誰でも空の出力スクリプトを使用できます。誰でも使用できるスクリプトは本質的に無制限に存在し、ビットコインプロトコルの開発者には _anyone can spends_ として知られています。ビットコインのスクリプト言語のアップグレードは、既存の anyone-can-spend スクリプトに新しい制約を追加し、新しい条件の下でのみ使用可能にすることがよくあります。アプリケーション開発者は通常、anyone-can-spend スクリプトを使用する必要はありませんが、もし使用する場合は、将来のアップグレードがシステムに誤って干渉しないように、ビットコインのユーザや開発者に計画を大声で発表することを強くお勧めします。
====

ビットコインコアのトランザクションの中継とマイニングに関するポリシーは、出力スクリプトをいくつかのテンプレート、_標準トランザクション出力_ と呼ばれるものに効果的に制限しています。これは、スクリプト言語に関連するいくつかの初期のバグが発見された後に最初に実装され、現代のビットコインコアでは、anyone-can-spend アップグレードをサポートし、P2SH リディームスクリプト、segwit v0 ウィットネススクリプト、および segwit v1 (taproot) リーフスクリプトにスクリプト条件を配置するというベストプラクティスを奨励するために保持されています。

現在の標準的なトランザクションテンプレートのそれぞれを見ていき、<<c_authorization_authentication>> でスクリプトを解析する方法を学びます。

[[witness_structure]]
=== 証人の構造

法廷では、証人とは何か重要な出来事を目撃したと証言する人のことです。人間の証人は必ずしも信頼できるわけではないので、法廷では信頼できる証拠のみを受け入れるためにさまざまなプロセスを用いて証人を尋問します。

数学の問題における証人がどのようなものかを想像してみてください。たとえば、重要な問題が _x + 2 == 4_ であり、誰かがその解を目撃したと主張した場合、私たちは何を尋ねるでしょうか？私たちは、2 と合計して 4 になる値を示す数学的な証明を求めるでしょう。人を必要とせず、提案された _x_ の値を証人として使用することもできます。証人が _2_ であると伝えられた場合、方程式にその値を代入し、正しいことを確認し、重要な問題が解決されたと判断できます。

ビットコインを使う際に解決したい重要な問題は、そのビットコインを管理する人または人々によって支出が承認されたかどうかを判断することです。ビットコインのコンセンサスルールを強制する数千のフルノードは人間の証人を尋問することはできませんが、数学の問題を解決するためのデータのみで構成される _証人_ を受け入れることができます。たとえば、_2_ の証人は、次のスクリプトで保護されたビットコインを使うことを可能にします。

----
2 OP_ADD 4 OP_EQUAL
----

もちろん、単純な方程式を解くことができる誰かによってビットコインを使われることを許可するのは安全ではありません。<<c_signatures>> で見るように、偽造不可能なデジタル署名スキームは、特定のデータを秘密に保持できる人だけが解くことができる方程式を使用します。彼らはその秘密データを公開識別子を使用して参照することができます。その公開識別子は _公開鍵_ と呼ばれ、方程式の解は _署名_ と呼ばれます。

次のスクリプトには公開鍵と、支出トランザクションのデータに署名コミットを要求するオペコードが含まれています。単純な例での数字 _2_ のように、署名が私たちの証拠となります。

----
<public key> OP_CHECKSIG
----

証拠、つまりビットコインを保護する数学的問題を解くために使用される値は、フルノードがそれらを検証するために使用されるトランザクションに含める必要があります。初期のビットコイントランザクションで使用されたレガシートランザクション形式では、署名やその他のデータは入力スクリプトフィールドに配置されます。しかし、開発者がビットコイン上で契約プロトコルを実装し始めたとき、<<original_tx_replacement>>で見たように、入力スクリプトフィールドに証拠を配置することにいくつかの重大な問題があることが判明しました。

==== 循環依存

多くのビットコインの契約プロトコルは、順序が異なるトランザクションの署名を含みます。例えば、アリスとボブが両者の署名がなければ支出できないスクリプトに資金を預けたいと考えていますが、どちらかが応答しなくなった場合には自分のお金を取り戻したいとも考えています。簡単な解決策は、順序が異なるトランザクションに署名することです。

- Tx~0~ はアリスとボブからのお金を、両者の署名が必要なスクリプトを持つ出力に支払います。

- Tx~1~ は前の出力を使って二つの出力に支払い、一つはアリスに彼女のお金を返金し、もう一つはボブに彼のお金を返金します（トランザクション手数料のための少額を差し引いて）。

- アリスとボブが Tx~0~ に署名する前に Tx~1~ に署名すれば、どちらもいつでも返金を受けることが保証されます。このプロトコルはどちらも他方を信頼する必要がないため、_信頼不要のプロトコル_ となります。

レガシートランザクション形式でのこの構造の問題は、署名を含む入力スクリプトフィールドを含むすべてのフィールドがトランザクションの識別子 (txid) を導出するために使用されることです。Tx~0~ の txid は Tx~1~ の入力のアウトポイントの一部です。つまり、アリスとボブが Tx~0~ の両方の署名を知るまで Tx~1~ を構築する方法がありません。しかし、Tx~0~ の署名を知っている場合、どちらかが返金トランザクションに署名する前にそのトランザクションをブロードキャストすることができ、返金の保証がなくなります。これが _循環依存_ です。

==== Third-Party Transaction Malleability

より複雑な一連のトランザクションは、循環依存を排除することができますが、多くのプロトコルは新たな懸念に直面します。それは、同じスクリプトを異なる方法で解決することがしばしば可能であるということです。例えば、<<witness_structure>> の単純なスクリプトを考えてみましょう：

----
2 OP_ADD 4 OP_EQUAL
----

このスクリプトを通過させるために入力スクリプトに値 _2_ を提供することができますが、その値を Bitcoin のスタックに置く方法はいくつかあります。以下はその一例です：

----
OP_2
OP_PUSH1 0x02
OP_PUSH2 0x0002
OP_PUSH3 0x000002
...
OP_PUSHDATA1 0x0102
OP_PUSHDATA1 0x020002
...
OP_PUSHDATA2 0x000102
OP_PUSHDATA2 0x00020002
...
OP_PUSHDATA4 0x0000000102
OP_PUSHDATA4 0x000000020002
...
----

入力スクリプト内の数値 _2_ の各代替エンコーディングは、完全に異なる txid を持つわずかに異なるトランザクションを生成します。これらの異なるバージョンのトランザクションは、他のすべてのバージョンと同じ入力（アウトポイント）を消費するため、互いに _競合_ します。競合するトランザクションのセットのうち、有効なブロックチェーンに含まれるのは一つのバージョンだけです。

アリスが入力スクリプトに +OP_2+ を含むトランザクションのバージョンを作成し、その出力をボブに支払うとします。ボブはその出力をすぐにキャロルに支払います。ネットワーク上の誰もが +OP_2+ を +OP_PUSH1 0x02+ に置き換えることができ、アリスの元のバージョンと競合を引き起こします。その競合するトランザクションが確認されると、アリスの元のバージョンを同じブロックチェーンに含めることはできなくなり、ボブのトランザクションがその出力を消費することもできなくなります。アリス、ボブ、キャロルの誰も何も悪いことをしていないのに、ボブのキャロルへの支払いが無効になってしまいます。トランザクションに関与していない第三者がアリスのトランザクションを変更（改変）できる問題を _望ましくない第三者トランザクション改変_ と呼びます。

[TIP]
====
トランザクションを可鍛性にしたい場合があり、Bitcoin はそれをサポートするいくつかの機能を提供しています。特に、<<sighash_types>> で学ぶ署名ハッシュ (sighash) が挙げられます。例えば、アリスは sighash を使ってボブがトランザクション手数料の一部を支払うのを手伝えるようにすることができます。これはアリスのトランザクションを変化させますが、アリスが望む方法でのみです。そのため、_望ましくない_ という言葉を _トランザクションの可鍛性_ という用語に時折付け加えます。私たちや他の Bitcoin 技術ライターが短い用語を使うときでも、ほぼ確実に望ましくないバリアントの可鍛性について話しています((("transactions", "witnesses", "third-party transaction malleability", startref="transaction-witness-third-party")))((("witnesses", "third-party transaction malleability", startref="witness-circular-third-party")))((("third-party transaction malleability", startref="third-party"))。
====

==== Second-Party Transaction Malleability

((("transactions", "witnesses", "second-party transaction malleability", id="transaction-witness-second-party")))((("witnesses", "second-party transaction malleability", id="witness-circular-second-party")))((("second-party transaction malleability", id="second-party")))レガシートランザクション形式が唯一のトランザクション形式だったとき、開発者たちは BIP62 のような第三者による可鍛性を最小限に抑える提案に取り組んでいました。しかし、たとえ第三者による可鍛性を完全に排除できたとしても、契約プロトコルのユーザは別の問題に直面していました。プロトコルに関与する他の誰かの署名が必要な場合、その人は代替署名を生成して txid を変更することができました。

例えば、アリスとボブはお金をスクリプトに預けており、それを使うには両者の署名が必要です。また、彼らはいつでもお金を取り戻せるリファンドトランザクションも作成しています。アリスは一部のお金だけを使いたいと決め、ボブと協力して一連のトランザクションを作成します：

- Tx~0~ はアリスとボブの両方の署名を含み、ビットコインを2つのアウトプットに送ります。最初のアウトプットはアリスのお金の一部を使い、2番目のアウトプットは残りのビットコインをアリスと [.keep-together]#ボブの署名を必要とするスクリプトに戻します。# このトランザクションに署名する前に、新しいリファンドトランザクションである Tx~1~ を作成します。

- Tx~1~ は、Tx~0~ の 2 番目の出力を使って 2 つの新しい出力を生成します。1 つは共同資金のアリスの分、もう 1 つはボブの分です。アリスとボブは、Tx~0~ に署名する前にこのトランザクションに署名します。

ここには循環依存はなく、第三者のトランザクションの改ざんを無視すれば、これは信頼のないプロトコルを提供するように見えます。しかし、Bitcoin の署名の特性として、署名者は署名を作成する際に大きなランダムな数を選ばなければなりません。異なるランダムな数を選ぶと、署名される内容が同じでも異なる署名が生成されます。これは、同じ契約書の 2 部に手書きの署名を提供する場合、それぞれの物理的な署名がわずかに異なるようなものです。

この署名の可変性により、アリスが Tx~0~（ボブの署名を含む）をブロードキャストしようとすると、ボブは代替の署名を生成して異なる txid を持つ競合するトランザクションを作成できます。ボブの代替バージョンの Tx~0~ が確認されると、アリスは事前署名された Tx~1~ を使用して返金を請求することができません。この種の改変は _望ましくない第二者トランザクションの改ざん_ と呼ばれます。

[[segwit]]
==== Segregated Witness

https://oreil.ly/---bp[2011] の早い段階で、プロトコル開発者たちは循環依存、第三者の改ざん、第二者の改ざんの問題を解決する方法を知っていました。アイデアは、トランザクションの txid を生成する計算に入力スクリプトを含めないことでした。入力スクリプトに保持されるデータの抽象名を _witness_ と呼びます。txid を生成する目的でトランザクションの残りのデータを witness から分離するというアイデアは _segregated witness_ (segwit) と呼ばれます。

Segwit を実装するための明白な方法は、古いフルノードと互換性のない Bitcoin のコンセンサスルールの変更を必要とします。これは _ハードフォーク_ とも呼ばれます。ハードフォークには多くの課題が伴いますが、それについては <<hard_forks>> でさらに詳しく説明します。

2015 年後半に、セグウィットの代替アプローチが説明されました。これは、コンセンサスルールへの後方互換性のある変更を使用するもので、_ソフトフォーク_ と呼ばれます。後方互換性とは、変更を実装したフルノードが、変更を行っていないフルノードが無効と見なすブロックを受け入れないことを意味します。このルールを守る限り、新しいフルノードは古いフルノードが受け入れるブロックを拒否することができ、新しいコンセンサスルールを強制する能力を持ちます（ただし、新しいフルノードが Bitcoin ユーザ間の経済的コンセンサスを代表する場合に限ります。この詳細については <<mining>> で探ります）。

ソフトフォークによるセグウィットアプローチは、anyone-can-spend 出力スクリプトに基づいています。0 から 16 までの数字で始まり、2 から 40 バイトのデータが続くスクリプトは、セグウィット出力スクリプトテンプレートとして定義されます。この数字はそのバージョンを示します（例：0 はセグウィットバージョン 0、または _セグウィット v0_ です）。データは _ウィットネスプログラム_ と呼ばれます。また、セグウィットテンプレートを P2SH コミットメントでラップすることも可能ですが、この章ではそれについては扱いません。

古いノードの視点から見ると、これらの出力スクリプトテンプレートは空の入力スクリプトで使用できます。新しいセグウィットルールを認識している新しいノードの視点からは、セグウィット出力スクリプトテンプレートへの支払いは空の入力スクリプトでのみ使用されなければなりません。ここでの違いに注意してください。古いノードは空の入力スクリプトを _許可_ しますが、新しいノードは空の入力スクリプトを _要求_ します。

空の入力スクリプトは、ウィットネスが txid に影響を与えることを防ぎ、循環依存性、第三者によるトランザクションの改ざん、第二者によるトランザクションの改ざんを排除します。しかし、入力スクリプトにデータを入れることができないため、セグウィット出力スクリプトテンプレートのユーザは新しいフィールドを必要とします。そのフィールドは _ウィットネス構造_ と呼ばれます。


証人プログラムと証人構造の導入は Bitcoin を複雑にしますが、これは抽象化を進める既存のトレンドに従っています。<<ch04_keys_addresses>> から思い出してください。元の Bitcoin ホワイトペーパーでは、ビットコインが公開鍵 (pubkeys) に受け取られ、署名 (sigs) で使用されるシステムが記述されています。公開鍵はビットコインを使用する権限がある人（対応する秘密鍵を管理する人）を定義し、署名は支出トランザクションが秘密鍵を管理する人から来たことを認証します。このシステムをより柔軟にするために、Bitcoin の初期リリースでは、ビットコインを出力スクリプトに受け取り、入力スクリプトで使用できるスクリプトが導入されました。その後、契約プロトコルの経験から、ビットコインを証人プログラムに受け取り、証人構造で使用できるようにすることが奨励されました。Bitcoin の異なるバージョンで使用される用語とフィールドは、<<terms_used_authorization_authentication>> に示されています。

++++
<table id="terms_used_authorization_authentication">
<caption>Bitcoin の異なる部分での認可と認証データに使用される用語</caption>
<thead>
<tr>
<th/>
<th><p>認可</p></th>
<th class="right"><p>認証</p></th>
</tr></thead>
<tbody>
<tr>
<td class="fakeheader"><p><strong>ホワイトペーパー</strong></p></td>
<td><p>公開鍵</p></td>
<td class="right"><p>署名</p></td>
</tr>
<tr>
<td  class="fakeheader"><p><strong>オリジナル (レガシー)</strong></p></td>
<td><p>出力スクリプト</p></td>
<td class="right"><p>入力スクリプト</p></td>
</tr>
<tr>
<td  class="fakeheader"><p><strong>Segwit</strong></p></td>
<td><p>証人プログラム</p></td>
<td class="right"><p>証人構造</p></td>
</tr>
</tbody>
</table>
++++

==== 証人構造のシリアル化

入力と出力フィールドに似て、証人構造には他のフィールドが含まれていますので、<<alice_tx_witness_map>> にあるアリスのトランザクションからそれらのバイトのマップを始めます。

[[alice_tx_witness_map]]
.Alice のトランザクションからの witness 構造のバイトマップ。
image::images/mbc3_0605.png["Alice のトランザクションからの witness のバイトマップ"]

入力および出力フィールドとは異なり、全体の witness 構造は含まれる witness スタックの総数を示すものから始まりません。代わりに、これは入力フィールドによって暗示されます。トランザクションの各入力に対して 1 つの witness スタックがあります。

特定の入力に対する witness 構造は、それらが含む要素の数を示すカウントから始まります。これらの要素は _witness items_ と呼ばれます。詳細については <<c_authorization_authentication>> で探りますが、今のところ各 witness item はそのサイズを示す compactSize 整数でプレフィックスされていることを知っておく必要があります。

レガシー入力には witness items が含まれていないため、それらの witness スタックはゼロ (0x00) のカウントのみで構成されます。

Alice のトランザクションには 1 つの入力と 1 つの witness item が含まれています。

[[lock_time]]
=== Lock Time

シリアライズされたトランザクションの最後のフィールドはその lock time です。このフィールドは Bitcoin の元々のシリアライズ形式の一部でしたが、最初はどのトランザクションをマイニングするかを選ぶ Bitcoin のポリシーによってのみ強制されていました。Bitcoin の最も初期のソフトフォークは、ブロック高さ 31,000 から、次のいずれかのルールを満たさない限り、トランザクションをブロックに含めることを禁止するルールを追加しました。

- トランザクションは lock time を 0 に設定することで、任意のブロックに含まれる資格があることを示します。

- トランザクションは lock time を 500,000,000 未満の値に設定することで、どのブロックに含まれるかを制限したいことを示します。この場合、トランザクションは lock time と同じかそれ以上の高さを持つブロックにのみ含めることができます。例えば、lock time が 123,456 のトランザクションは、ブロック 123,456 またはそれ以降のブロックに含めることができます。

- トランザクションは、ロックタイムを 500,000,000 以上に設定することで、ブロックチェーンに含まれるタイミングを制限したいことを示します。この場合、フィールドはエポック時間（1970-01-01T00:00 UTC からの秒数）として解析され、トランザクションはロックタイムよりも大きい _median time past_ (MTP) を持つブロックにのみ含めることができます。MTP は通常、現在の時間よりも 1 時間から 2 時間遅れています。MTP のルールは <<mtp>> で説明されています。

[[coinbase_transactions]]
=== Coinbase トランザクション

各ブロックの最初のトランザクションは特別なケースです。多くの古い文書ではこれを _generation transaction_ と呼んでいますが、多くの新しい文書では _coinbase transaction_ と呼んでいます（「Coinbase」という名前の会社が作成したトランザクションと混同しないでください）。

Coinbase トランザクションは、それを含むブロックのマイナーによって作成され、マイナーにそのブロック内のトランザクションによって支払われた手数料を請求するオプションを与えます。さらに、ブロック 6,720,000 までは、マイナーはこれまでに流通したことのないビットコインからなる補助金、つまり _block subsidy_ を請求することが許可されています。マイナーがブロックに対して請求できる総額（手数料と補助金の組み合わせ）は _block reward_ と呼ばれます。

Coinbase トランザクションに関する特別なルールの一部は次のとおりです：

- 入力は 1 つしか持てません。

- 単一の入力は、null txid（すべてゼロで構成される）と最大の出力インデックス (0xffffffff) を持つアウトポイントを持たなければなりません。これにより、coinbase トランザクションが以前のトランザクション出力を参照することを防ぎます。これは少なくとも、coinbase トランザクションが手数料と補助金を支払うことを考えると混乱を招くでしょう。

- 通常のトランザクションで入力スクリプトが含まれるフィールドは _coinbase_ と呼ばれます。このフィールドが coinbase トランザクションの名前の由来です。coinbase フィールドは少なくとも 2 バイトで、100 バイトを超えてはなりません。このスクリプトは実行されませんが、シグネチャチェック操作（sigops）の数に関するレガシーのトランザクション制限が適用されるため、任意のデータを配置する場合はデータプッシュオペコードでプレフィックスする必要があります。2013 年に BIP34 で定義されたソフトフォーク以降、このフィールドの最初の数バイトは <<duplicate_transactions>> で説明する追加のルールに従う必要があります。

- 出力の合計は、そのブロック内のすべてのトランザクションから集められた手数料の値と補助金の合計を超えてはなりません。補助金はブロックごとに 50 BTC から始まり、210,000 ブロックごとに半減します（約 4 年ごと）。補助金の値は最も近いサトシに切り捨てられます。

- BIP141 に記載された 2017 年の segwit ソフトフォーク以降、segwit 出力を消費するトランザクションを含むブロックは、そのブロック内のすべてのトランザクション（その証人を含む）にコミットするコインベーストランザクションへの出力を含めなければなりません。このコミットメントについては <<mining>> で探ります。

コインベーストランザクションは、通常のトランザクションで有効な他の出力を持つことができます。しかし、それらの出力のいずれかを消費するトランザクションは、コインベーストランザクションが 100 回の確認を受けた後でなければ、どのブロックにも含めることができません。これを _成熟ルール_ と呼び、100 回の確認をまだ受けていないコインベーストランザクションの出力は _未成熟_ と呼ばれます。

//TODO: 成熟ルールの理由と、それに伴う期限切れタイムロックがない理由を説明するストレッチゴール

ほとんどの Bitcoin ソフトウェアはコインベーストランザクションを扱う必要はありませんが、その特別な性質のため、設計上それを予期していないソフトウェアでは時折、珍しい問題の原因となることがあります。

// 有用な内容が削除されました
// - トランザクションにおける入力額なし
// - トランザクションにおける残高なし
//   - UTXO モデル理論？
 // コイン選択
// お釣り
// 軽量クライアントが古い UTXO を取得できないこと

=== 重量と Vbytes

各 Bitcoin ブロックは含めることができるトランザクションデータの量に制限があるため、ほとんどの Bitcoin ソフトウェアは作成または処理するトランザクションを測定できる必要があります。Bitcoin の現代の測定単位は _重量_ と呼ばれます。重量の代替バージョンは _vbytes_ で、4 単位の重量が 1 vbyte に相当し、レガシー Bitcoin ブロックで使用されていた元の _バイト_ 測定単位との簡単な比較を提供します。

ブロックは 4,000,000 ウェイトに制限されています。ブロックヘッダは 240 ウェイトを占めます。追加のフィールドであるトランザクション数は、4 または 12 ウェイトを使用します。残りのウェイトはすべてトランザクションデータに使用できます。

トランザクション内の特定のフィールドのウェイトを計算するには、そのシリアライズされたフィールドのサイズ（バイト単位）に係数を掛けます。トランザクションのウェイトを計算するには、すべてのフィールドのウェイトを合計します。トランザクション内の各フィールドの係数は <<weight_factors>> に示されています。例として、この章のアリスからボブへのトランザクションの各フィールドのウェイトも計算します。

これらの係数と適用されるフィールドは、UTXO を使用する際のウェイトを削減するために選ばれました。これは、<<uneconomical_outputs>> で説明されているように、非経済的なアウトプットの作成を抑制するのに役立ちます。

++++
<table id="weight_factors">
<caption>ビットコイントランザクション内のすべてのフィールドのウェイト係数</caption>
<thead>
<tr>
<th><p>フィールド</p></th>
<th><p>係数</p></th>
<th><p>アリスのトランザクションでのウェイト</p></th>
</tr> </thead>
<tbody>
<tr>
<td><p>バージョン</p></td>
<td><p>4</p></td>
<td><p>16</p></td>
</tr>
<tr>
<td><p>マーカー &amp; フラグ</p></td>
<td><p>1</p></td>
<td><p>2</p></td>
</tr>
<tr>
<td><p>入力数</p></td>
<td><p>4</p></td>
<td><p>4</p></td>
</tr>
<tr>
<td><p>アウトポイント</p></td>
<td><p>4</p></td>
<td><p>144</p></td>
</tr>
<tr>
<td><p>入力スクリプト</p></td>
<td><p>4</p></td>
<td><p>4</p></td>
</tr>
<tr>
<td><p>シーケンス</p></td>
<td><p>4</p></td>
<td><p>16</p></td>
</tr>
<tr>
<td><p>出力数</p></td>
<td><p>4</p></td>
<td><p>4</p></td>
</tr>
<tr>
<td><p>金額</p></td>
<td><p>4</p></td>
<td><p>64 (2 outputs)</p></td>
</tr>
<tr>
<td><p>出力スクリプト</p></td>
<td><p>4</p></td>
<td><p>232 (2 outputs with different scripts)</p></td>
</tr>
<tr>
<td><p>証拠数</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
</tr>
<tr>
<td><p>証拠アイテム</p></td>
<td><p>1</p></td>
<td><p>66</p></td>
</tr>
<tr>
<td><p>ロックタイム</p></td>
<td><p>4</p></td>
<td><p>16</p></td>
</tr>
<tr>
<td><p><strong>合計</strong></p></td>
<td><p><em>N/A</em></p></td>
<td><p><strong>569</strong></p></td>
</tr>
</tbody>
</table>
++++

[role="less_space pagebreak-before"]
Alice のトランザクションの合計を Bitcoin Core から取得することで、重み計算を検証できます。

----
$ bitcoin-cli getrawtransaction 466200308696215bbc949d5141a49a41\
38ecdfdfaa2a8029c1f9bcecd1f96177 2 | jq .weight
569
----

この章の冒頭にある <<alice_tx_serialized_reprint>> からの Alice のトランザクションは、<<alice_tx_weight_map>> に示されているように重み単位で表されています。2 つの画像における各フィールドのサイズの違いを比較することで、重みの要素がどのように機能しているかがわかります。

[[alice_tx_weight_map]]
.Alice のトランザクションのバイトマップ。
image::images/mbc3_0606.png["Alice のトランザクションの重みマップ"]

[[legacy_serialization]]
=== レガシーシリアライゼーション

この章で説明するシリアライゼーション形式は、この本の執筆時点で新しい Bitcoin トランザクションの大部分に使用されていますが、古いシリアライゼーション形式も多くのトランザクションで使用されています。この古い形式は _レガシーシリアライゼーション_ と呼ばれ、空のウィットネス構造を持つトランザクション（ウィットネスプログラムを消費しない場合にのみ有効）には Bitcoin P2P ネットワークで使用する必要があります。

レガシーシリアライゼーションには、マーカー、フラグ、およびウィットネス構造フィールドが含まれていません。

++++
<p class="fix_tracking2">
この章では、トランザクション内の各フィールドを見て、ユーザ間で転送されるビットコインの詳細をフルノードに伝える方法を発見しました。出力スクリプト、入力スクリプト、およびウィットネス構造については簡単に触れただけですが、これらは誰がどのビットコインを消費できるかを制限する条件を指定し、満たすことを可能にします。これらの条件を構築し使用する方法を理解することは、Alice だけが彼女のビットコインを消費できるようにするために不可欠ですので、次の章でこれを取り上げます。</p>
++++

//TODO:text long section or full chapter about psbts

It seems like you haven't provided the Markdown file yet. Please upload the file or paste the content here, and I'll assist you with the translation.
