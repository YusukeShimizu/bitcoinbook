[[c_authorization_authentication]]
== 認可と認証

ビットコインを受け取るとき、誰にそれを使う許可を与えるかを決める必要があります。これを _認可_ と呼びます。また、フルノードが許可された使用者を他のすべての人と区別する方法を決める必要があります。これを _認証_ と呼びます。あなたの認可指示と使用者の認証証明は、何千もの独立したフルノードによってチェックされ、すべてが同じ結論に達する必要があります。それにより、そのトランザクションが有効であると認められます。

ビットコインの元々の説明では、認可に公開鍵を使用しました。アリスはボブに支払う際、トランザクションの出力に彼の公開鍵を入れました。認証は、ボブからの署名という形で行われ、ボブからキャロルへの送金トランザクションにコミットされました。

最初にリリースされたビットコインの実際のバージョンは、認可と認証の両方に対してより柔軟なメカニズムを提供しました。それ以降の改善は、その柔軟性をさらに高めています。この章では、それらの機能を探り、それがどのように一般的に使用されているかを見ていきます。

[[tx_script]]
=== トランザクションスクリプトとスクリプト言語

ビットコインの元々のバージョンは、_スクリプト_ と呼ばれる新しいプログラミング言語を導入しました。これは、Forth に似たスタックベースの言語です。出力に置かれるスクリプトと、使用トランザクションで使用されるレガシー入力スクリプトの両方が、このスクリプト言語で書かれています。

スクリプトは非常にシンプルな言語です。処理が最小限で済み、現代のプログラミング言語ができる多くの高度なことを簡単には行えません。

レガシートランザクションが最も一般的に使用されていたタイプのトランザクションであったとき、ビットコインネットワークを通じて処理されるトランザクションの大部分は「ボブのビットコインアドレスへの支払い」という形式をとり、公開鍵ハッシュへの支払い (P2PKH) スクリプトを使用していました。しかし、ビットコイントランザクションは「ボブのビットコインアドレスへの支払い」スクリプトに限定されません。実際、スクリプトはさまざまな複雑な条件を表現するために書くことができます。これらのより複雑なスクリプトを理解するためには、まずトランザクションスクリプトとスクリプト言語の基本を理解する必要があります。

このセクションでは、Bitcoin トランザクションスクリプト言語の基本的な構成要素を示し、それがどのようにして支出条件を表現し、その条件を満たすことができるかを説明します。

[TIP]
====
Bitcoin トランザクションの検証は、静的なパターンに基づくものではなく、スクリプト言語の実行を通じて達成されます。この言語は、ほぼ無限の条件を表現することが可能です。
====

==== チューリング完全性の欠如

Bitcoin トランザクションスクリプト言語は多くの演算子を含んでいますが、重要な点で意図的に制限されています。それは、ループや複雑なフロー制御機能が条件付きフロー制御以外には存在しないことです。これにより、この言語は _チューリング完全_ ではなく、スクリプトの複雑さが制限され、実行時間が予測可能になります。スクリプトは汎用言語ではありません。これらの制限により、無限ループや他の形式の「ロジックボム」を作成して、Bitcoin ネットワークに対するサービス拒否攻撃を引き起こすようなトランザクションに埋め込むことができないようにしています。すべてのトランザクションは、Bitcoin ネットワーク上のすべてのフルノードによって検証されます。制限された言語は、トランザクション検証メカニズムが脆弱性として利用されるのを防ぎます。

==== ステートレス検証

Bitcoin トランザクションスクリプト言語はステートレスであり、スクリプトの実行前に状態がなく、実行後に状態が保存されることもありません。スクリプトを実行するために必要なすべての情報は、スクリプトとスクリプトを実行するトランザクション内に含まれています。スクリプトは、どのシステムでも予測可能な方法で実行されます。もしあなたのシステムがスクリプトを検証したなら、Bitcoin ネットワーク内の他のすべてのシステムもそのスクリプトを検証することが保証されます。つまり、有効なトランザクションは誰にとっても有効であり、誰もがそれを知っています。この結果の予測可能性は、Bitcoin システムの重要な利点です。

[[tx_lock_unlock]]
==== スクリプトの構築

Bitcoin のレガシーなトランザクション検証エンジンは、トランザクションを検証するためにスクリプトの二つの部分に依存しています。それは、出力スクリプトと入力スクリプトです。

出力スクリプトは、将来その出力を使用するために満たすべき条件を指定します。例えば、誰がその出力を使用する権限を持っているのか、そしてどのように認証されるのかを示します。

入力スクリプトは、出力スクリプトに置かれた条件を満たし、出力を使用可能にするスクリプトです。入力スクリプトはすべてのトランザクション入力の一部です。レガシートランザクションでは、ほとんどの場合、ユーザのウォレットがそのプライベートキーから生成したデジタル署名を含んでいますが、すべての入力スクリプトが署名を含む必要はありません。

すべての Bitcoin 検証ノードは、出力スクリプトと入力スクリプトを実行することでトランザクションを検証します。<<c_transactions>> で見たように、各入力には以前のトランザクション出力を参照するアウトポイントが含まれています。入力には入力スクリプトも含まれています。検証ソフトウェアは入力スクリプトをコピーし、入力が参照する UTXO を取得し、その UTXO から出力スクリプトをコピーします。次に、入力スクリプトと出力スクリプトが一緒に実行されます。入力スクリプトが出力スクリプトの条件を満たす場合、入力は有効です（<<script_exec>> を参照）。すべての入力は、トランザクション全体の検証の一部として独立して検証されます。

前述の手順では、すべてのデータのコピーを作成することに注意してください。以前の出力と現在の入力の元のデータは決して変更されません。特に、以前の出力は不変であり、それを使用しようとする失敗した試みの影響を受けません。出力スクリプトの条件を正しく満たす有効なトランザクションのみが、その出力が「使用済み」と見なされる結果をもたらします。

<<input_and_output_scripts_legacy>> は、最も一般的なタイプのレガシー Bitcoin トランザクション（公開鍵ハッシュへの支払い）の出力スクリプトと入力スクリプトの例であり、検証前にスクリプトを連結した結果の結合スクリプトを示しています。

[[input_and_output_scripts_legacy]]
.トランザクションスクリプトを評価するための入力スクリプトと出力スクリプトの組み合わせ
image::images/mbc3_0701.png["input_and_output_scripts"]

===== スクリプト実行スタック

Bitcoin のスクリプト言語はスタックベースの言語と呼ばれます。これは _スタック_ と呼ばれるデータ構造を使用するためです。スタックは非常にシンプルなデータ構造で、カードの束として視覚化できます。スタックには二つの基本操作があります：プッシュとポップです。プッシュはスタックの上にアイテムを追加します。ポップはスタックの上からアイテムを取り除きます。

スクリプト言語は、左から右に各アイテムを処理することでスクリプトを実行します。数値（データ定数）はスタックにプッシュされます。演算子はスタックから一つ以上のパラメータをプッシュまたはポップし、それらに作用し、結果をスタックにプッシュすることがあります。例えば、+OP_ADD+ はスタックから二つのアイテムをポップし、それらを加算し、結果の合計をスタックにプッシュします。

条件演算子は条件を評価し、+TRUE+ または +FALSE+ のブール結果を生成します。例えば、+OP_EQUAL+ はスタックから二つのアイテムをポップし、それらが等しい場合は +TRUE+（+TRUE+ は数値 1 で表されます）をプッシュし、等しくない場合は +FALSE+（0 で表されます）をプッシュします。Bitcoin トランザクションスクリプトは通常、トランザクションが有効であることを示す +TRUE+ の結果を生成するために条件演算子を含んでいます。

===== シンプルなスクリプト

では、スクリプトとスタックについて学んだことをいくつかの簡単な例に適用してみましょう。

<<simplemath_script>> で見るように、スクリプト +2 3 OP_ADD 5 OP_EQUAL+ は算術加算演算子 +OP_ADD+ を示し、二つの数を加算して結果をスタックに置き、その後に条件演算子 +OP_EQUAL+ が続き、結果の合計が +5+ と等しいかを確認します。この本の例では、簡潔さのために +OP_+ プレフィックスが省略されることがあります。利用可能なスクリプト演算子と関数の詳細については、https://oreil.ly/21vH9[Bitcoin Wiki のスクリプトページ]を参照してください。

ほとんどのレガシー出力スクリプトは公開鍵ハッシュ（基本的にはレガシー Bitcoin アドレス）を参照し、資金を使うための所有権の証明を要求しますが、スクリプトはそれほど複雑である必要はありません。出力スクリプトと入力スクリプトの任意の組み合わせで +TRUE+ 値が得られれば、それは有効です。スクリプト言語の例として使用した単純な算術も有効なスクリプトです。

算術例スクリプトの一部を出力スクリプトとして使用します：

```
3 OP_ADD 5 OP_EQUAL
```

これは、入力スクリプトを含むトランザクションによって満たされます：

```
2
```

検証ソフトウェアはスクリプトを組み合わせます：

```
2 3 OP_ADD 5 OP_EQUAL
```

<<simplemath_script>> で見たように、このスクリプトが実行されると、結果は +OP_TRUE+ となり、トランザクションは有効になります。このトランザクション出力スクリプトは有効ですが、結果として得られる UTXO は、スクリプトを満たす数値 2 を知っている算術のスキルを持つ誰でも使うことができます。

[[simplemath_script]]
.Bitcoin のスクリプト検証が単純な算術を行う。
image::images/mbc3_0702.png["TxScriptSimpleMathExample"]

[TIP]
====
トランザクションは、スタックのトップの結果が +TRUE+（任意の非ゼロ値）であれば有効です。トランザクションは、スタックのトップの値が +FALSE+（値がゼロまたは空のスタック）である場合、演算子（+VERIFY+、+OP_RETURN+ など）によってスクリプトの実行が明示的に停止された場合、またはスクリプトが意味的に有効でなかった場合（+OP_IF+ ステートメントが +OP_ENDIF+ オペコードで終了されていないなど）には無効です。詳細は https://oreil.ly/J2DXt[Bitcoin Wiki のスクリプトページ] を参照してください。
====

次に示すのは、2 + 7 – 3 + 1 を計算する、やや複雑なスクリプトです。スクリプトに複数の演算子が連続して含まれている場合、スタックは一つの演算子の結果を次の演算子が作用することを可能にします：

```
2 7 OP_ADD 3 OP_SUB 1 OP_ADD 7 OP_EQUAL
```

前述のスクリプトを自分で鉛筆と紙を使って検証してみてください。スクリプトの実行が終了すると、スタックには +TRUE+ 値が残るはずです。


[[script_exec]]
===== 出力スクリプトと入力スクリプトの分離実行

元の Bitcoin クライアントでは、出力スクリプトと入力スクリプトが連結され、順番に実行されていました。セキュリティ上の理由から、+1 OP_RETURN+ バグとして知られる脆弱性のため、2010年にこれが変更されました。現在の実装では、スクリプトは別々に実行され、スタックが両方の実行間で転送されます。

まず、入力スクリプトがスタック実行エンジンを使用して実行されます。入力スクリプトがエラーなく実行され、操作が残っていない場合、スタックがコピーされ、出力スクリプトが実行されます。入力スクリプトからコピーされたスタックデータで出力スクリプトを実行した結果が +TRUE+ であれば、入力スクリプトは出力スクリプトによって課された条件を解決することに成功したことになり、したがって、入力は UTXO を消費するための有効な認証です。結合されたスクリプトの実行後に +TRUE+ 以外の結果が残っている場合、入力は出力に課された消費条件を満たしていないため無効です。

//SOMEDAY:入力スクリプトでスクリプトを使用できないことの影響

[[p2pkh]]
==== 公開鍵ハッシュへの支払い (P2PKH)

公開鍵ハッシュへの支払い (P2PKH) スクリプトは、公開鍵にコミットするハッシュを含む出力スクリプトを使用します。P2PKH は、レガシー Bitcoin アドレスの基礎として最もよく知られています。P2PKH 出力は、ハッシュコミットメントに一致する公開鍵と、対応する秘密鍵によって作成されたデジタル署名を提示することで消費できます (<<c_signatures>> を参照)。P2PKH 出力スクリプトの例を見てみましょう。

----
OP_DUP OP_HASH160 <Key Hash> OP_EQUALVERIFY OP_CHECKSIG
----

[role="less_space pagebreak-before"]
+Key Hash+ は、レガシー base58check アドレスにエンコードされるデータです。ほとんどのアプリケーションは、スクリプト内で _公開鍵ハッシュ_ を 16 進エンコーディングを使用して表示し、通常の Bitcoin アドレス base58check 形式 ( [.keep-together]#a "1."# で始まる) では表示しません。

前述の出力スクリプトは、次の形式の入力スクリプトで満たすことができます：

----
<Signature> <Public Key>
----

この 2 つのスクリプトを組み合わせると、次のような結合された検証スクリプトが形成されます：

----
<Sig> <Pubkey> OP_DUP OP_HASH160 <Hash> OP_EQUALVERIFY OP_CHECKSIG
----

入力スクリプトが、担保として設定された公開鍵ハッシュに対応するボブの秘密鍵からの有効な署名を持っている場合、結果は +TRUE+ になります。

図 pass:[<a data-type="xref" href="#P2PubKHash1" data-xrefstyle="select: labelnumber">#P2PubKHash1</a>] および pass:[<a data-type="xref" href="#P2PubKHash2" data-xrefstyle="select: labelnumber">#P2PubKHash2</a>] は、結合スクリプトのステップバイステップの実行を 2 部に分けて示しており、これが有効なトランザクションであることを証明します。

[[P2PubKHash1]]
.P2PKH トランザクションのスクリプト評価 (1/2)
image::images/mbc3_0703.png["Tx_Script_P2PubKeyHash_1"]

[[P2PubKHash2]]
.P2PKH トランザクションのスクリプト評価 (2/2)
image::images/mbc3_0704.png["Tx_Script_P2PubKeyHash_2"]

[[multisig]]
=== スクリプト化されたマルチシグネチャ

マルチシグネチャスクリプト((("scripted multisignatures", id="script-multisignature")))((("multisignature scripts", id="multi-script")))は、_k_ 個の公開鍵がスクリプトに記録され、そのうち少なくとも _t_ 個が資金を使うための署名を提供しなければならないという条件を設定します。これは _t_-of-_k_ と呼ばれます。例えば、2-of-3 マルチシグネチャは、3 つの公開鍵が潜在的な署名者としてリストされ、そのうち少なくとも 2 つが資金を使うための有効なトランザクションを作成するために使用されなければならないものです。

[TIP]
====
一部のビットコインのドキュメント、特にこの本の初版では、従来のマルチシグネチャに対して "m-of-n" という用語が使われています。しかし、口頭で "m" と "n" を区別するのは難しいため、代わりに _t_-of-_k_ を使用します。どちらのフレーズも同じタイプの署名スキームを指します。
====

_t_-of-_k_ マルチシグネチャ条件を設定する出力スクリプトの一般的な形式は次のとおりです：

----
t <Public Key 1> <Public Key 2> ... <Public Key k> k OP_CHECKMULTISIG
----

ここで、_k_ はリストされた公開鍵の総数であり、_t_ は出力を使うために必要な署名の閾値です。

2-of-3マルチシグネチャ条件を設定する出力スクリプトは次のようになります：

----
2 <Public Key A> <Public Key B> <Public Key C> 3 OP_CHECKMULTISIG
----

前述の出力スクリプトは、次のような入力スクリプトで満たすことができます [.keep-together]#署名：#

----
<Signature B> <Signature C>
----

または、3つの公開鍵に対応する秘密鍵から任意の2つの署名の組み合わせでも可能です。

これら2つのスクリプトを組み合わせると、次のような検証スクリプトが形成されます：

----
<Sig B> <Sig C> 2 <Pubkey A> <Pubkey B> <Pubkey C> 3 OP_CHECKMULTISIG
----

実行されると、この組み合わせたスクリプトは、入力スクリプトが3つの公開鍵のうち2つに対応する秘密鍵からの有効な署名を持っている場合に+TRUE+と評価されます。

現在、Bitcoin Coreのトランザクションリレーポリシーは、マルチシグネチャ出力スクリプトを最大で3つの公開鍵に制限しています。つまり、1-of-1から3-of-3のマルチシグネチャ、またはその範囲内の任意の組み合わせが可能です。ネットワークで現在受け入れられているものを確認するには、+IsStandard()+関数をチェックすることをお勧めします。3つの鍵の制限は、標準（「ベア」とも呼ばれる）マルチシグネチャスクリプトにのみ適用され、P2SH、P2WSH、P2TRのような他の構造にラップされたスクリプトには適用されません。P2SHマルチシグネチャスクリプトは、ポリシーとコンセンサスの両方で15鍵に制限されており、最大で15-of-15のマルチシグネチャが可能です。P2SHについては<<p2sh>>で学びます。他のすべてのスクリプトは、+OP_CHECKMULTISIG+または+OP_CHECKMULTISIGVERIFY+オペコードごとに20鍵にコンセンサスで制限されていますが、1つのスクリプトにこれらのオペコードを複数含めることができます。

[role="less_space pagebreak-before"]
[[multisig_bug]]
==== CHECKMULTISIG実行の奇妙な点

++OP_CHECKMULTISIG++の実行には、少しの回避策が必要な奇妙な点があります。+OP_CHECKMULTISIG+が実行されると、スタック上の_t_ + _k_ + 2個のアイテムをパラメータとして消費するはずです。しかし、この奇妙な点のために、+OP_CHECKMULTISIG+は予想よりも1つ多くの値をポップします。

前回の検証例を使って、これを詳しく見ていきましょう。

----
<Sig B> <Sig C> 2 <Pubkey A> <Pubkey B> <Pubkey C> 3 OP_CHECKMULTISIG
----

まず、+OP_CHECKMULTISIG+ はトップの項目をポップします。これは _k_ です（この例では「3」）。次に _k_ 項目をポップします。これらは署名できる公開鍵で、この例では公開鍵 A、B、C です。その後、1 項目をポップします。これは _t_ で、クォーラム（必要な署名の数）です。ここでは _t_ = 2 です。この時点で、+OP_CHECKMULTISIG+ は最終的に _t_ 項目をポップし、それらが有効かどうかを確認する必要があります。しかし、残念ながら、実装の奇妙さにより、+OP_CHECKMULTISIG+ は本来よりも 1 項目多くポップしてしまいます（合計 _t_ + 1 項目）。この余分な項目は「ダミースタック要素」と呼ばれ、署名の確認時には無視されるため、+OP_CHECKMULTISIG+ 自体には直接影響しません。しかし、ダミー要素は存在しなければならず、もし +OP_CHECKMULTISIG+ が空のスタックでポップしようとしたときに存在しないと、スタックエラーとスクリプトの失敗を引き起こし、トランザクションが無効とされます。ダミー要素は無視されるため、何でも構いません。初期の頃から +OP_0+ を使うのが慣例となり、後にリレーポリシールールとなり、最終的には BIP147 の施行によりコンセンサスルールとなりました。

ダミー要素をポップすることがコンセンサスルールの一部であるため、これを永遠に再現し続ける必要があります。したがって、スクリプトは次のようにする必要があります。

----
OP_0 <Sig B> <Sig C> 2 <Pubkey A> <Pubkey B> <Pubkey C> 3 OP_CHECKMULTISIG
----

したがって、マルチシグで実際に使用される入力スクリプトは次のようになります。

----
<Signature B> <Signature C>
----

ではなく、次のようになります。

----
OP_0 <Sig B> <Sig C>
----

この奇妙さはビットコインの元のコードのバグであると考える人もいますが、もっともらしい別の説明も存在します。_t_ -of-_k_ 署名を検証するには、_t_ または _k_ 以上の署名確認操作が必要になることがあります。1-in-5 の簡単な例を考えてみましょう。次のような結合スクリプトがあります。

----
<dummy> <Sig4> 1 <key0> <key1> <key2> <key3> <key4> 5 OP_CHECKMULTISIG
----

署名はまず +key0+ に対してチェックされ、その後 +key1+、そして他のキーに対してチェックされ、最終的に対応する +key4+ と比較されます。つまり、署名は一つしかないにもかかわらず、5 回の署名チェック操作が必要です。この冗長性を排除する一つの方法として、+OP_CHECKMULTISIG+ に提供された署名がどの公開鍵に対応するかを示すマップを提供し、+OP_CHECKMULTISIG+ 操作が正確に _t_ 回の署名チェック操作のみを行うようにすることが考えられました。ビットコインのオリジナル開発者が、後のソフトフォークでマップを渡す機能を追加できるように、元のビットコインのバージョンに追加要素（現在ではダミースタック要素と呼ばれています）を追加した可能性があります。しかし、その機能は実装されず、2017 年の BIP147 のコンセンサスルールの更新により、将来的にその機能を追加することは不可能になりました。

ダミースタック要素がバグの結果なのか、将来のアップグレードの計画だったのかは、ビットコインのオリジナル開発者のみが知ることです。この本では、それを単に奇妙なものと呼びます。

今後、マルチシグスクリプトを見た場合、コンセンサスルールの奇妙さを回避するためだけに、最初に追加の +OP_0+ があることを期待してください。

[[p2sh]]
=== Pay to Script Hash

Pay to script hash (P2SH) は、複雑なスクリプトの使用を大幅に簡素化する強力な新しいタイプの操作として 2012 年に導入されました。P2SH の必要性を説明するために、実際の例を見てみましょう。

Mohammed はドバイを拠点とする電子機器の輸入業者です。Mohammed の会社は、企業アカウントにビットコインのマルチシグネチャ機能を広範に使用しています。マルチシグネチャスクリプトは、ビットコインの高度なスクリプト機能の最も一般的な使用例の一つであり、非常に強力な機能です。Mohammed の会社は、すべての顧客支払いにマルチシグネチャスクリプトを使用しています。顧客によって行われた支払いは、少なくとも 2 つの署名が必要な方法でロックされています。Mohammed、彼の 3 人のパートナー、および彼らの弁護士は、それぞれ 1 つの署名を提供できます。このようなマルチシグネチャスキームは、企業のガバナンスコントロールを提供し、盗難、横領、または損失から保護します。

生成されたスクリプトは非常に長く、次のようになります：

----
2 <Mohammed's Public Key> <Partner1 Public Key> <Partner2 Public Key> 
<Partner3 Public Key> <Attorney Public Key> 5 OP_CHECKMULTISIG
----

マルチシグネチャスクリプトは強力な機能ですが、使用するのが面倒です。前述のスクリプトを考えると、Mohammed は支払いの前にこのスクリプトをすべての顧客に伝える必要があります。各顧客は、カスタムトランザクションスクリプトを作成できる特別な Bitcoin ウォレットソフトウェアを使用しなければなりません。さらに、このスクリプトには非常に長い公開鍵が含まれているため、生成されるトランザクションは単純な支払いトランザクションの約 5 倍の大きさになります。その余分なデータの負担は、追加のトランザクション手数料という形で顧客が負うことになります。最後に、このような大きなトランザクションスクリプトは、消費されるまでの間、すべてのフルノードの UTXO セットに保持されます。これらの問題すべてが、複雑な出力スクリプトの実際の使用を困難にしています。

P2SH はこれらの実際的な困難を解決し、複雑なスクリプトの使用を単一キーの Bitcoin アドレスへの支払いと同じくらい簡単にするために開発されました。P2SH 支払いでは、複雑なスクリプトは暗号ハッシュのダイジェストであるコミットメントに置き換えられます。後で UTXO を消費しようとするトランザクションが提示されるとき、それはスクリプトを満たすデータに加えて、コミットメントに一致するスクリプトを含まなければなりません。簡単に言えば、P2SH は「このハッシュに一致するスクリプトに支払いを行い、この出力が消費されるときにそのスクリプトが提示される」という意味です。

P2SH トランザクションでは、ハッシュに置き換えられるスクリプトは _redeem script_（リディームスクリプト）と呼ばれます。これは、出力スクリプトとしてではなく、償還時にシステムに提示されるためです。<<without_p2sh>> は P2SH を使用しないスクリプトを示し、<<with_p2sh>> は P2SH でエンコードされた同じスクリプトを示しています。

++++
<table id="without_p2sh">
<caption>P2SH を使用しない複雑なスクリプト</caption>
<tbody>
<tr>
<td><p>出力スクリプト</p></td>
<td><p>2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 OP_CHECKMULTISIG</p></td>
</tr>
<tr>
<td><p>入力スクリプト</p></td>
<td><p>Sig1 Sig2</p></td>
</tr>
</tbody>
</table>
<table id="with_p2sh">
<caption>P2SH としての複雑なスクリプト</caption>
<tbody>
<tr>
<td><p>リディームスクリプト</p></td>
<td><p>2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 OP_CHECKMULTISIG</p></td>
</tr>
<tr>
<td><p>出力スクリプト</p></td>
<td><p>OP_HASH160 &lt;20-byte hash of redeem script&gt; OP_EQUAL</p></td>
</tr>
<tr>
<td><p>入力スクリプト</p></td>
<td><p>Sig1 Sig2 &lt;redeem script&gt;</p></td>
</tr>
</tbody>
</table>
++++

テーブルからわかるように、P2SH では、出力を消費する条件を詳細に記述した複雑なスクリプト（リディームスクリプト）は出力スクリプトに提示されません。その代わりに、そのハッシュだけが出力スクリプトに含まれ、リディームスクリプト自体は出力が消費される際に入力スクリプトの一部として提示されます。これにより、手数料と複雑さの負担が送金者から受取人に移ります。

モハメッドの会社、複雑なマルチシグネチャスクリプト、および結果として得られる P2SH スクリプトを見てみましょう。

まず、モハメッドの会社が顧客からのすべての入金に使用するマルチシグネチャスクリプトです：

----
2 <Mohammed's Public Key> <Partner1 Public Key> <Partner2 Public Key> 
<Partner3 Public Key> <Attorney Public Key> 5 OP_CHECKMULTISIG
----

この全体のスクリプトは、SHA256 ハッシュアルゴリズムを適用し、その結果に RIPEMD-160 アルゴリズムを適用することで、20 バイトの暗号ハッシュで表現できます。例えば、モハメッドのリディームスクリプトのハッシュから始めます：

----
54c557e07dde5bb6cb791c7a540e0a4796f5e97e
----

P2SH トランザクションは、このハッシュに出力をロックし、より長いリディームスクリプトの代わりに特別な出力スクリプトテンプレートを使用します：

----
OP_HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e OP_EQUAL
----

ご覧のとおり、これははるかに短いです。「この 5 キーのマルチシグネチャスクリプトに支払う」のではなく、P2SH の同等のトランザクションは「このハッシュを持つスクリプトに支払う」となります。モハメッドの会社に支払いを行う顧客は、このはるかに短い出力スクリプトを支払いに含めるだけで済みます。モハメッドとそのパートナーがこの UTXO を消費したい場合、元のリディームスクリプト（UTXO をロックしたハッシュのもの）とそれを解除するために必要な署名を提示しなければなりません。例えば：

----
<Sig1> <Sig2> <2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG>
----

2 つのスクリプトは 2 段階で組み合わされます。まず、リディームスクリプトが出力スクリプトと一致するかどうかを確認します：

----
<2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG> OP_HASH160 <script hash> OP_EQUAL
----

リディームスクリプトのハッシュが一致すれば、リディームスクリプトが実行されます：

----
<Sig1> <Sig2> 2 <PK1> <PK2> <PK3> <PK4> <PK5> 5 OP_CHECKMULTISIG
----

==== P2SH アドレス

P2SH 機能のもう一つの重要な部分は、BIP13 で定義されているように、スクリプトハッシュをアドレスとしてエンコードする能力です。P2SH アドレスは、スクリプトの 20 バイトハッシュの base58check エンコーディングであり、ビットコインアドレスが公開鍵の 20 バイトハッシュの base58check エンコーディングであるのと同様です。P2SH アドレスはバージョンプレフィックス「5」を使用し、その結果、base58check エンコードされたアドレスは「3」で始まります。

例えば、モハメッドの複雑なスクリプトをハッシュ化し、base58check エンコードされた P2SH アドレスとして表現すると、+39RF6JqABiHdYHkfChV6USGMe6Nsr66Gzw+ になります。

これで、モハメッドはこの「アドレス」を顧客に渡すことができ、顧客はほとんどのビットコインウォレットを使って、他のビットコインアドレスと同様に簡単に支払いを行うことができます。「3」プレフィックスは、これが公開鍵ではなくスクリプトに対応する特別なタイプのアドレスであることを示唆しますが、それ以外は他のビットコインアドレスへの支払いと全く同じように機能します。

P2SH アドレスはすべての複雑さを隠すため、支払いを行う人はスクリプトを見ることはありません。

==== P2SH の利点

P2SH 機能は、出力で複雑なスクリプトを直接使用するのに比べて、次のような利点を提供します：

- 元のレガシーアドレスとの類似性により、送信者と送信者のウォレットは P2SH を実装するために複雑なエンジニアリングを必要としません。

- P2SH は、長いスクリプトのデータストレージの負担を出力（ブロックチェーンに保存されるだけでなく、UTXO セットにも含まれる）から入力（ブロックチェーンにのみ保存される）に移します。

- P2SH は、長いスクリプトのデータストレージの負担を現在（支払い）から将来（それが使用されるとき）に移します。

- P2SH は、長いスクリプトのトランザクション手数料の負担を送信者から受信者に移し、受信者はそれを使用するために長いリディームスクリプトを含める必要があります。

==== リディームスクリプトと検証

P2SH リディームスクリプト内に P2SH を入れることはできません。なぜなら、P2SH の仕様は再帰的ではないからです。また、技術的にはリディームスクリプトに +OP_RETURN+（<<op_return>> を参照）を含めることは可能ですが、ルール上それを防ぐものは何もないものの、検証中に +OP_RETURN+ を実行するとトランザクションが無効とされるため、実際には役に立ちません。

ネットワークに対してリディームスクリプトが提示されるのは P2SH 出力を使おうとしたときだけなので、無効なリディームスクリプトのハッシュを持つ出力を作成した場合、それを使うことはできません。リディームスクリプトを含む支出トランザクションは無効なスクリプトであるため受け入れられません。これにより、後で使えない P2SH アドレスにビットコインを送ってしまうリスクが生じます。

[WARNING]
====
P2SH 出力スクリプトにはリディームスクリプトのハッシュが含まれており、リディームスクリプトの内容についての手がかりはありません。リディームスクリプトが無効であっても、P2SH 出力は有効と見なされ受け入れられます。このため、後で使えない方法でビットコインを受け取ってしまうことがあります。
====

[[op_return]]
=== データ記録出力 (OP_RETURN)

ビットコインの分散型ブロックチェーンは、支払い以外の用途にも利用可能性があります。多くの開発者が、デジタル公証サービスなどのアプリケーションのために、システムのセキュリティと耐久性を活用しようとトランザクションスクリプト言語を使用してきました。ビットコインのスクリプト言語をこれらの目的で使用する初期の試みには、ブロックチェーン上にデータを記録するトランザクション出力を作成することが含まれていました。例えば、特定の日付にそのトランザクションを参照することで、誰でもそのファイルの存在証明を確立できるようにファイルへのコミットメントを記録することがありました。

[role="less_space pagebreak-before"]
ビットコインのブロックチェーンをビットコインの支払いに関係のないデータを保存するために使用することは、議論の的となっています。多くの人々はそのような使用を乱用と見なし、抑制したいと考えています。一方で、ブロックチェーン技術の強力な能力を示すものとして、そのような実験を奨励したいと考える人もいます。支払いに関係のないデータの含有に反対する人々は、ブロックチェーンが意図していないデータのディスクストレージのコストを負担することをフルビットコインノードを運営する人々に課していると主張します。さらに、そのようなトランザクションは、自由形式の 20 バイトフィールドとしてレガシービットコインアドレスを使用して、使えない UTXO を作成する可能性があります。アドレスがデータに使用されるため、それは秘密鍵に対応せず、結果として得られる UTXO は _決して_ 使えません。それは偽の支払いです。このように決して使えないトランザクションは、UTXO セットから決して削除されず、UTXO データベースのサイズが永遠に増加し続ける、つまり「膨張」する原因となります。

妥協案が成立し、+OP_RETURN+ で始まる出力スクリプトを使用して、トランザクション出力に非支払いデータを追加できるようになりました。しかし、「偽の」UTXO を使用する場合とは異なり、+OP_RETURN+ 演算子は明示的に _消費不可能であることが証明された_ 出力を作成します。これは UTXO セットに保存する必要がありません。+OP_RETURN+ 出力はブロックチェーンに記録されるため、ディスクスペースを消費し、ブロックチェーンのサイズ増加に寄与しますが、UTXO セットには保存されないため、フルノードが高価なデータベース操作のコストで膨らむことはありません。

+OP_RETURN+ スクリプトは次のようになります：

----
OP_RETURN <data>
----

データ部分は、SHA256 アルゴリズム（32 バイト）の出力のようなハッシュを表すことが多いです。一部のアプリケーションは、アプリケーションを識別しやすくするためにデータの前にプレフィックスを付けます。たとえば、https://proofofexistence.com[Proof of Existence] デジタル公証サービスは、8 バイトのプレフィックス +DOCPROOF+ を使用しており、これは 16 進数で +44 4f 43 50 52 4f 4f 46+ として ASCII エンコードされています。

+OP_RETURN+ に対応する入力スクリプトは存在せず、+OP_RETURN+ 出力を「消費」するために使用することはできないことに注意してください。+OP_RETURN+ 出力のポイントは、その出力にロックされた資金を消費できないことであり、したがって潜在的に消費可能なものとして UTXO セットに保持する必要がないということです。+OP_RETURN+ 出力は _消費不可能であることが証明された_ ものです。+OP_RETURN+ 出力は通常、金額がゼロです。なぜなら、そのような出力に割り当てられたビットコインは事実上永久に失われるからです。トランザクションで +OP_RETURN+ 出力を入力として参照すると、スクリプト検証エンジンは検証スクリプトの実行を停止し、そのトランザクションを無効としてマークします。+OP_RETURN+ の実行は本質的にスクリプトを +FALSE+ で「RETURN」させ、停止させます。したがって、誤ってトランザクションで +OP_RETURN+ 出力を入力として参照すると、そのトランザクションは無効になります。

[[lock_time_limitations]]
==== トランザクションのロックタイムの制限

ロックタイムを使用することで、支出者はトランザクションが特定のブロック高までブロックに含まれないように制限できますが、それより早く別のトランザクションで資金を使うことを防ぐことはできません。この点を次の例で説明します。

アリスは、自分の出力の一つをボブのアドレスに送るトランザクションに署名し、そのトランザクションのロックタイムを3か月後に設定します。アリスはそのトランザクションをボブに送って保持させます。このトランザクションにより、アリスとボブは以下のことを知っています。

* ボブは3か月が経過するまでトランザクションを送信して資金を引き出すことができません。
* ボブは3か月後にトランザクションを送信することができます。

しかしながら：

* アリスは、ロックタイムなしで同じ入力を使う競合するトランザクションを作成できます。したがって、アリスは3か月が経過する前に同じ UTXO を使うことができます。
* ボブには、アリスがそれをしないという保証はありません。

トランザクションのロックタイムの制限を理解することが重要です。唯一の保証は、ボブが3か月が経過する前に事前署名されたトランザクションを引き出せないということです。ボブが資金を受け取る保証はありません。ボブが資金を受け取ることを保証しつつ、3か月が経過するまでそれを使えないようにする方法の一つは、トランザクションではなくスクリプトの一部として UTXO 自体にタイムロック制限を設けることです。これは次の形式のタイムロック、Check Lock Time Verify によって実現されます。

==== Check Lock Time Verify (OP_CLTV)

2015年12月に、ビットコインに新しい形式のタイムロックがソフトフォークのアップグレードとして導入されました。BIP65 の仕様に基づき、+OP_CHECKLOCKTIMEVERIFY+ (+OP_CLTV+) という新しいスクリプトオペレータがスクリプト言語に追加されました。+OP_CLTV+ は、ロックタイムの場合のようにトランザクションごとのタイムロックではなく、出力ごとのタイムロックです。これにより、タイムロックの適用方法にさらなる柔軟性がもたらされます。

簡単に言うと、出力に +OP_CLTV+ オペコードをコミットすることで、その出力は指定された時間が経過するまで使用できないように制限されます。

+OP_CLTV+ はロックタイムを置き換えるのではなく、特定の UTXO を制限して、ロックタイムが同等またはそれ以上に設定された将来のトランザクションでのみ使用できるようにします。

+OP_CLTV+ オペコードは、ロックタイムと同じ形式（ブロック高または Unix エポック時間）で表現される数値を入力として受け取ります。+VERIFY+ サフィックスが示すように、+OP_CLTV+ はスクリプトの実行を +FALSE+ の結果で停止するタイプのオペコードです。+TRUE+ の結果が得られると、実行は続行されます。

+OP_CLTV+ を使用するには、出力を作成するトランザクションの出力のリディームスクリプトに挿入します。例えば、アリスがボブに支払う場合、彼は通常次の P2SH スクリプトで支払いを受け入れるかもしれません：

----
<Bob's public key> OP_CHECKSIG
----

これを、例えば今から 3 ヶ月後にロックするには、彼の P2SH スクリプトは次のようになります：

----
<Bob's pubkey> OP_CHECKSIGVERIFY <now + 3 months> OP_CHECKLOCKTIMEVERIFY
----

ここで +<now {plus} 3 months>+ は、トランザクションがマイニングされる時点から 3 ヶ月後のブロック高または時間値を推定したものです：現在のブロック高 {plus} 12,960（ブロック）または現在の Unix エポック時間 {plus} 7,760,000（秒）。

ボブがこの UTXO を使用しようとするとき、彼は UTXO を入力として参照するトランザクションを構築します。彼はその入力の入力スクリプトに自分の署名と公開鍵を使用し、トランザクションのロックタイムをアリスが設定した +OP_CHECKLOCKTIMEVERIFY+ のタイムロックと同等またはそれ以上に設定します。ボブはその後、トランザクションをビットコインネットワークにブロードキャストします。

ボブのトランザクションは次のように評価されます。アリスが設定した +OP_CHECKLOCKTIMEVERIFY+ パラメータが支出トランザクションのロックタイム以下である場合、スクリプトの実行は続行されます（_no operation_ または +OP_NOP+ オペコードが実行されたかのように動作します）。それ以外の場合、スクリプトの実行は停止し、トランザクションは無効と見なされます。

より正確には、BIP65 は次のいずれかが発生した場合に +OP_CHECKLOCKTIMEVERIFY+ が失敗し、実行が停止することを説明しています：


* スタックが空である。
* スタックの一番上の項目が 0 未満である。
* スタックの一番上の項目のロックタイムの種類（高さ対タイムスタンプ）とロックタイムフィールドが一致しない。
* スタックの一番上の項目がトランザクションのロックタイムフィールドより大きい。
* 入力のシーケンスフィールドが 0xffffffff である。

[role="less_space pagebreak-before"]
[[timelock_conflicts]]
.Timelock Conflicts
****
+OP_CLTV+ とロックタイムは、タイムロックを記述するために同じ形式を使用します。ブロックの高さまたは Unix エポックから経過した秒数のいずれかです。重要なのは、これらを一緒に使用する場合、ロックタイムの形式は出力の +OP_CLTV+ の形式と一致しなければならないということです。つまり、どちらもブロックの高さまたは秒単位の時間を参照しなければなりません。

これは、スクリプトが異なる形式の +OP_CLTV+ を 2 回呼び出す必要がある場合、そのスクリプトは決して有効にならないことを意味します。高度なスクリプトを書く際にこのミスを犯しやすいので、テストネットワークでスクリプトを徹底的にテストするか、Miniscript コンパイラのようなこの問題を防ぐためのツールを使用することをお勧めします。

さらに、トランザクションのスクリプトでは、1 種類の +OP_CLTV+ しか使用できないという意味もあります。ある入力のスクリプトが高さの種類を使用し、別の入力のスクリプトが時間の種類を使用する場合、両方の入力を消費する有効なトランザクションを構築する方法はありません。
****

実行後、+OP_CLTV+ が満たされると、それに先行するパラメータがスタックの一番上の項目として残り、後続のスクリプトオペコードを正しく実行するために +OP_DROP+ で削除する必要があるかもしれません。このため、スクリプトでは +OP_CHECKLOCKTIMEVERIFY+ の後に +OP_DROP+ が続くことがよくあります。+OP_CLTV+ は、+OP_CSV+（<<op_csv>> を参照）と同様に、スタック上に項目を残す点で他の +CHECKVERIFY+ オペコードとは異なります。これは、それらを追加したソフトフォークが、スタック項目を削除しない既存のオペコードを再定義したためであり、それらの以前のノーオペレーション（NOP）オペコードの動作を保持する必要があるからです。

ロックタイムと +OP_CLTV+ を組み合わせることで、<<lock_time_limitations>> で説明したシナリオが変わります。アリスはすぐにトランザクションを送信し、資金をボブの鍵に割り当てます。アリスはもうそのお金を使うことができませんが、ボブも 3 か月のロックタイムが終了するまでは使うことができません。

スクリプト言語にタイムロック機能を直接導入することで、+OP_CLTV+ は非常に興味深い複雑なスクリプトを開発することを可能にします。

標準の((("transactions", "timelocks", "verifying", startref="transaction-timelock-op-cltv")))((("timelocks", "verifying", startref="timelock-op-cltv")))((("lock time", "verifying", startref="lock-time-op-cltv")))((("OP_CLTV  script operator", startref="op-cltv")))((("verifying", "lock time", startref="verify-lock-time")))((("scripts", "timelocks", "verifying", startref="script-timelock-verify"))) は https://oreil.ly/YmJGD[BIP65 (OP_CHECKLOCKTIMEVERIFY)] で定義されています。

[[op_csv]]
==== 相対タイムロック

ロックタイム((("absolute timelocks")))((("transactions", "timelocks", "relative", id="transaction-timelock-relative")))((("timelocks", "relative", id="timelock-relative")))((("lock time", "relative", id="locktime-relative")))((("scripts", "timelocks", "relative", id="script-timelock-relative")))((("relative timelocks", id="relative-timelock2"))) と +OP_CLTV+ はどちらも _絶対タイムロック_ であり、特定の絶対的な時間を指定します。次に検討する 2 つのタイムロック機能は _相対タイムロック_ であり、ブロックチェーンでの出力の確認から経過した時間を条件として出力を消費することを指定します。

[role="less_space pagebreak-before"]
相対タイムロックは、以前のトランザクションの確認から経過した時間に依存するトランザクションに時間制約を課すことができるため、有用です。言い換えれば、UTXO がブロックチェーンに記録されるまで時計はカウントを開始しません。この機能は、<<state_channels>> で見るように、双方向のステートチャネルや Lightning Network (LN) で特に有用です。

相対タイムロックは、絶対タイムロックと同様に、トランザクションレベルの機能とスクリプトレベルのオペコードの両方で実装されています。トランザクションレベルの相対タイムロックは、すべてのトランザクション入力に設定されるトランザクションフィールドである +sequence+ の値に関するコンセンサスルールとして実装されています。スクリプトレベルの相対タイムロックは、+OP_CHECKSEQUENCEVERIFY+ (+OP_CSV+) オペコードで実装されています。

相対的なタイムロックは、https://oreil.ly/ZuANb[BIP68, 相対ロックタイムのコンセンサス強制シーケンス番号の使用] および https://oreil.ly/dLA2r[BIP112, OP_CHECKSEQUENCEVERIFY] の仕様に従って実装されています。

BIP68 と BIP112 は、2016年5月にコンセンサスルールへのソフトフォークアップグレードとして有効化されました。

==== OP_CSV を用いた相対的タイムロック

+OP_CLTV+ やロックタイムと同様に、スクリプト内でシーケンス値を活用する相対的タイムロックのためのスクリプトオペコードがあります。このオペコードは +OP_CHECKSEQUENCEVERIFY+ で、一般的に +OP_CSV+ と略されます。

UTXO のスクリプト内で評価されると、+OP_CSV+ オペコードは、入力シーケンス値が +OP_CSV+ パラメータ以上であるトランザクションでのみ支出を許可します。基本的に、これは UTXO がマイニングされた時点から一定のブロック数または秒数が経過するまで UTXO の支出を制限します。

CLTV と同様に、+OP_CSV+ の値は対応するシーケンス値の形式と一致している必要があります。+OP_CSV+ がブロック単位で指定されている場合、シーケンスもそうでなければなりません。+OP_CSV+ が秒単位で指定されている場合、シーケンスもそうでなければなりません。

[WARNING]
====
複数の +OP_CSV+ オペコードを実行するスクリプトは、時間ベースまたは高さベースのいずれかの同じ種類のみを使用しなければなりません。種類を混在させると、決して支出できない無効なスクリプトが生成されます。この問題は <<timelock_conflicts>> で見た +OP_CLTV+ と同じです。しかし、+OP_CSV+ は任意の2つの有効な入力を同じトランザクションに含めることができるため、+OP_CLTV+ で発生する入力間の相互作用の問題は +OP_CSV+ には影響しません。
====

[role="less_space pagebreak-before"]
+OP_CSV+ を用いた相対的タイムロックは、いくつかの（連鎖した）トランザクションが作成され署名されるが、伝播されない場合、つまりブロックチェーン外（_オフチェーン_）に保持される場合に特に有用です。子トランザクションは、親トランザクションが伝播され、マイニングされ、相対的タイムロックで指定された時間だけ経過するまで使用できません。このユースケースの一例は <<state_channels>> および <<lightning_network>> に示されています。

+OP_CSV+ は、https://oreil.ly/z_Obw[BIP112, CHECKSEQUENCEVERIFY] で詳細に定義されています。

=== フロー制御を持つスクリプト (条件句)

Bitcoin Script のより強力な機能の一つに、フロー制御、または条件句があります。さまざまなプログラミング言語で使われる +IF...THEN...ELSE+ 構造のフロー制御に慣れているかもしれません。Bitcoin の条件句は少し異なって見えますが、本質的には同じ構造です。

基本的なレベルでは、Bitcoin の条件オペコードを使用すると、論理条件の評価結果が +TRUE+ または +FALSE+ に応じて、2 通りの方法でロックを解除するスクリプトを構築できます。たとえば、x が +TRUE+ の場合、実行されるコードパスは A であり、+ELSE+ のコードパスは B です。

さらに、Bitcoin の条件式は無限に「ネスト」することができ、条件句の中に別の条件句を含めることができ、その中にさらに別の条件句を含めることができます。Bitcoin Script のフロー制御を使用すると、数百の実行パスを持つ非常に複雑なスクリプトを構築できます。ネストに制限はありませんが、コンセンサスルールにより、スクリプトの最大サイズ（バイト単位）に制限が課されています。

Bitcoin は +OP_IF+、+OP_ELSE+、+OP_ENDIF+、+OP_NOTIF+ オペコードを使用してフロー制御を実装しています。さらに、条件式には +OP_BOOLAND+、+OP_BOOLOR+、+OP_NOT+ などのブール演算子を含めることができます。

最初は、Bitcoin のフロー制御スクリプトが混乱を招くかもしれません。それは、Bitcoin Script がスタック言語であるためです。+1 {plus} 1+ が +1 1 OP_ADD+ と表現されると「逆」に見えるのと同じように、Bitcoin のフロー制御句も「逆」に見えます。

ほとんどの従来の（手続き型）プログラミング言語では、フロー制御は次のようになります。

.ほとんどのプログラミング言語におけるフロー制御の擬似コード
----
if (condition):
  code to run when condition is true
else:
  code to run when condition is false
endif
code to run in either case
----

Bitcoin Script のようなスタックベースの言語では、論理条件が +IF+ の前に来るため、「逆向き」に見えます。

[role="less_space pagebreak-before"]
.Bitcoin Script のフロー制御
----
condition
IF
  code to run when condition is true
OP_ELSE
  code to run when condition is false
OP_ENDIF
code to run in either case
----

Bitcoin Script を読むときは、評価される条件が +IF+ オペコードの _前_ に来ることを覚えておいてください。

==== VERIFY オペコードを使った条件付き節

Bitcoin Script におけるもう一つの条件付きの形式は、+VERIFY+ で終わるオペコードです。+VERIFY+ サフィックスは、条件が +TRUE+ でない場合、スクリプトの実行が即座に終了し、トランザクションが無効と見なされることを意味します。

+IF+ 節が代替の実行パスを提供するのとは異なり、+VERIFY+ サフィックスは _ガード節_ として機能し、前提条件が満たされた場合にのみ続行します。

例えば、次のスクリプトはボブの署名と特定のハッシュを生成するプレイメージ（秘密）が必要です。両方の条件が満たされるとロックが解除されます。

.+OP_EQUALVERIFY+ ガード節を持つスクリプト
----
OP_HASH160 <expected hash> OP_EQUALVERIFY <Bob's Pubkey> OP_CHECKSIG
----

これを使用するには、ボブは有効なプレイメージと署名を提示する必要があります。

.上記スクリプトを満たす
----
<Bob's Sig> <hash pre-image>
----

プレイメージを提示しないと、ボブは彼の署名を確認する部分に到達できません。

このスクリプトは +OP_IF+ を使って書くこともできます。

.+IF+ ガード節を持つスクリプト
----
OP_HASH160 <expected hash> OP_EQUAL
OP_IF
   <Bob's Pubkey> OP_CHECKSIG
OP_ENDIF
----

ボブの認証データは同じです。

.上記スクリプトを満たす
----
<Bob's Sig> <hash pre-image>
----

+OP_IF+ を使ったスクリプトは、+VERIFY+ サフィックスを持つオペコードを使用するのと同じことを行います。どちらもガード節として機能します。しかし、+VERIFY+ 構造の方が効率的で、2 つ少ないオペコードを使用します。

では、+VERIFY+ と +OP_IF+ はいつ使うのでしょうか。もし単に前提条件（ガード句）を付けたいだけなら、+VERIFY+ の方が適しています。しかし、複数の実行パス（フロー制御）を持ちたい場合は、+OP_IF...OP_ELSE+ フロー制御句が必要です。

==== スクリプトでのフロー制御の使用

Bitcoin Script でフロー制御を使用する非常に一般的な方法は、複数の実行パスを提供するスクリプトを構築することです。各パスは UTXO を引き出す異なる方法を示します。

簡単な例を見てみましょう。ここでは、2 人の署名者、アリスとボブがいて、どちらも引き出しが可能です。マルチシグを使うと、これは 1-of-2 マルチシグスクリプトとして表現されます。デモンストレーションのために、これを +OP_IF+ 句で同じことを行います。

----
OP_IF
 <Alice's Pubkey>
OP_ELSE
 <Bob's Pubkey>
OP_ENDIF
OP_CHECKSIG
----

このリディームスクリプトを見て、疑問に思うかもしれません。「条件はどこにあるのか？+IF+ 句の前に何もない！」

条件はスクリプトの一部ではありません。代わりに、条件は支払い時に提供され、アリスとボブがどの実行パスを選ぶかを「選択」できるようにします。

.アリスが上記のスクリプトを満たす場合：
----
<Alice's Sig> OP_TRUE
----

最後の +OP_TRUE+ は条件（+TRUE+）として機能し、+OP_IF+ 句が最初の引き出しパスを実行します。この条件は、アリスが署名を持つ公開鍵をスタックに置きます。+OP_TRUE+ オペコード、別名 +OP_1+ は、スタックに数値 1 を置きます。

ボブがこれを引き出すには、+FALSE+ 値を与えて +OP_IF+ の第 2 の実行パスを選ぶ必要があります。+OP_FALSE+ オペコード、別名 +OP_0+ は、空のバイト配列をスタックにプッシュします。

----
<Bob's Sig> OP_FALSE
----

ボブの入力スクリプトは、+OP_IF+ 句が第 2 の（+OP_ELSE+）スクリプトを実行し、ボブの署名を要求します。

+OP_IF+ 句はネストできるため、実行パスの「迷路」を作成できます。入力スクリプトは、実際に実行される実行パスを選択する「地図」を提供できます。

----
OP_IF
  subscript A
OP_ELSE
  OP_IF
    subscript B
  OP_ELSE
    subscript C
  OP_ENDIF
OP_ENDIF
----

このシナリオでは、3 つの実行パス（+subscript A+、+subscript B+、+subscript C+）があります。入力スクリプトは +TRUE+ または +FALSE+ の値のシーケンスとしてパスを提供します。たとえば、パス +subscript B+ を選択するには、入力スクリプトは +OP_1 OP_0+（+TRUE+、+FALSE+）で終わる必要があります。これらの値はスタックにプッシュされ、2 番目の値（+FALSE+）がスタックのトップに来ます。外側の +OP_IF+ 節は +FALSE+ 値をポップし、最初の +OP_ELSE+ 節を実行します。その後、+TRUE+ 値がスタックのトップに移動し、内側（ネストされた）+OP_IF+ によって評価され、+B+ 実行パスが選択されます。

この構造を使用することで、UTXO を引き出すための異なる方法を提供する、数十または数百の実行パスを持つリディームスクリプトを構築できます。支出するには、各フロー制御（((("scripts", "flow control", startref="script-flow")))((("flow control in scripts", startref="flow-control-script")))((("conditional clauses in scripts", startref="conditional-clause-script"))) ポイントで適切な +TRUE+ と +FALSE+ の値をスタックに置くことで、実行パスをナビゲートする入力スクリプトを構築します。

=== 複雑なスクリプトの例

この((("scripts", "examples of", id="script-example-complex")))セクションでは、この章の多くの概念を単一の例にまとめます。

ドバイの会社オーナーであるモハメッドは、輸出入ビジネスを運営しており、柔軟なルールを持つ会社の資本口座を構築したいと考えています。彼が作成するスキームは、タイムロックに応じて異なるレベルの承認を必要とします。マルチシグスキームの参加者は、モハメッド、彼の 2 人のパートナーであるサイードとザイラ、および彼らの会社の弁護士です。3 人のパートナーは多数決に基づいて決定を下すため、3 人のうち 2 人が同意する必要があります。しかし、彼らの鍵に問題がある場合、弁護士が 3 人のパートナーの署名のうち 1 つを使用して資金を回収できるようにしたいと考えています。最後に、すべてのパートナーがしばらくの間利用できないか無能力になった場合、弁護士が資本口座の取引記録にアクセスした後に口座を直接管理できるようにしたいと考えています。

<<variable_timelock_multisig>> は、Mohammed がこれを達成するために設計したリディームスクリプトです（行番号が付されています）。

[[variable_timelock_multisig]]
.タイムロック付きの可変マルチシグ
====
----
01  OP_IF
02    OP_IF
03      2
04    OP_ELSE
05      <30 days> OP_CHECKSEQUENCEVERIFY OP_DROP
06      <Lawyer's Pubkey> OP_CHECKSIGVERIFY
07      1
08    OP_ENDIF
09    <Mohammed's Pubkey> <Saeed's Pubkey> <Zaira's Pubkey> 3 OP_CHECKMULTISIG
10  OP_ELSE
11    <90 days> OP_CHECKSEQUENCEVERIFY OP_DROP
12    <Lawyer's Pubkey> OP_CHECKSIG
13  OP_ENDIF
----
====

Mohammed のスクリプトは、ネストされた +OP_IF...OP_ELSE+ フロー制御句を使用して三つの実行パスを実装します。

最初の実行パスでは、このスクリプトは三人のパートナーによる単純な 2-of-3 マルチシグとして動作します。この実行パスは、行 3 と 9 で構成されています。行 3 はマルチシグの定足数を +2+ (2-of-3) に設定します。この実行パスは、入力スクリプトの末尾に +OP_TRUE OP_TRUE+ を置くことで選択できます。

.最初の実行パス (2-of-3 マルチシグ) の支出データ
----
OP_0 <Mohammed's Sig> <Zaira's Sig> OP_TRUE OP_TRUE
----

[TIP]
====
この入力スクリプトの先頭にある +OP_0+ は、+OP_CHECKMULTISIG+ がスタックから余分な値をポップするという奇妙さのためです。余分な値は +OP_CHECKMULTISIG+ によって無視されますが、存在しなければスクリプトは失敗します。空のバイト配列を +OP_0+ でプッシュすることは、この奇妙さに対する回避策です。詳細は <<multisig_bug>> を参照してください。
====

第二の実行パスは、UTXO の作成から 30 日が経過した後にのみ使用できます。その時点で、弁護士と三人のパートナーのうち一人の署名が必要です (1-of-3 マルチシグ)。これは、行 7 によってマルチシグの定足数を +1+ に設定することで達成されます。この実行パスを選択するには、入力スクリプトの末尾を +OP_FALSE OP_TRUE+ にします。

.第二の実行パス (弁護士 + 1-of-3) の支出データ
----
OP_0 <Saeed's Sig> <Lawer's Sig> OP_FALSE OP_TRUE
----

[TIP]
====
なぜ +OP_FALSE OP_TRUE+ なのか？逆ではないのか？+FALSE+ がスタックにプッシュされ、その上に +TRUE+ がプッシュされます。
したがって、+TRUE+ は最初の +OP_IF+ オペコードによって _最初に_ ポップされます。
====

最後に、3 つ目の実行パスでは、弁護士が単独で資金を使うことができますが、それは 90 日後のみです。この実行パスを選択するには、インプットスクリプトが +OP_FALSE+ で終わる必要があります。

.3 つ目の実行パスのインプットスクリプト (弁護士のみ)
----
<Lawyer's Sig> OP_FALSE
----

スクリプトを紙の上で実行して、スタック上でどのように動作するかを確認してみてください。

==== セグリゲーテッド・ウィットネスのアウトプットとトランザクションの例

いくつかの例のトランザクションを見て、セグリゲーテッド・ウィットネスでどのように変わるかを確認しましょう。まず、P2PKH 支払いがセグリゲーテッド・ウィットネスプログラムとしてどのように実現できるかを見てみます。次に、P2SH スクリプトのセグリゲーテッド・ウィットネス版を見てみます。最後に、前述のセグリゲーテッド・ウィットネスプログラムの両方を P2SH スクリプト内に埋め込む方法を見てみます。

[[p2wpkh]]
===== ウィットネス公開鍵ハッシュへの支払い (P2WPKH)

P2PKH アウトプットスクリプトの例を見てみましょう。

.P2PKH アウトプットスクリプトの例
----
OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 
OP_EQUALVERIFY OP_CHECKSIG
----

セグリゲーテッド・ウィットネスを使用すると、アリスは P2WPKH スクリプトを作成します。そのスクリプトが同じ公開鍵にコミットする場合、次のようになります。

.P2WPKH アウトプットスクリプトの例
----
0 ab68025513c3dbd2f7b92a94e0581f5d50f654e7
----

ご覧のとおり、P2WPKH アウトプットスクリプトは P2PKH の同等のものよりもはるかに簡単です。スクリプト評価スタックにプッシュされる 2 つの値で構成されています。古い (セグウィット非対応の) ビットコインクライアントには、2 つのプッシュは誰でも使えるアウトプットのように見えます。新しい、セグウィット対応のクライアントには、最初の数字 (0) がバージョン番号 (_ウィットネスバージョン_) として解釈され、2 番目の部分 (20 バイト) が _ウィットネスプログラム_ です。20 バイトのウィットネスプログラムは、P2PKH スクリプトと同様に公開鍵のハッシュです。

さて、次に Bob がこの出力を使って支出するための対応するトランザクションを見てみましょう。元のスクリプトの場合、支出トランザクションにはトランザクション入力内に署名を含める必要があります。

.署名を使って P2PKH 出力が支出されることを示すデコードされたトランザクション
----
[...]
"vin" : [
  "txid": "abcdef12345...",
  "vout": 0,
  "scriptSig": “<Bob’s scriptSig>”,
]
[...]
----

しかし、P2WPKH 出力を支出するためには、その入力に署名がありません。代わりに、Bob のトランザクションには空の入力スクリプトがあり、witness 構造を含んでいます。

.証人構造を使って P2WPKH 出力が支出されることを示すデコードされたトランザクション
----
[...]
"vin" : [
  "txid": "abcdef12345...",
  "vout": 0,
  "scriptSig": “”,
]
[...]
“witness”: “<Bob’s witness structure>”
[...]
----

===== P2WPKH のウォレット構築

P2WPKH witness プログラムは受取人によってのみ作成されるべきであり、既知の公開鍵、P2PKH スクリプト、またはアドレスから支出者によって変換されるべきではないことを強調しておくことが非常に重要です。支出者は、受取人のウォレットが segwit トランザクションを構築し、P2WPKH 出力を支出する能力があるかどうかを知る方法がありません。

さらに、P2WPKH 出力は圧縮された公開鍵のハッシュから構築されなければなりません。非圧縮公開鍵は segwit では非標準であり、将来のソフトフォークによって明示的に無効にされる可能性があります。P2WPKH で使用されるハッシュが非圧縮公開鍵から来た場合、それは支出不可能であり、資金を失う可能性があります。P2WPKH 出力は、支払受取人のウォレットによって、彼らの秘密鍵から圧縮公開鍵を導出することによって作成されるべきです。

[WARNING]
====
P2WPKH は、圧縮公開鍵を P2WPKH ハッシュに変換することによって受取人によって構築されるべきです。支出者や他の誰も P2PKH スクリプト、Bitcoin アドレス、または非圧縮公開鍵を P2WPKH witness スクリプトに変換するべきではありません。一般に、支出者は受取人が示した方法でのみ受取人に送金するべきです。
====

[[p2wsh]]
===== Pay to witness script hash (P2WSH)

segwit v0 witness プログラムの第二のタイプは P2SH スクリプトに対応します。このタイプのスクリプトは <<p2sh>> で見ました。その例では、Mohammed の会社がマルチシグネチャスクリプトを表現するために P2SH を使用しました。Mohammed の会社への支払いは次のようなスクリプトでエンコードされました。

.Example P2SH output script
----
OP_HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e OP_EQUAL
----

この P2SH スクリプトは、資金を使うための 2-of-3 マルチシグネチャ要件を定義する _redeem script_ のハッシュを参照しています。この出力を使うためには、モハメッドの会社はリディームスクリプト（そのハッシュが P2SH 出力のスクリプトハッシュと一致する）と、そのリディームスクリプトを満たすために必要な署名をトランザクション入力内で提示します。

.Decoded transaction showing a P2SH output being spent
----
[...]
"vin" : [
  "txid": "abcdef12345...",
  "vout": 0,
  "scriptSig": “<SigA> <SigB> <2 PubA PubB PubC PubD PubE 5 OP_CHECKMULTISIG>”,
]
----

では、この全体の例が segwit v0 にどのようにアップグレードされるかを見てみましょう。モハメッドの顧客が segwit 対応のウォレットを使用している場合、彼らは支払いを行い、次のような P2WSH 出力を作成します。

.Example P2WSH output script
----
0 a9b7b38d972cabc7961dbfbcb841ad4508d133c47ba87457b4a0e8aae86dbb89
----

P2WPKH の例と同様に、セグリゲーテッドウィットネスの同等スクリプトははるかにシンプルで、P2SH スクリプトで見られるテンプレートのオーバーヘッドを削減しています。代わりに、セグリゲーテッドウィットネス出力スクリプトは、スタックにプッシュされる 2 つの値で構成されています。ウィットネスバージョン (0) とウィットネススクリプトの 32 バイトの SHA256 ハッシュ (ウィットネスプログラム) です。

[TIP]
====
P2SH が 20 バイトの +RIPEMD160(SHA256(script))+ ハッシュを使用するのに対し、P2WSH ウィットネスプログラムは 32 バイトの +SHA256(script)+ ハッシュを使用します。このハッシュアルゴリズムの選択の違いは、特定のユースケースで P2WSH により強力なセキュリティを提供するために意図的に行われています（P2WSH では 128 ビットのセキュリティ、P2SH では 80 ビットのセキュリティ）。詳細は <<p2sh_collision_attacks>> を参照してください。
====

モハメッドの会社は、正しいウィットネススクリプトとそれを満たすのに十分な署名を提示することで P2WSH 出力を使うことができます。ウィットネススクリプトと署名はウィットネス構造の一部として含まれます。これはネイティブウィットネスプログラムであり、従来の入力スクリプトフィールドを使用しないため、入力スクリプトにはデータが配置されません。


.Decoded transaction showing a P2WSH output being spent with witness structure
----
[...]
"vin" : [
  "txid": "abcdef12345...",
  "vout": 0,
  "scriptSig": “”,
]
[...]
“witness”: “<SigA> <SigB> <2 PubA PubB PubC PubD PubE 5 OP_CHECKMULTISIG>”
[...]
----

===== P2WPKH と P2WSH の区別

前の二つのセクションでは、二種類のウィットネスプログラムを示しました：<<p2wpkh>> と <<p2wsh>> です。両方のウィットネスプログラムは、同じバージョン番号に続いてデータプッシュで構成されます。見た目は非常に似ていますが、解釈は非常に異なります。一方は公開鍵ハッシュとして解釈され、署名によって満たされ、もう一方はスクリプトハッシュとして解釈され、ウィットネススクリプトによって満たされます。これらの間の重要な違いは、ウィットネスプログラムの長さです。

- P2WPKH のウィットネスプログラムは 20 バイトです。
- P2WSH のウィットネスプログラムは 32 バイトです。

この違いが、フルノードが二種類のウィットネスプログラムを区別することを可能にします。ハッシュの長さを見ることで、ノードはそれが P2WPKH か P2WSH かを判断できます。

==== セグウィットへのアップグレード

前の例からわかるように、セグウィットへのアップグレードは二段階のプロセスです。まず、ウォレットはセグウィットタイプのアウトプットを作成しなければなりません。その後、これらのアウトプットは、セグウィットトランザクションを構築する方法を知っているウォレットによって消費されます。例では、アリスのウォレットはセグウィットアウトプットスクリプトに支払うアウトプットを作成することができます。ボブのウォレットもセグウィット対応で、これらのアウトプットを消費することができます。

Segregated witness は後方互換性のあるアップグレードとして実装されました。ここでは、_古いクライアントと新しいクライアントが共存できる_ ということです。ウォレット開発者は独立してウォレットソフトウェアをアップグレードし、segwit 機能を追加しました。レガシー P2PKH と P2SH は、[.keep-together]#非アップグレード#ウォレットでも引き続き動作します。これにより、次のセクションで説明する 2 つの重要なシナリオが残ります。

- segwit を認識していない支払者のウォレットが、segwit トランザクションを処理できる受取人のウォレットに支払いを行う能力。

- segwit を認識している支払者のウォレットが、受取人が segwit を認識しているかどうかを _アドレス_ によって識別し区別する能力。

===== P2SH 内に segregated witness を埋め込む

例えば、((("埋め込まれた segregated witness")))((("P2SH (pay to script hash)", "埋め込まれた segregated witness")))アリスのウォレットが segwit にアップグレードされておらず、ボブのウォレットがアップグレードされて segwit トランザクションを処理できると仮定しましょう。アリスとボブはレガシーの非 segwit 出力を使用できます。しかし、ボブはおそらく、証人構造のコスト削減を利用してトランザクション手数料を削減するために segwit を使用したいと考えるでしょう。

この場合、ボブのウォレットは segwit スクリプトを含む P2SH アドレスを構築できます。アリスのウォレットは segwit を知らなくてもこれに支払いを行うことができます。その後、ボブのウォレットは segwit トランザクションを使用してこの支払いを消費し、segwit を利用してトランザクション手数料を削減できます。

P2WPKH と P2WSH の両方の形式の証人スクリプトは、P2SH アドレスに埋め込むことができます。最初のものはネストされた P2WPKH として記載され、2 番目のものはネストされた P2WSH として記載されます。

===== ネストされた pay to witness public key hash

最初に((("P2WPKH (pay to witness public key hash)", "ネスト", id="p2wpkh-nest")))((("ネスト", "P2WPKH (pay to witness public key hash)", id="nest-p2wpkh-ch7")))((("アドレス", "P2WPKH (pay to witness public key hash)", "ネスト", id="address-p2wpkh-nest")))検討する出力スクリプトの形式はネストされた P2WPKH です。これは、pay to witness public key hash 証人プログラムを pay to script hash スクリプト内に埋め込んだもので、segwit を認識していないウォレットでも出力スクリプトに支払いを行うことができます。

Bob のウォレットは、Bob の公開鍵を使って P2WPKH ウィットネスプログラムを構築します。このウィットネスプログラムはハッシュ化され、結果のハッシュが P2SH スクリプトとしてエンコードされます。P2SH スクリプトは Bitcoin アドレスに変換され、「3」で始まるアドレスになります。これは <<p2sh>> で見た通りです。

Bob のウォレットは、先ほど見た P2WPKH ウィットネスバージョンとウィットネスプログラムから始まります。

.Bob の P2WPKH ウィットネスバージョンとウィットネスプログラム
----
0 ab68025513c3dbd2f7b92a94e0581f5d50f654e7
----

データはウィットネスバージョンと Bob の 20 バイトの公開鍵ハッシュで構成されています。

Bob のウォレットは次にデータをハッシュ化します。まず SHA256 で、次に RIPEMD-160 でハッシュ化し、別の 20 バイトのハッシュを生成します。次に、リディームスクリプトハッシュを Bitcoin アドレスに変換します。最後に、Alice のウォレットは他の Bitcoin アドレスと同様に +37Lx99uaGn5avKBxiW26HjedQE3LrDCZru+ に支払いを行うことができます。

Bob に支払うために、Alice のウォレットは出力を P2SH スクリプトでロックします。
----
OP_HASH160 3e0547268b3b19288b3adef9719ec8659f4b2b0b OP_EQUAL
----

Alice のウォレットが segwit をサポートしていなくても、彼女が作成する支払いは Bob が segwit トランザクションで消費することができます。

===== ネストされたウィットネススクリプトハッシュへの支払い

同様に、P2WSH ウィットネスプログラムはマルチシグスクリプトや他の複雑なスクリプトのために P2SH スクリプトとアドレスの中に埋め込むことができ、どのウォレットでも segwit 互換の支払いを行うことが可能になります。

<<p2wsh>> で見たように、Mohammed の会社はマルチシグネチャスクリプトへのセグウィット支払いを使用しています。彼の会社に支払うクライアントが、ウォレットが segwit にアップグレードされているかどうかに関係なく支払いを行えるようにするために、Mohammed のウォレットは P2WSH ウィットネスプログラムを P2SH スクリプトの中に埋め込むことができます。

まず、Mohammed のウォレットは witness スクリプトを SHA256 でハッシュ化します（一度だけ）。これにより、次のハッシュが生成されます：

----
9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73
----

次に、ハッシュ化された witness スクリプトはバージョンプレフィックス付きの P2WSH witness プログラムに変換されます：

----
0 9592d601848d04b172905e0ddb0adde59f1590f1e553ffc81ddc4b0ed927dd73
----

その後、witness プログラム自体が SHA256 と RIPEMD-160 でハッシュ化され、新しい 20 バイトのハッシュが生成されます：

----
86762607e8fe87c0c37740cddee880988b9455b2
----

次に、ウォレットはこのハッシュから P2SH ビットコインアドレスを構築します：

.P2SH Bitcoin address
----
3Dwz1MXhM6EfFoJChHCxh1jWHb8GQqRenG
----

これで、Mohammed のクライアントは segwit をサポートしていなくてもこのアドレスに支払いを行うことができます。Mohammed に支払いを送るために、ウォレットは次の P2SH スクリプトで出力をロックします：

.P2SH script used to lock payments to Mohammed's multisig
----
OP_HASH160 86762607e8fe87c0c37740cddee880988b9455b2 OP_EQUAL
----

Mohammed の会社はこれらの支払いを使って segwit トランザクションを構築し、segwit の機能を活用してトランザクション手数料を低く抑えることができます。

[[mast]]
=== Merklized Alternative Script Trees (MAST)

+OP_IF+ を使用することで、複数の異なる支払い条件を承認することができますが、このアプローチにはいくつかの望ましくない側面があります：


重み（コスト）：
条件を追加するたびにスクリプトのサイズが増加し、トランザクションの重みが増し、そのスクリプトで保護されたビットコインを使うために支払うべき手数料の額が増えます。

サイズの制限：
追加条件のために支払う意志があっても、スクリプトに入れられる条件の最大数には制限があります。例えば、レガシースクリプトは 10,000 バイトに制限されており、実際には数百の条件分岐に制限されます。仮にスクリプトをブロック全体のサイズにできたとしても、約 20,000 の有用な分岐しか含められません。これは単純な支払いには多いですが、ビットコインの想定される用途に比べると非常に少ないです。

プライバシーの欠如：
スクリプトに追加する条件はすべて、そのスクリプトで保護されたビットコインを使うときに公開されます。例えば、モハメッドの弁護士やビジネスパートナーは、誰かが <<variable_timelock_multisig>> から支払うたびにスクリプト全体を見ることができます。つまり、たとえ弁護士が署名に必要でなくても、彼らのすべてのトランザクションを追跡できるということです。

しかし、ビットコインはすでに、セットの他のすべてのメンバーを特定することなく、要素がセットのメンバーであることを検証することを可能にするデータ構造であるマークルツリーを使用しています。

<<merkle_trees>> でマークルツリーについて詳しく学びますが、基本的な情報として、私たちが欲しいデータのセットのメンバー（例えば、任意の長さの認証条件）は、ハッシュ関数に渡されて短いコミットメント（マークルツリーの _葉_ と呼ばれる）を作成できます。それぞれの葉は別の葉とペアになり、再びハッシュされ、葉へのコミットメントである _ブランチ_ コミットメントが作成されます。ブランチのペアへのコミットメントも同じ方法で作成できます。このステップはブランチに対して繰り返され、最終的に _マークルルート_ と呼ばれる一つの識別子が残ります。<<variable_timelock_multisig>> の例のスクリプトを使用して、<<diagram_mast1>> の 3 つの認証条件それぞれに対してマークルツリーを構築します。

[[diagram_mast1]]
.3 つのサブスクリプトを持つ MAST。
image::images/mbc3_0705.png["3 つのサブスクリプトを持つ MAST"]

特定の認証条件がマークルツリーのメンバーであることを、他のメンバーの詳細を開示せずに証明するコンパクトなメンバーシップ証明を作成できるようになりました。<<diagram_mast2>> を参照してください。影付きのノードはユーザが提供する他のデータから計算できるため、支出時に指定する必要はありません。

[[diagram_mast2]]
.サブスクリプトの一つに対する MAST メンバーシップ証明。
image::images/mbc3_0706.png["A MAST membership proof for one of the sub-scripts"]

[role="less_space pagebreak-before"]
コミットメントを作成するために使用されるハッシュダイジェストはそれぞれ 32 バイトです。したがって、<<diagram_mast2>> の支出が認証されていることを証明するには（マークルツリーと特定の条件を使用して）383 バイトを使用します。比較として、マークルツリーを使用しない同じ支出（すべての可能な認証条件を提供する場合）は 412 バイトを使用します。

この例で 29 バイト（7%）を節約することは、潜在的な節約を完全には表していません。マークルツリーの二分木の性質により、セット内のメンバー数（この場合は認証条件）が倍増するたびに、追加の 32 バイトのコミットメントが必要になります。この例では、3 つの条件で 3 つのコミットメントを使用する必要があります（そのうちの 1 つは認証データに含める必要があるマークルルートです）。同じコストで 4 つのコミットメントを持つこともできます。追加のコミットメントにより、最大 8 つの条件を持つことができます。16 のコミットメント、つまり 512 バイトのコミットメントで、32,000 を超える認証条件を持つことができ、これは +OP_IF+ ステートメントで満たされたトランザクションのブロック全体で効果的に使用できる数をはるかに超えています。128 のコミットメント（4,096 バイト）で、理論上作成できる条件の数は、世界中のすべてのコンピュータが作成できる条件の数をはるかに超えます。

すべての認証条件が同じように使用される可能性があるわけではないことが一般的です。この例では、モハメッドと彼のパートナーが頻繁にお金を使うことを期待しています。時間遅延条件は何か問題が発生した場合にのみ存在します。この知識をもとに、<<diagram_mast3>> に示すようにツリーを再構築できます。

[[diagram_mast3]]
.最も期待されるスクリプトが最適な位置にある MAST
image::images/mbc3_0707.png["最も期待されるスクリプトが最適な位置にある MAST"]

[role="less_space pagebreak-before"]
一般的なケースでは 2 つのコミットメントを提供するだけで済みます (32 バイト節約) が、あまり一般的でないケースでは 3 つのコミットメントが必要です。異なる認証条件を使用する確率を知っている (または推測できる) 場合は、ハフマンアルゴリズムを使用してそれらを最大効率のツリーに配置できます。詳細は BIP341 を参照してください。

ツリーがどのように構築されているかに関係なく、前の例で見たように、実際に使用される認証条件のみを公開しています。他の条件は非公開のままです。また、条件の数も非公開です。ツリーには単一の条件がある場合もあれば、1 兆の条件がある場合もありますが、単一のトランザクションのオンチェーンデータを見ただけではわかりません。

Bitcoin の複雑さをわずかに増すことを除けば、Bitcoin に対する MAST の重大な欠点はなく、BIP114 と BIP116 の 2 つの堅実な提案がありましたが、より優れたアプローチが発見されました。それは <<taproot>> で見ていきます。

.MAST 対 MAST
****
Bitcoin における現在の _MAST_ の最も初期のアイデアは、_メルクル化された抽象構文木_ でした。抽象構文木 (AST) では、スクリプト内のすべての条件が新しい枝を作成します。これは <<ast>> に示されています。

[[ast]]
.スクリプトの抽象構文木 (AST)
image::images/mbc3_0708.png["スクリプトの抽象構文木 (AST)"]

AST は、コンパイラなどの他のプログラムのコードを解析し最適化するプログラムによって広く使用されています。メルクル化された AST は、プログラムのすべての部分にコミットし、<<mast>> で説明されている機能を可能にしますが、プログラムの各部分ごとに少なくとも 1 つの 32 バイトのダイジェストを公開する必要があり、ほとんどのプログラムにとってブロックチェーン上で非常にスペース効率が悪くなります。

今日 Bitcoin で一般的に _MAST_ と呼ばれているものは、開発者 Anthony Towns によって作られた逆頭字語である _メルクル化された代替スクリプトツリー_ です。代替スクリプトツリーは、それぞれが完全に独立したスクリプトのセットであり、1 つだけが選択されることができるため、互いに代替となります。これは <<alt_script>> に示されています。


[[alt_script]]
.代替スクリプトツリー
image::images/mbc3_0709.png["代替スクリプトツリー"]

代替スクリプトツリーでは、支出者が選んだスクリプトとツリーのルートとの間の各深さレベルに対して、32 バイトのダイジェストを 1 つだけ公開する必要があります。ほとんどのスクリプトにおいて、これはブロックチェーン内での空間のより効率的な利用です。

****

[[pay_to_contract]]
=== Pay to Contract (P2C)

<<public_child_key_derivation>> で見たように、楕円曲線暗号 (ECC) の数学を利用すると、アリスは秘密鍵を使ってボブに渡す公開鍵を導出できます。ボブはその公開鍵に任意の値を加えて派生公開鍵を作成できます。その任意の値をアリスに渡せば、アリスはそれを秘密鍵に加えて派生公開鍵の秘密鍵を導出できます。つまり、ボブはアリスだけが対応する秘密鍵を作成できる子公開鍵を作成できるのです。これは BIP32 スタイルの階層的決定性 (HD) ウォレットの復旧に役立ちますが、他の用途にも使えます。

ボブがアリスから何かを購入したいが、後で何を支払ったかを証明できるようにしたいと想像してみましょう。アリスとボブは販売されるアイテムやサービスの名前 (例：「アリスのポッドキャストエピソード #123」) に合意し、その説明をハッシュ化してハッシュダイジェストを数値として解釈します。ボブはその数値をアリスの公開鍵に加えて支払います。このプロセスは _キーの調整_ と呼ばれ、その数値は _調整_ として知られています。

アリスは同じ数値 (調整) を使って秘密鍵を調整することで資金を使うことができます。

後で、ボブはアリスに支払ったことを誰にでも証明するために、アリスの基礎鍵と使用した説明を公開できます。誰でも支払われた公開鍵が基礎鍵と説明へのハッシュコミットメントの合計であることを確認できます。アリスがその鍵が自分のものであると認めれば、彼女は支払いを受け取ったことになります。アリスが資金を使った場合、彼女が支出トランザクションに署名した時点で説明を知っていたことをさらに証明します。なぜなら、彼女が調整された公開鍵の有効な署名を作成できるのは、調整 (説明) を知っていた場合だけだからです。

もしアリスもボブも使用する説明を公に公開しないことを選択した場合、彼らの間の支払いは他の支払いと同じように見えます。プライバシーの損失はありません。

P2C はデフォルトでプライベートであるため、元の目的でどのくらい頻繁に使用されているかを知ることはできません。理論的にはすべての支払いがそれを使用している可能性がありますが、それはありそうにないと考えています。しかし、P2C は今日、少し異なる形で広く使用されています。それを <<taproot>> で見ることができます。

[[scriptless_multisignatures_and_threshold_signatures]]
=== スクリプトレスマルチシグネチャとしきい値署名

<<multisig>> では、複数の鍵からの署名を要求するスクリプトを見ました。しかし、複数の鍵の協力を要求する別の方法もあり、これもまた紛らわしく _マルチシグネチャ_ と呼ばれています。このセクションでは、2 つのタイプを区別するために、`OP_CHECKSIG` スタイルのオペコードを含むバージョンを _スクリプトマルチシグネチャ_ と呼び、もう一方のバージョンを _スクリプトレスマルチシグネチャ_ と呼びます。

スクリプトレスマルチシグネチャでは、各参加者が秘密鍵を作成するのと同じ方法で自分の秘密を作成します。この秘密を _部分秘密鍵_ と呼びますが、通常の完全な秘密鍵と同じ長さであることに注意してください。部分秘密鍵から、各参加者は <<public_key_derivation>> で説明した通常の公開鍵に使用するのと同じアルゴリズムを使用して部分公開鍵を導出します。各参加者は自分の部分公開鍵を他のすべての参加者と共有し、すべての鍵を組み合わせてスクリプトレスマルチシグネチャ公開鍵を作成します。

この組み合わせた公開鍵は、他のどのビットコイン公開鍵とも同じように見えます。第三者は、マルチパーティ公開鍵と単一のユーザによって生成された通常の鍵を区別することはできません。

ビットコインをスクリプトレスマルチシグネチャ公開鍵で保護された状態で使うには、各参加者が部分署名を生成します。これらの部分署名を組み合わせて、通常の完全な署名を作成します。部分署名を作成し組み合わせる方法は多く知られています。このトピックについては <<c_signatures>> で詳しく見ていきます。スクリプトレスマルチシグネチャの公開鍵と同様に、このプロセスで生成された署名は他のビットコイン署名と同じように見えます。第三者は、署名が一人の人間によって作成されたのか、あるいは何百万人もの人々が協力して作成したのかを判断することはできません。

スクリプトレスマルチシグネチャは、スクリプト化されたマルチシグネチャよりも小さく、よりプライベートです。スクリプト化されたマルチシグネチャでは、トランザクションに置かれるバイト数は関与するキーと署名の数に応じて増加します。スクリプトレスマルチシグネチャでは、サイズは一定です。100万人の参加者がそれぞれ自分の部分キーと部分署名を提供しても、単一のキーと署名を使用する個人と同じ量のデータがトランザクションに置かれます。プライバシーについても同様です。新しいキーや署名がトランザクションにデータを追加するため、スクリプト化されたマルチシグネチャは使用されているキーと署名の数に関するデータを開示します。これにより、どのトランザクションがどの参加者グループによって作成されたかを特定しやすくなるかもしれません。しかし、すべてのスクリプトレスマルチシグネチャは他のスクリプトレスマルチシグネチャや単一署名と同じように見えるため、プライバシーを低下させるデータは漏れません。

++++
<p class="fix_tracking">
スクリプトレスマルチシグネチャには二つの欠点があります。第一に、ビットコイン用にそれらを作成するための既知の安全なアルゴリズムは、スクリプト化されたマルチシグネチャよりも多くのラウンドの対話や、より慎重な状態管理を必要とします。これは、ほぼステートレスなハードウェア署名デバイスで署名が生成され、キーが物理的に分散されている場合に挑戦となることがあります。例えば、ハードウェア署名デバイスを銀行の貸金庫に保管している場合、スクリプト化されたマルチシグネチャを作成するにはそのボックスを一度訪れる必要がありますが、スクリプトレスマルチシグネチャの場合は二度または三度訪れる必要があるかもしれません。
</p>
++++

他の欠点として、しきい値署名では誰が署名したかが明らかにならないことがあります。スクリプト化されたしきい値署名では、アリス、ボブ、キャロルが（例えば）彼らのうちの任意の二人が署名すれば資金を使うのに十分であると合意します。アリスとボブが署名した場合、それぞれの署名をチェーン上に置く必要があり、彼らの鍵を知っている誰にでも彼らが署名し、キャロルが署名していないことを証明します。スクリプトレスしきい値署名では、アリスとボブの署名は、アリスとキャロルまたはボブとキャロルの署名と区別がつきません。これはプライバシーにとって有益ですが、キャロルが署名していないと主張しても、それを証明できないため、説明責任や監査可能性にとっては悪いかもしれません。

多くのユーザやユースケースにとって、常に小さいサイズとマルチシグネチャのプライバシーの向上は、署名の作成と監査における時折の課題を上回ります。

[[taproot]]
=== Taproot

人々がビットコインを使用する理由の一つは、結果が非常に予測可能な契約を作成できることです。法廷で執行される法的契約は、事件に関与する裁判官や陪審員の判断に一部依存します。対照的に、ビットコインの契約はしばしば参加者の行動を必要としますが、それ以外は機能的に同一のコードを実行する何千ものフルノードによって執行されます。同じ契約と同じ入力を与えられた場合、すべてのフルノードは常に同じ結果を出します。どんな逸脱もビットコインが壊れていることを意味します。人間の裁判官や陪審員はソフトウェアよりも柔軟性がありますが、その柔軟性が望まれないまたは必要でない場合、ビットコイン契約の予測可能性は大きな資産です。

契約の参加者全員がその結果が完全に予測可能であると認識した場合、実際には契約を続行する必要はありません。契約が求めることを実行し、その後契約を終了すればよいのです。社会においては、これはほとんどの契約が終了する方法です。関係者が満足していれば、契約を裁判官や陪審員の前に持ち出すことはありません。ビットコインにおいては、ブロックスペースを大幅に使用して決済する契約は、代わりに相互の満足によって決済できる条項を提供するべきです。

MAST とスクリプトレスマルチシグネチャを使用する場合、相互の満足条項は簡単に設計できます。スクリプトツリーのトップリーフの一つを、関係者全員のスクリプトレスマルチシグネチャにするだけです。<<diagram_mast3>> では、複数の関係者間の複雑な契約に、単純な相互の満足条項があることをすでに見ました。スクリプト付きマルチシグネチャからスクリプトレスマルチシグネチャに切り替えることで、それをさらに最適化できます。

これは合理的に効率的でプライベートです。相互の満足条項が使用される場合、提供する必要があるのは単一のマークルブランチだけで、署名が関与していることだけが明らかになります（それは一人からのものかもしれませんし、何千人もの異なる参加者からのものかもしれません）。しかし、2018年の開発者たちは、ペイ・トゥ・コントラクトも使用すればさらに良くなることに気付きました。

<<pay_to_contract>> でのペイ・トゥ・コントラクトの以前の説明では、アリスとボブの間の合意のテキストにコミットするために公開鍵を調整しました。代わりに、MAST のルートにコミットすることで契約のプログラムコードにコミットできます。調整する公開鍵は通常のビットコインの公開鍵であり、単一の人物からの署名を要求することも、複数の人からの署名を要求することもできます（または、署名を生成することが不可能な特別な方法で作成されることもあります）。つまり、関係者全員からの単一の署名で契約を満たすことも、使用したい MAST ブランチを公開することもできます。公開鍵と MAST の両方を含むこのコミットメントツリーは、<<diagram_taproot1>> に示されています。

[[diagram_taproot1]]
.公開鍵がマークルルートにコミットするタップルート
image::images/mbc3_0710.png["公開鍵がマークルルートにコミットするタップルート"]

これにより、マルチシグネチャを使用した相互満足条項が非常に効率的で非常にプライベートになります。それは、単一のユーザが単一の署名（または彼らが管理する複数の異なるウォレットによって生成されたマルチシグネチャ）で満足させたいと考えるトランザクションが、オンチェーン上で相互満足支出と同一に見えるため、見た目以上にプライベートです。この場合、非常に複雑な契約に関与する百万のユーザによる支出と、単に貯めたビットコインを使う単一のユーザによる支出の間にオンチェーンの違いはありません。

単一の署名やスクリプトレスマルチシグネチャのように、キーだけで支出が可能な場合、それは _keypath spending_（キー経路支出）と呼ばれます。スクリプトの木が使用される場合、それは _scriptpath spending_（スクリプト経路支出）と呼ばれます。キー経路支出では、オンチェーンに置かれるデータは公開鍵（ウィットネスプログラム内）と署名（ウィットネススタック上）です。

スクリプト経路支出では、オンチェーンデータには公開鍵も含まれ、これはウィットネスプログラムに配置され、この文脈では _taproot output key_（タップルート出力キー）と呼ばれます。ウィットネス構造には次の情報が含まれます：

* バージョン番号。

* 基本キー――マークルルートによって調整されてタップルート出力キーを生成する前に存在したキー。この基本キーは _taproot internal key_（タップルート内部キー）と呼ばれます。

* 実行するスクリプト、_leaf script_（リーフスクリプト）と呼ばれます。

* リーフをマークルルートに接続する経路に沿ったマークルツリーの各接合点に対する 32 バイトのハッシュ。

* スクリプトを満たすために必要なデータ（署名やハッシュのプレイメージなど）。

// 33 バイトのソース：https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017622.html

私たちが認識しているタップルートの唯一の重要な欠点は、MAST を使用したいが相互満足条項を望まない契約の参加者が、ブロックチェーン上にタップルート内部キーを含める必要があり、約 33 バイトのオーバーヘッドが追加されることです。ほとんどすべての契約が相互満足条項やトップレベルの公開鍵を使用する他のマルチシグネチャ条項から利益を得ると予想され、すべてのユーザが出力が互いに似ていることによる匿名性セットの増加から利益を得るため、その稀なオーバーヘッドはタップルートのアクティベーションに参加したほとんどのユーザによって重要視されませんでした。

ビットコインに対する taproot のサポートは、2021年11月にソフトフォークで有効化されました。このフォークでは、((("scripts", "MAST", "taproot", startref="script-mast-taproot")))((("MAST (merklized alternative script trees)", "taproot", startref="mast-taproot")))((("merkle trees", "MAST", "taproot", startref="merkle-tree-mast-taproot")))((("taproot", startref="taproot-ch7")))((("mutual satisfaction contracts", "taproot", startref="mutual-satisfaction-taproot")))が導入されました。

=== Tapscript

//FIXME:mention "control block" (maybe in MAST section)

Taproot は ((("tapscript", id="tapscript")))((("mutual satisfaction contracts", "tapscript", id="mutual-satisfaction-tapscript")))MAST を可能にしますが、以前使用されていたビットコインスクリプト言語とはわずかに異なるバージョンを使用します。この新しいバージョンは _tapscript_ と呼ばれます。主な違いは以下の通りです。

[role="less_space pagebreak-before"]
スクリプト化されたマルチシグネチャの変更::
  旧 +OP_CHECKMULTISIG+ および +OP_CHECKMULTISIGVERIFY+ オペコードは削除されました。これらのオペコードは、taproot ソフトフォークの他の変更の一つである、バッチ検証を用いたシュノア署名の使用（<<schnorr_signatures>>を参照）と組み合わせるのに適していません。代わりに新しい +OP_CHECKSIGADD+ オペコードが提供されます。この新しいオペコードは署名を正常に検証するとカウンタを1つ増やし、通過した署名の数を便利に数えることができ、+OP_CHECKMULTISIG+ と同じ動作を再実装するために必要な成功署名の数と比較できます。

すべての署名に対する変更::
  tapscript のすべての署名操作は、BIP340で定義されたシュノア署名アルゴリズムを使用します。シュノア署名については、<<c_signatures>>でさらに詳しく探ります。
+
さらに、成功しないと予想される署名チェック操作には、実際の署名の代わりに +OP_FALSE+（+OP_0+ とも呼ばれる）を与える必要があります。失敗した署名チェック操作に他の何かを提供すると、スクリプト全体が失敗します。これにより、シュノア署名のバッチ検証もサポートされます。

++OP_SUCCESSx++ オペコード::
  以前のバージョンのスクリプトで使用できなかったオペコードは、使用されるとスクリプト全体が成功するように再定義されました。これにより、将来のソフトフォークで特定の状況下で成功しないように再定義することが可能になります。これは制限であり、ソフトフォークで行うことが可能です。（逆に、成功しない操作を成功と定義することはハードフォークでしか行えず、はるかに困難なアップグレードパスです。）

この章では認証と認可について詳しく見てきましたが、ビットコインが支出者を認証する非常に重要な部分である署名については省略してきました。次にその点について<<c_signatures>>で見ていきます。

//FIXME:text "一般的な tapscript に関する情報をもっと追加するべきだと思います。MAST のセクションは taproot のセクションに統合して簡潔にする方が良いでしょう。また、taproot のマークルツリーがどのようにユニークであるか（葉のソート、タグ付きハッシュなど）についても言及するべきです。"
