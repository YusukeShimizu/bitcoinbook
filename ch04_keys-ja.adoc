[[ch04_keys_addresses]]
== 鍵とアドレス

アリスはボブに支払いをしたいのですが、彼女の取引を検証する何千ものビットコインフルノードはアリスやボブが誰であるかを知りませんし、彼らのプライバシーを守るためにそのままにしておきたいのです。アリスは、ボブが彼女のビットコインの一部を受け取るべきであることを、ボブの実世界の身元やボブが受け取る他のビットコインの支払いと結びつけることなく伝える必要があります。アリスが使用する方法は、ボブだけが受け取ったビットコインをさらに使うことができるようにする必要があります。

元のビットコイン論文では、これらの目標を達成するための非常にシンプルなスキームが説明されています。それが <<pay-to-pure-pubkey>> に示されています。

[[pay-to-pure-pubkey]]
.元のビットコイン論文からの取引チェーン。
image::images/mbc3_aain01.png["元のビットコイン論文からの取引チェーン"]

ボブのような受取人は、送信者（アリスのような）によって署名された取引で公開鍵にビットコインを受け取ります。アリスが使っているビットコインは、以前に彼女の公開鍵の一つに受け取られたものであり、彼女は対応する秘密鍵を使って署名を生成します。フルノードは、アリスの署名がボブの公開鍵や他の取引の詳細にコミットするハッシュ関数の出力にコミットしていることを検証できます。

この章では、公開鍵、秘密鍵、署名、ハッシュ関数を調べ、それらをすべて組み合わせて現代のビットコインソフトウェアで使用されるアドレスを説明します。

=== 公開鍵暗号

公開鍵暗号は1970年代に発明され、現代のコンピュータと情報セキュリティの数学的基盤となっています。

公開鍵暗号の発明以来、素数のべき乗や楕円曲線の乗算など、いくつかの適切な数学的関数が発見されました。これらの数学的関数は、一方向には計算が容易であり、今日利用可能なコンピュータとアルゴリズムを使用して逆方向に計算することは不可能です。これらの数学的関数に基づいて、暗号は偽造不可能なデジタル署名の作成を可能にします。ビットコインは、その暗号の基礎として楕円曲線の加算と乗算を使用しています。

ビットコインでは、公開鍵暗号を使用してビットコインへのアクセスを制御する鍵ペア (key pairs) を作成できます。鍵ペアは、秘密鍵とその秘密鍵から導出された公開鍵で構成されます。公開鍵は資金を受け取るために使用され、秘密鍵は資金を使うためにトランザクションに署名するために使用されます。

公開鍵と秘密鍵の間には数学的な関係があり、秘密鍵を使用してメッセージに署名を生成することができます。これらの署名は、秘密鍵を明らかにすることなく公開鍵に対して検証できます。

[TIP]
====
一部のウォレット実装では、秘密鍵と公開鍵が便利のために _鍵ペア_ として一緒に保存されます。しかし、公開鍵は秘密鍵から計算できるため、秘密鍵のみを保存することも可能です。
====

ビットコインウォレットには、秘密鍵と公開鍵からなる鍵ペアのコレクションが含まれています。秘密鍵 (_k_) は通常、ランダムに選ばれた数から導出される数です。秘密鍵から、楕円曲線乗算という一方向の暗号関数を使用して公開鍵 (_K_) を生成します。

[role="less_space pagebreak-before"]
.なぜ非対称暗号 (公開鍵/秘密鍵) を使用するのか？
****
ビットコインで非対称暗号 (asymmetric cryptography) が使用される理由は何でしょうか？それはトランザクションを「暗号化」(秘密にする) ためではありません。むしろ、非対称暗号の有用な特性は _デジタル署名_ を生成する能力です。秘密鍵はトランザクションに適用され、数値的な署名を生成します。この署名は、秘密鍵を知っている人だけが生成できます。しかし、公開鍵とトランザクションにアクセスできる人は誰でも、それらを使用して署名を _検証_ できます。この非対称暗号の有用な特性により、誰でもすべてのトランザクションのすべての署名を検証できる一方で、秘密鍵の所有者だけが有効な署名を生成できることが保証されます。
****

[[private_keys]]
==== 秘密鍵

秘密鍵 (private key) は単にランダムに選ばれた数です。秘密鍵の管理は、対応する Bitcoin 公開鍵に関連付けられたすべての資金に対するユーザの管理の根幹です。秘密鍵は、取引で使用される資金の管理を証明することによってビットコインを使うための署名を作成するために使用されます。秘密鍵は常に秘密にしておく必要があります。第三者に公開することは、その鍵で保護されたビットコインの管理を彼らに与えることと同じです。また、秘密鍵はバックアップされ、偶発的な紛失から保護される必要があります。紛失した場合、復元することはできず、それによって保護されている資金も永遠に失われます。

[TIP]
====
Bitcoin の秘密鍵は単なる数です。コイン、鉛筆、紙を使ってランダムに秘密鍵を選ぶことができます。コインを 256 回投げると、Bitcoin ウォレットで使用できるランダムな秘密鍵のバイナリ桁が得られます。その後、秘密鍵から公開鍵を生成できます。ただし、完全にランダムでないプロセスは、秘密鍵とそれが管理するビットコインのセキュリティを大幅に低下させる可能性があるため、注意が必要です。
====

鍵を生成する最初で最も重要なステップは、安全なランダム性のソースを見つけることです（コンピュータ科学者はこれを _エントロピー_ と呼びます）。Bitcoin 鍵を作成することは、ほぼ「1 から 2^256^ の間の数を選ぶ」ことと同じです。その数を選ぶ方法は、予測可能または再現可能でない限り、重要ではありません。Bitcoin ソフトウェアは、暗号的に安全な乱数生成器を使用して 256 ビットのエントロピーを生成します。

[role="less_space pagebreak-before"]
より正確には、秘密鍵は 0 から _n_ - 1 までの任意の数であり、ここで _n_ は Bitcoin で使用される楕円曲線の順序として定義された定数 (_n_ = 1.1578 × 10^77^、2^256^ よりわずかに小さい) です (<<elliptic_curve>> を参照)。このような鍵を作成するには、ランダムに 256 ビットの数を選び、それが _n_ より小さいことを確認します。プログラミング用語では、これは通常、暗号的に安全なランダム性のソースから収集されたより大きなランダムビット列を SHA256 ハッシュアルゴリズムに供給することによって達成されます。これにより、数として解釈できる 256 ビットの値が便利に生成されます。結果が _n_ より小さい場合、適切な秘密鍵が得られます。それ以外の場合は、別のランダムな数で再試行します。

[WARNING]
====
独自のコードを書いてランダムな数を生成したり、プログラミング言語が提供する「単純な」ランダム数生成器を使用したりしないでください。十分なエントロピー源からのシードを持つ暗号学的に安全な疑似乱数生成器 (CSPRNG) を使用してください。選択した乱数生成ライブラリのドキュメントを調べて、それが暗号学的に安全であることを確認してください。CSPRNG の正しい実装は、鍵のセキュリティにとって非常に重要です。
====

以下は、16 進数形式で表示されたランダムに生成された秘密鍵 (_k_) です (256 ビットが 64 個の 16 進数桁として表示され、各桁は 4 ビットです)：

----
1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD
----

[TIP]
====
Bitcoin の秘密鍵空間のサイズ (2^256^) は、想像を絶するほど大きな数です。これは 10^77^ に相当します。比較のために言うと、可視宇宙には 10^80^ 個の原子が含まれていると推定されています。
====

[[elliptic_curve]]
==== 楕円曲線暗号の説明

楕円曲線暗号 (ECC) は、離散対数問題に基づく非対称または公開鍵暗号の一種です。これは、楕円曲線上の点の加算と乗算によって表されます。

<<ecc-curve>> は、Bitcoin が使用するものと似た楕円曲線の例です。

[[ecc-curve]]
[role="width-50"]
.楕円曲線
image::images/mbc3_0402.png["ecc-curve"]

Bitcoin は、米国標準技術研究所 (NIST) によって確立された +secp256k1+ という標準で定義された特定の楕円曲線と一連の数学的定数を使用します。+secp256k1+ 曲線は、次の関数によって定義され、楕円曲線を生成します：

[latexmath]
++++
\begin{equation}
{y^2 = (x^3 + 7)}~\text{over}~(\mathbb{F}_p)
\end{equation}
++++

または

[latexmath]
++++
\begin{equation}
{y^2 \mod p = (x^3 + 7) \mod p}
\end{equation}
++++

_mod p_ (素数 _p_ による剰余) は、この曲線が素数階数 _p_ の有限体上にあることを示しています。これは latexmath:[\( \mathbb{F}_p\)] とも書かれ、_p_ = 2^256^ – 2^32^ – 2^9^ – 2^8^ – 2^7^ – 2^6^ – 2^4^ – 1 という非常に大きな素数です。

この曲線は実数ではなく素数階の有限体上で定義されているため、2 次元に散らばった点のパターンのように見え、視覚化が難しいです。しかし、数学的には実数上の楕円曲線と同じです。例として、<<ecc-over-F17-math>> は、素数階 17 のはるかに小さい有限体上の同じ楕円曲線を示しており、グリッド上の点のパターンを示しています。+secp256k1+ ビットコイン楕円曲線は、計り知れないほど大きなグリッド上のはるかに複雑な点のパターンと考えることができます。

[[ecc-over-F17-math]]
.楕円曲線暗号：F(p) 上の楕円曲線の視覚化、p=17。
image::images/mbc3_0403.png["ecc-over-F17-math"]

例えば、次のような座標 (x, y) を持つ点 P は、+secp256k1+ 曲線上の点です。

[source, python]
----
P = 
(55066263022277343669578718895168534326250603453777594175500187360389116729240,
32670510020758816978083085130507043184471273380659243275938904335757337482424)
----

<<example_4_1>> は、Python を使用して自分でこれを確認する方法を示しています。

[[example_4_1]]
.Python を使用してこの点が楕円曲線上にあることを確認する
====
[source, pycon]
----
Python 3.10.6 (main, Nov 14 2022, 16:10:14) [GCC 11.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
> p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
> x = 55066263022277343669578718895168534326250603453777594175500187360389116729240
> y = 32670510020758816978083085130507043184471273380659243275938904335757337482424
> (x ** 3 + 7 - y**2) % p
0
----
====

[role="less_space pagebreak-before"]
楕円曲線の数学では、「無限遠点」と呼ばれる点があり、これは加算におけるゼロの役割におおよそ対応します。コンピュータ上では、x = y = 0 と表現されることがあります（これは楕円曲線の方程式を満たしませんが、簡単にチェックできる別のケースです）。

また、pass:[+] 演算子と呼ばれる「加算」があり、これは小学校で学ぶ実数の伝統的な加算といくつかの性質が似ています。楕円曲線上の 2 点 P~1~ と P~2~ が与えられると、楕円曲線上の 3 番目の点 P~3~ = P~1~ + P~2~ があります。

幾何学的には、この第 3 の点 P~3~ は、P~1~ と P~2~ を結ぶ直線を引くことで計算されます。この直線は楕円曲線と正確にもう一つの点で交わります。この点を P~3~' = (x, y) と呼びます。そして、x 軸に反射させて P~3~ = (x, –y) を得ます。

「無限遠点」が必要な理由を説明する特別なケースがいくつかあります。

もし P~1~ と P~2~ が同じ点である場合、P~1~ と P~2~ の「間」の直線は、この点 P~1~ での曲線の接線として延長されるべきです。この接線は曲線と正確に新しい一点で交わります。接線の傾きを求めるために微積分の技法を使うことができます。これらの技法は、私たちが二つの整数座標を持つ曲線上の点に関心を限定しているにもかかわらず、不思議と機能します。

いくつかのケースでは（例えば、P~1~ と P~2~ が同じ x 値を持ち、異なる y 値を持つ場合）、接線は正確に垂直になります。この場合、P~3~ = 「無限遠点」となります。

もし P~1~ が「無限遠点」である場合、P~1~ + P~2~ = P~2~ です。同様に、もし P~2~ が無限遠点である場合、P~1~ + P~2~ = P~1~ です。これにより、無限遠点がゼロの役割を果たすことが示されます。

実際、pass:[+] は結合的であることが判明しています。つまり、(A pass:[+] B) pass:[+] C = A pass:[+] (B pass:[+] C) です。これにより、A pass:[+] B pass:[+] C を括弧なしで曖昧さなく書くことができます。

加算を定義したので、加算を拡張する標準的な方法で乗算を定義できます。楕円曲線上の点 P に対して、k が整数であれば、kP = P + P + P + ... + P (k 回) です。この場合、k は時々「指数」として混乱を招くことがあります。

[[public_key_derivation]]
==== 公開鍵

公開鍵は、楕円曲線乗算を使用して秘密鍵から計算されます。これは不可逆です：_K_ = _k_ × _G_ で、_k_ は秘密鍵、_G_ は _生成点_ と呼ばれる定数点、_K_ は結果として得られる公開鍵です。逆操作、つまり _K_ を知っている場合に _k_ を計算することは「離散対数を見つける」として知られ、_k_ のすべての可能な値を試すこと（すなわち、総当たり検索）と同じくらい困難です。秘密鍵から公開鍵を生成する方法を示す前に、楕円曲線暗号についてもう少し詳しく見てみましょう。


[TIP]
====
楕円曲線乗算は、暗号学者が「トラップドア」関数と呼ぶタイプの関数です。ある方向（乗算）では簡単にできるが、逆方向（除算）では不可能です。秘密鍵を持っている人は、簡単に公開鍵を作成し、それを世界と共有できます。この関数を逆にして公開鍵から秘密鍵を計算することはできません。この数学的トリックが、ビットコインの資金を管理していることを証明する偽造不可能で安全なデジタル署名の基礎となります。
====

ランダムに生成された数 _k_ の形式の秘密鍵から始めて、曲線上のあらかじめ決められた点である _生成点_ _G_ を掛けて、曲線上の別の点である対応する公開鍵 _K_ を生成します。生成点は +secp256k1+ 標準の一部として指定されており、ビットコインのすべての鍵に対して常に同じです：

[latexmath]
++++
\begin{equation}
{K = k \times G}
\end{equation}
++++

ここで _k_ は秘密鍵、_G_ は生成点、_K_ は曲線上の結果として得られる公開鍵です。生成点はすべてのビットコインユーザに対して常に同じであるため、秘密鍵 _k_ に _G_ を掛けると常に同じ公開鍵 _K_ になります。_k_ と _K_ の関係は固定されていますが、計算できるのは一方向、つまり _k_ から _K_ へのみです。そのため、ビットコインの公開鍵 (_K_) は誰とでも共有でき、ユーザの秘密鍵 (_k_) を明らかにしません。

[TIP]
====
秘密鍵は公開鍵に変換できますが、公開鍵は秘密鍵に戻すことはできません。なぜなら、数学的に一方向にしか機能しないからです。
====

楕円曲線乗算を実装する際には、以前に生成された秘密鍵 _k_ を取り、生成点 _G_ に掛けて公開鍵 _K_ を見つけます：

[source, python]
----
K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD × G
----

公開鍵 _K_ は点 _K_ = (_x_, _y_) として定義されます：

[latexmath]
++++
\begin{equation}
K = (x, y)
\end{equation}
++++

ここで、

----
x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
----

点と整数の乗算を視覚化するために、より簡単な実数上の楕円曲線を使用します。数学は同じです。私たちの目標は、生成点 _G_ の倍数 _kG_ を見つけることです。これは、_G_ を _k_ 回連続して自分自身に加えるのと同じです。楕円曲線では、点に自分自身を加えることは、その点に接線を引き、その線が曲線と再び交わる場所を見つけ、その点を x 軸に反射することと同等です。

<<ecc_illustrated>> は、曲線上での幾何学的操作として _G_、_2G_、_4G_ を導出するプロセスを示しています。

[TIP]
====
多くの Bitcoin 実装は、楕円曲線((("公開鍵", "生成", startref="public-key-generate")))((("楕円曲線乗算", startref="elliptic-multiply")))の数学を行うために、https://oreil.ly/wD60m[libsecp256k1 暗号ライブラリ]を使用します。
====

[[ecc_illustrated]]
.楕円曲線暗号：楕円曲線上で点 G を整数 k で乗算することを視覚化。
image::images/mbc3_0404.png["ecc_illustrated"]

=== 出力スクリプトと入力スクリプト

元の Bitcoin 論文のイラスト <<pay-to-pure-pubkey>> は、公開鍵 (pubkeys) と署名 (sigs) が直接使用されることを示していますが、Bitcoin の最初のバージョンでは、代わりに _出力スクリプト_ と呼ばれるフィールドに送金され、そのビットコインの支出は _入力スクリプト_ と呼ばれるフィールドによって承認されました。これらのフィールドは、署名が公開鍵に対応することを確認することに加えて（または代わりに）、追加の操作を実行することを可能にします。たとえば、出力スクリプトには 2 つの公開鍵を含め、対応する 2 つの署名を支出入力スクリプトに配置することを要求できます。

後で <<tx_script>> でスクリプトについて詳しく学びます。今のところ、ビットコインは公開鍵のように機能する出力スクリプトに受け取られ、ビットコインの支出は((("公開鍵暗号", "入力/出力スクリプト", startref="pub-key-input-output")))((("入力スクリプト", startref="input-script")))((("出力スクリプト", startref="output-script")))((("スクリプト", "入力/出力", startref="script-input-output")))署名のように機能する入力スクリプトによって承認されることを理解しておけば十分です。

[[p2pk]]
=== IP Addresses: The Original Address for Bitcoin (P2PK)

私たちは、アリスがボブの公開鍵の一つに彼女のビットコインを割り当てることでボブに支払いができることを確認しました。しかし、アリスはどうやってボブの公開鍵を手に入れるのでしょうか？ボブが単にコピーを渡すこともできますが、<<public_key_derivation>>で扱った公開鍵をもう一度見てみましょう。かなり長いことに気づくでしょう。ボブが電話でアリスにそれを読み上げることを想像してみてください：

----
x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
----

直接公開鍵を入力する代わりに、ビットコインソフトウェアの初期バージョンでは、送金者が受取人のIPアドレスを入力することができました（<<bitcoin_01_send>>に示されています）。この機能は後に削除されましたが（IPアドレスを使用するには多くの問題があります）、その簡単な説明は、なぜ特定の機能がビットコインプロトコルに追加されたのかを理解するのに役立ちます。

[[bitcoin_01_send]]
.初期のビットコイン送金画面（https://oreil.ly/IDV1a[The Internet Archive]より）
image::images/mbc3_0405.png["Early Bitcoin send screen"]

アリスがビットコイン 0.1 にボブのIPアドレスを入力すると、彼女のフルノードはボブのフルノードと接続を確立し、ボブのウォレットから新しい公開鍵を受け取ります。この公開鍵は、ボブのノードが以前に誰にも与えたことのないものであることが重要でした。これは、ブロックチェーンを見てすべての取引が同じ公開鍵に支払われていることに気づくことで、異なる取引がボブに支払われていることを誰かが関連付けられないようにするためです。

ボブのノードから受け取った公開鍵を使用して、アリスのウォレットは非常にシンプルな出力スクリプトを支払うトランザクション出力を構築します：

----
<Bob's public key> OP_CHECKSIG
----

ボブは後に、彼の署名だけで構成された入力スクリプトを使ってそのアウトプットを使用できるようになります。

----
<Bob's signature>
----

アウトプットと入力スクリプトが何をしているのかを理解するためには、それらを組み合わせて（まず入力スクリプトを）みることができます。そして、各データ（山括弧で示される）は、スタックと呼ばれるアイテムのリストの一番上に置かれます。オペレーションコード（オプコード）が出現すると、スタックの一番上のアイテムから順に使用します。次に、結合されたスクリプトを見てみましょう。

----
<Bob's signature> <Bob's public key> OP_CHECKSIG
----

このスクリプトでは、ボブの署名がスタックに置かれ、その上にボブの公開鍵が置かれます。+OP_CHECKSIG+ 操作は、公開鍵から始めて署名を続けて、2つの要素を消費し、それらをスタックから取り除きます。それは、署名が公開鍵に対応していることを確認し、トランザクションのさまざまなフィールドにコミット（署名）します。署名が正しければ、+OP_CHECKSIG+ はスタック上で自身を値 1 に置き換えます。署名が正しくなければ、0 に置き換えます。評価の最後にスタックの一番上に非ゼロのアイテムがあれば、スクリプトは通過します。トランザクション内のすべてのスクリプトが通過し、トランザクションに関する他のすべての詳細が有効であれば、フルノードはトランザクションを有効と見なします。

要するに、前述のスクリプトは、元の論文で説明されているのと同じ公開鍵と署名を使用していますが、2つのスクリプトフィールドとオプコードの複雑さを追加しています。ここでは余分な作業のように見えますが、次のセクションを見るとその利点がわかり始めます。

このタイプのアウトプットは、今日では _pay to public key_、略して _P2PK_ として知られています。これは支払いに広く使用されたことはなく、IPアドレス支払いをサポートする広く使用されているプログラムは、ほぼ 10 年間存在していません。


[[addresses_for_p2pkh]]
=== P2PKH のレガシーアドレス

支払いたい相手の IP アドレスを入力することには多くの利点がありますが、いくつかの欠点もあります。特に、受取人のウォレットがその IP アドレスでオンラインである必要があり、外部からアクセス可能でなければならないという欠点があります。多くの人にとって、それは選択肢になりません。夜間にコンピュータをオフにしたり、ノートパソコンがスリープ状態になったり、ファイアウォールの背後にいたり、ネットワークアドレス変換 (NAT) を使用している場合があります。

これにより、ボブのような受取人がアリスのような支払者に長い公開鍵を渡さなければならないという問題に戻ります。初期の Bitcoin 開発者が知っていた Bitcoin 公開鍵の最短バージョンは 65 バイトで、16 進数で書かれると 130 文字に相当します。しかし、Bitcoin にはすでに 65 バイトよりもはるかに大きなデータ構造がいくつか含まれており、それらを Bitcoin の他の部分で最小限のデータで安全に参照する必要があります。

Bitcoin はそれを _ハッシュ関数_ で実現します。これは、潜在的に大量のデータを取り込み、それをスクランブル（ハッシュ）して、固定量のデータを出力する関数です。暗号学的ハッシュ関数は、同じ入力を与えられたときに常に同じ出力を生成し、また安全な関数は、以前に見た出力を生成する異なる入力を選ぶことを実質的に不可能にします。これにより、出力は入力への _コミットメント_ となります。実際には、入力 _x_ のみが出力 _X_ を生成するという約束です。

例えば、あなたに質問をして、すぐには読めない形で私の答えを渡したいとします。質問は「サトシ・ナカモトが Bitcoin の作業を開始したのは何年ですか？」としましょう。私は、Bitcoin で最も一般的に使用される関数である SHA256 ハッシュ関数の出力の形で、私の答えへのコミットメントをあなたに渡します。

----
94d7a772612c8f2f2ec609d41f5bd3d04a5aa1dfe3582f04af517d396a302e4e
----

後で、あなたが質問の答えを推測した後に、私の答えを明かして、その答えがハッシュ関数への入力として、先ほどお見せした出力とまったく同じものを生成することを証明できます：

----
$ echo "2007.  He said about a year and a half before Oct 2008" | sha256sum
94d7a772612c8f2f2ec609d41f5bd3d04a5aa1dfe3582f04af517d396a302e4e
----

さて、ボブに「あなたの公開鍵は何ですか？」と質問すると想像してみてください。ボブはハッシュ関数を使って、彼の公開鍵に対する暗号的に安全なコミットメントを私たちに提供できます。後で彼が鍵を明かし、それが以前に彼が提供したコミットメントと同じものであることを確認できれば、それが以前のコミットメントを作成するために使用されたまったく同じ鍵であることを確信できます。

SHA256ハッシュ関数は非常に安全とされており、256ビット（32バイト）の出力を生成します。これは元のビットコイン公開鍵のサイズの半分以下です。しかし、出力が小さい、やや安全性が低いハッシュ関数もあります。例えば、((("RIPEMD-160 hash function")))RIPEMD-160ハッシュ関数は160ビット（20バイト）の出力を生成します。サトシ・ナカモトが理由を述べたことはありませんが、ビットコインのオリジナルバージョンは、公開鍵に対するコミットメントを作成する際に、まず鍵をSHA256でハッシュし、その出力をRIPEMD-160でハッシュすることで、公開鍵に対する20バイトのコミットメントを生成しました。

[role="less_space pagebreak-before"]
それをアルゴリズム的に見てみましょう。
公開鍵 _K_ から始めて、SHA256ハッシュを計算し、その結果のRIPEMD-160ハッシュを計算して、160ビット（20バイト）の数値を生成します：

[latexmath]
++++
\begin{equation}
{A = RIPEMD160(SHA256(K))}
\end{equation}
++++

ここで _K_ は公開鍵で、_A_ は結果として得られるコミットメントです。

公開鍵に対するコミットメントの作成方法を理解したので、それをトランザクションでどのように使用するかを考える必要があります。次の出力スクリプトを考えてみてください：

----
OP_DUP OP_HASH160 <Bob's commitment> OP_EQUAL OP_CHECKSIG
----

そして次の入力スクリプトも：

----
<Bob's signature> <Bob's public key>
----

一緒に、それらは次のスクリプトを形成します：

----
<sig> <pubkey> OP_DUP OP_HASH160 <commitment> OP_EQUALVERIFY OP_CHECKSIG
----

<<p2pk>> で行ったように、スタックにアイテムを置き始めます。まずボブの署名を置き、次に彼の公開鍵をスタックの上に置きます。+OP_DUP+ 操作は最上位のアイテムを複製するので、スタックの最上位とその次のアイテムはどちらもボブの公開鍵になります。+OP_HASH160+ 操作は最上位の公開鍵を消費（削除）し、それを +RIPEMD160(SHA256(K))+ でハッシュした結果に置き換えます。これでスタックの最上位はボブの公開鍵のハッシュになります。次に、ボブの公開鍵へのコミットメントがスタックの最上位に追加されます。+OP_EQUALVERIFY+ 操作は最上位の2つのアイテムを消費し、それらが等しいことを確認します。これは、ボブが入力スクリプトで提供した公開鍵が、アリスが支払った出力スクリプトでコミットメントを作成するために使用された公開鍵と同じである場合に成立するはずです。+OP_EQUALVERIFY+ が失敗すると、スクリプト全体が失敗します。最後に、スタックにはボブの署名と彼の公開鍵だけが残ります。+OP_CHECKSIG+ オペコードはそれらが互いに対応していることと、署名がトランザクションにコミットしていることを確認します。

公開鍵ハッシュへの支払い (_P2PKH_) のこのプロセスは複雑に見えるかもしれませんが、アリスのボブへの支払いが、元のビットコインのバージョンであれば65バイトであった公開鍵そのものではなく、彼の公開鍵への20バイトのコミットメントだけを含むことを可能にします。これは、ボブがアリスに伝えるデータがはるかに少なくて済むことを意味します。

しかし、ボブがその20バイトを彼のビットコインウォレットからアリスのウォレットにどのように送るかについてはまだ説明していません。バイト値には一般的に使用されるエンコーディング（例えば16進数）がありますが、コミットメントをコピーする際にミスがあると、ビットコインが使えない出力に送られ、永遠に失われてしまいます。次のセクションでは、コンパクトなエンコーディングと信頼性のあるチェックサムについて見ていきます。

[[base58]]
=== Base58check エンコーディング

長い数字をコンパクトに表現するために、より少ない記号を使って、多くのコンピュータシステムは 10 以上の基数（または基底）を持つ混合英数字表現を使用します。例えば、従来の十進法システムは 0 から 9 までの 10 の数字を使用しますが、十六進法システムは 16 を使用し、A から F までの 6 つの追加記号を含みます。十六進法形式で表現された数字は、同等の十進法表現よりも短くなります。さらにコンパクトな base64 表現は、26 の小文字、26 の大文字、10 の数字、そして "+" や "/" などの 2 つの文字を使用して、メールなどのテキストベースのメディア上でバイナリデータを送信します。

Base58 は base64 に似たエンコーディングで、大文字と小文字のアルファベットと数字を使用しますが、特定のフォントで表示されるときに頻繁に間違えられたり、同一に見える文字を省略しています。具体的には、base58 は 0（数字のゼロ）、O（大文字のオー）、l（小文字のエル）、I（大文字のアイ）、および記号 "+" と "/" を除いた base64 です。つまり、先に述べた 4 つ（0, O, l, I）を除いた小文字と大文字のアルファベットと数字のセットです。<<base58alphabet>> は base58 の完全なアルファベットを示しています。

[[base58alphabet]]
.Bitcoin の base58 アルファベット
====
----
123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
----
====

タイプミスや転記エラーに対する追加のセキュリティを提供するために、base58check は base58 アルファベットでエンコードされた _チェックサム_ を含みます。チェックサムは、エンコードされるデータの末尾に追加される 4 バイトの追加データです。チェックサムはエンコードされたデータのハッシュから導出されるため、転記や入力エラーを検出するために使用できます。base58check コードが提示されたとき、デコードソフトウェアはデータのチェックサムを計算し、コードに含まれるチェックサムと比較します。もし二つが一致しない場合、エラーが発生しており、base58check データは無効です。これにより、誤入力された Bitcoin アドレスがウォレットソフトウェアによって有効な送信先として受け入れられることを防ぎます。これは、そうでなければ資金の損失につながるエラーです。

データ（数値）を base58check 形式に変換するには、まずデータにプレフィックスを追加します。これは「バージョンバイト」と呼ばれ、エンコードされたデータの種類を簡単に識別するためのものです。例えば、プレフィックスのゼロ（16進数で 0x00）は、データがレガシー P2PKH 出力スクリプトのコミットメント（ハッシュ）として使用されるべきことを示します。一般的なバージョンプレフィックスの一覧は <<base58check_versions>> に示されています。

次に、「ダブル SHA」チェックサムを計算します。これは、前の結果（プレフィックスとデータを連結したもの）に対して SHA256 ハッシュアルゴリズムを 2 回適用することを意味します：

----
checksum = SHA256(SHA256(prefix||data))
----

得られた 32 バイトのハッシュ（ハッシュのハッシュ）から最初の 4 バイトだけを取り出します。これらの 4 バイトはエラーチェックコード、つまりチェックサムとして機能します。チェックサムは末尾に追加されます。

結果はプレフィックス、データ、およびチェックサムの 3 つの項目で構成されます。この結果は、前述の base58 アルファベットを使用してエンコードされます。<<base58check_encoding>> は base58check エンコードプロセスを示しています。

[[base58check_encoding]]
.Base58check エンコード：ビットコインデータを明確にエンコードするための base58、バージョン付き、チェックサム付き形式。
image::images/mbc3_0406.png["Base58checkEncoding"]

++++
<p class="fix_tracking2">
ビットコインでは、公開鍵コミットメント以外のデータも base58check エンコードでユーザに提示され、データをコンパクトにし、読みやすくし、エラーを検出しやすくします。base58check エンコードのバージョンプレフィックスは、エンコードされた base58 の先頭に特定の文字を含む形式を作成するために使用されます。これらの文字により、人間がエンコードされたデータの種類とその使用方法を簡単に識別できるようになります。これが、例えば 1 で始まる base58check エンコードされたビットコインアドレスと、5 で始まる base58check エンコードされたプライベートキーウォレットインポート形式（WIF）を区別するものです。いくつかのバージョンプレフィックスとそれに対応する base58 文字の例は、<a data-type="xref" href="#base58check_versions">#base58check_versions</a> に示されています。
</p>
++++

++++
<table id="base58check_versions">
<caption>Base58check バージョンプレフィックスとエンコード結果の例</caption>
<thead>
<tr>
<th>タイプ</th>
<th>バージョンプレフィックス (hex)</th>
<th>Base58 結果プレフィックス</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>公開鍵ハッシュへの支払いアドレス (P2PKH)</p></td>
<td><p>0x00</p></td>
<td><p>1</p></td>
</tr>
<tr>
<td><p>スクリプトハッシュへの支払いアドレス (P2SH)</p></td>
<td><p>0x05</p></td>
<td><p>3</p></td>
</tr>
<tr>
<td><p>テストネットアドレス P2PKH</p></td>
<td><p>0x6F</p></td>
<td><p>m または n</p></td>
</tr>
<tr>
<td><p>テストネットアドレス P2SH</p></td>
<td><p>0xC4</p></td>
<td><p>2</p></td>
</tr>
<tr>
<td><p>秘密鍵 WIF</p></td>
<td><p>0x80</p></td>
<td><p>5, K, または L</p></td>
</tr>
<tr>
<td><p>BIP32 拡張公開鍵</p></td>
<td><p>0x0488B21E</p></td>
<td><p>xpub</p></td>
</tr>
</tbody>
</table>
++++

公開鍵、ハッシュベースのコミットメント、および base58check エンコーディングを組み合わせることで、<<pubkey_to_address>> は公開鍵を Bitcoin アドレスに変換する方法を示しています。

[[pubkey_to_address]]
.公開鍵から Bitcoin アドレスへ：公開鍵を Bitcoin アドレスに変換する。
image::images/mbc3_0407.png["pubkey_to_address"]

[[comp_pub]]
=== 圧縮公開鍵

//https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2011-November/000778.html

Bitcoin が最初に作成されたとき、開発者たちは 65 バイトの公開鍵を作成する方法しか知りませんでした。しかし、後に別の開発者が、33 バイトのみを使用する公開鍵の代替エンコーディングを発見しました。これは当時のすべての Bitcoin フルノードと後方互換性があったため、Bitcoin プロトコルを変更する必要はありませんでした。これらの 33 バイトの公開鍵は _圧縮公開鍵_ として知られ、元の 65 バイトの鍵は _非圧縮公開鍵_ として知られています。より小さな公開鍵を使用することで、トランザクションが小さくなり、同じブロック内でより多くの支払いを行うことができます。

私たちが <<public_key_derivation>> のセクションで見たように、公開鍵は楕円曲線上の点 (x, y) です。曲線は数学的な関数を表しているため、曲線上の点は方程式の解を表します。したがって、_x_ 座標がわかれば、方程式 y^2^ mod p = (x^3^ + 7) mod p を解くことで _y_ 座標を計算できます。これにより、公開鍵の点の _x_ 座標のみを保存し、_y_ 座標を省略して鍵のサイズと保存に必要なスペースを 256 ビット削減できます。各トランザクションでサイズがほぼ 50% 減少することで、時間が経つにつれて多くのデータを節約できます。

<<public_key_derivation>> で作成した秘密鍵によって生成された公開鍵は次のとおりです：

----
x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
----

同じ公開鍵を 520 ビットの数値 (130 進数) として、プレフィックス +04+ に続いて +x+ と +y+ 座標を +04 x y+ として示します：

++++
<pre data-type="programlisting">
K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A\
    07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
</pre>
++++

非圧縮公開鍵はプレフィックス +04+ を持ちますが、圧縮公開鍵は +02+ または +03+ のプレフィックスで始まります。なぜ 2 つの可能なプレフィックスがあるのか見てみましょう。方程式の左側が __y__^2^ であるため、_y_ の解は平方根であり、正または負の値を持つことができます。視覚的には、結果として得られる _y_ 座標は x 軸の上または下にあることを意味します。<<ecc-curve>> の楕円曲線のグラフからわかるように、曲線は対称であり、x 軸によって鏡のように反射されます。したがって、_y_ 座標を省略することはできますが、_y_ の符号 (正または負) を保存する必要があります。つまり、x 軸の上か下かを覚えておく必要があります。これらの選択肢のそれぞれが異なる点と異なる公開鍵を表すからです。素数 p の有限体上でバイナリ演算を行う際に楕円曲線を計算すると、_y_ 座標は偶数または奇数であり、前述の正負の符号に対応します。したがって、_y_ の 2 つの可能な値を区別するために、_y_ が偶数の場合はプレフィックス +02+、奇数の場合は +03+ を持つ圧縮公開鍵を保存し、ソフトウェアが _x_ 座標から _y_ 座標を正しく推測し、公開鍵を点の完全な座標に展開できるようにします。公開鍵の圧縮は <<pubkey_compression>> で説明されています。

[[pubkey_compression]]
.公開鍵の圧縮.
image::images/mbc3_0408.png["pubkey_compression"]

<<public_key_derivation>> で生成された同じ公開鍵を、圧縮された公開鍵として 264 ビット（16 進数で 66 桁）で示しています。プレフィックス +03+ は _y_ 座標が奇数であることを示しています：

----
K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
----

この圧縮された公開鍵は同じ秘密鍵に対応しており、同じ秘密鍵から生成されています。しかし、非圧縮の公開鍵とは見た目が異なります。さらに重要なのは、この圧縮された公開鍵を HASH160 関数 (+RIPEMD160(SHA256(K))+）を使ってコミットメントに変換すると、非圧縮の公開鍵とは異なるコミットメントが生成され、異なるアドレスが生じることです。これは、単一の秘密鍵が異なる形式（圧縮と非圧縮）で表現された公開鍵を生成し、それが異なるビットコインアドレスを生むことを意味するため、混乱を招く可能性があります。しかし、両方のビットコインアドレスに対する秘密鍵は同一です。

圧縮された公開鍵は、現在ほとんどのビットコインソフトウェアでデフォルトとなっており、後のプロトコルアップグレードで追加された特定の新機能を使用する際に必要とされました。

しかし、古いウォレットから秘密鍵をインポートするウォレットアプリケーションなど、一部のソフトウェアでは非圧縮の公開鍵をサポートする必要があります。新しいウォレットが古い P2PKH 出力と入力のためにブロックチェーンをスキャンする際、65 バイトの鍵（およびそれらのコミットメント）をスキャンするのか、33 バイトの鍵（およびそれらのコミットメント）をスキャンするのかを知る必要があります。正しいタイプをスキャンしないと、ユーザが全額を使えない可能性があります。この問題を解決するために、ウォレットから秘密鍵がエクスポートされる際、これらの秘密鍵が圧縮された公開鍵を生成するために使用されたことを示すために、新しいビットコインウォレットでは WIF がわずかに異なる方法で実装されています。

[[addresses_for_p2sh]]
=== レガシー Pay to Script Hash (P2SH)

前のセクションで見たように、ビットコインを受け取る人（例えばボブ）は、支払いに対して特定の制約を出力スクリプトに含めることができます。ボブはそのビットコインを使うときに、入力スクリプトを使ってその制約を満たす必要があります。<<p2pk>> では、制約は単に適切な署名を提供することでした。<<addresses_for_p2pkh>> では、適切な公開鍵も提供する必要がありました。

++++
<p class="fix_tracking3">
支払う人（例えばアリス）がボブの望む制約を彼女が使う出力スクリプトに含めるためには、ボブがその制約を彼女に伝える必要があります。これは、ボブが彼の公開鍵を彼女に伝える必要がある問題に似ています。その問題と同様に、公開鍵がかなり大きくなる可能性があるように、ボブが使用する制約も非常に大きくなる可能性があります—場合によっては数千バイトにもなります。それは、アリスに伝える必要がある数千バイトだけでなく、彼女がボブにお金を支払うたびに取引手数料を支払う必要がある数千バイトでもあります。しかし、大量のデータに対する小さなコミットメントを作成するためにハッシュ関数を使用する解決策もここに適用されます。
</p>
++++

2012年のビットコインプロトコルへの BIP16 アップグレードにより、出力スクリプトが _リデンプションスクリプト_ (_redeem script_) にコミットすることができるようになりました。ボブがビットコインを使うとき、彼の入力スクリプトはコミットメントに一致するリデンプションスクリプトと、リデンプションスクリプトを満たすために必要なデータ（例えば署名）を提供する必要があります。ボブがビットコインを使うためにデスクトップウォレットからの署名とハードウェア署名デバイスからの署名の2つを要求したいと想像してみましょう。彼はその条件をリデンプションスクリプトに入れます：

----
<public key 1> OP_CHECKSIGVERIFY <public key 2> OP_CHECKSIG
----

次に、彼は P2PKH コミットメントで使用されるのと同じ HASH160 メカニズムを使用して、リディームスクリプトへのコミットメントを作成します。+RIPEMD160(SHA256(script))+ を使用します。そのコミットメントは、特別なテンプレートを使用して出力スクリプトに配置されます。

----
OP_HASH160 <commitment> OP_EQUAL
----

[WARNING]
====
スクリプトハッシュへの支払い (P2SH) を使用する場合、出力スクリプトに余分なデータや条件を含めずに、特定の P2SH テンプレートを使用しなければなりません。出力スクリプトが +OP_HASH160 <20 bytes> OP_EQUAL+ と完全に一致しない場合、リディームスクリプトは使用されず、ビットコインが使えなくなるか、誰でも使えるようになる可能性があります（つまり、誰でもそれを取得できるということです）。
====

ボブが彼のスクリプトへのコミットメントに対して受け取った支払いを使おうとするとき、彼はリディームスクリプトを含む入力スクリプトを使用します。それは単一のデータ要素としてシリアライズされます。彼はまた、リディームスクリプトを満たすために必要な署名を提供し、それらをオペコードによって消費される順序で配置します。

----
<signature2> <signature1> <redeem script>
----

ビットコインのフルノードがボブの支出を受け取ると、シリアライズされたリディームスクリプトがコミットメントと同じ値にハッシュされることを確認します。そして、それをスタック上でデシリアライズされた値に置き換えます。

----
<signature2> <signature1> <pubkey1> OP_CHECKSIGVERIFY <pubkey2> OP_CHECKSIG
----

スクリプトが実行され、通過し、他のすべてのトランザクションの詳細が正しい場合、トランザクションは有効です。

P2SH のアドレスも base58check で作成されます。バージョンプレフィックスは 5 に設定され、エンコードされたアドレスは +3+ で始まります。P2SH アドレスの例は +3F6i6kwkevjR7AsAd4te2YB2zZyASEm1HM+ です。

[TIP]
====
P2SH は必ずしもマルチシグネチャトランザクションと同じではありません。P2SH アドレスは _ほとんどの場合_ マルチシグネチャスクリプトを表しますが、他の種類のトランザクションをエンコードするスクリプトを表すこともあります。
====

P2PKH と P2SH は、base58check エンコーディングで使用される唯一のスクリプトテンプレートです。これらは現在、レガシーアドレスとして知られており、時間とともに一般的ではなくなっています。レガシーアドレスは、bech32 ファミリーのアドレスに取って代わられました。

[[p2sh_collision_attacks]]
.P2SH 衝突攻撃
****
ハッシュ関数に基づくすべてのアドレスは、理論的には攻撃者が同じ入力を独立して見つけてハッシュ関数の出力（コミットメント）を生成する可能性に対して脆弱です。Bitcoin の場合、攻撃者が元のユーザと同じ方法で入力を見つけた場合、ユーザの秘密鍵を知ることができ、そのユーザのビットコインを使うことができます。既存のコミットメントに対して攻撃者が独立して入力を生成する可能性は、ハッシュアルゴリズムの強度に比例します。HASH160 のような安全な 160 ビットアルゴリズムの場合、その確率は 1-in-2^160^ です。これは _プレイメージ攻撃_ です。

攻撃者はまた、同じコミットメントを生成する異なる 2 つの入力（例えば、リディームスクリプト）を生成しようとすることもできます。完全に単一の当事者によって作成されたアドレスの場合、既存のコミットメントに対して攻撃者が異なる入力を生成する可能性も HASH160 アルゴリズムでは約 1-in-2^160^ です。これは _セカンドプレイメージ攻撃_ です。

しかし、攻撃者が元の入力値に影響を与えることができる場合、この状況は変わります。例えば、攻撃者がマルチシグネチャスクリプトの作成に参加し、他のすべての当事者の公開鍵を知った後に自分の公開鍵を提出する必要がない場合です。その場合、ハッシュアルゴリズムの強度は平方根に減少します。HASH160 の場合、その確率は 1-in-2^80^ になります。これは _衝突攻撃_ です。

// bits80=$( echo '2^80' | bc )
// seconds_per_hour="$(( 60 * 60))"
// bitcoin-cli getmininginfo | jq "(.networkhashps / $bits80 * $seconds_per_hour)"
// 0.8899382363032076

これらの数字を文脈に置くと、2023 年初頭の時点で、すべての Bitcoin マイナーが毎時約 2^80^ のハッシュ関数を実行しています。彼らは HASH160 とは異なるハッシュ関数を実行しているため、既存のハードウェアでは HASH160 に対する衝突攻撃を作成することはできませんが、Bitcoin ネットワークの存在は HASH160 のような 160 ビット関数に対する衝突攻撃が実用的であることを証明しています。Bitcoin マイナーは特殊なハードウェアに数十億ドル相当を費やしているため、衝突攻撃を作成することは安くはありませんが、複数の当事者が関与するプロセスによって生成されたアドレスに対して数十億ドルのビットコインを受け取ることを期待する組織も存在し、その攻撃が利益をもたらす可能性があります。

衝突攻撃を防ぐための確立された暗号プロトコルがありますが、ウォレット開発者が特別な知識を必要としない簡単な解決策は、より強力なハッシュ関数を使用することです。後の Bitcoin のアップグレードによりそれが可能になり、新しい Bitcoin アドレスは少なくとも 128 ビットの衝突耐性を提供します。2^128^ 回のハッシュ操作を実行するには、現在のすべての Bitcoin マイナーで約 320 億年かかります。

新しい P2SH アドレスを作成する誰かに対する即時の脅威はないと考えていますが、すべての新しいウォレットが新しいタイプのアドレスを使用して、アドレス衝突攻撃を懸念事項として排除することを推奨します((("public key cryptography", "hash functions and", startref="pub-key-hash2")))((("hash functions", "Bitcoin payments and", startref="hash-payment2")))((("payments", "with hash functions", secondary-sortas="hash functions", startref="payment-hash2")))((("P2SH (pay to script hash)", startref="p2sh-ch4")))((("addresses", "P2SH (pay to script hash)", startref="address-p2sh-ch4")))。
****

=== Bech32 アドレス

2017 年に、((("public key cryptography", "bech32 addresses", "advantages of", id="pub-key-bech32-adv")))((("addresses", "bech32", "advantages of", id="address-bech32-adv")))((("bech32 addresses", "advantages of", id="bech32-adv")))Bitcoin プロトコルがアップグレードされました。このアップグレードを使用すると、支出ユーザ（または複数の署名が必要な場合の署名者のクォーラム）の同意なしにトランザクション識別子 (txids) が変更されるのを防ぎます。このアップグレードは、_segregated witness_（略して _segwit_）と呼ばれ、ブロック内のトランザクションデータの追加容量やその他のいくつかの利点を提供しました。しかし、segwit の利点に直接アクセスしたいユーザは、新しい出力スクリプトへの支払いを受け入れる必要がありました。

<<p2sh>> で述べたように、P2SH 出力タイプの利点の一つは、支出者（例えばアリス）が受取人（例えばボブ）が使用するスクリプトの詳細を知る必要がないことでした。segwit アップグレードはこのメカニズムを利用するように設計されており、ユーザが P2SH アドレスを使用することで多くの新しい利点にすぐにアクセスできるようにしました。しかし、ボブがすべての利点にアクセスするには、アリスのウォレットが異なるタイプのスクリプトを使用して彼に支払う必要があります。それには、アリスのウォレットが新しいスクリプトをサポートするようにアップグレードする必要があります。

最初に、Bitcoin の開発者たちは BIP142 を提案しました。これは P2SH のアップグレードと同様に、新しいバージョンバイトを使用して base58check を継続するものでした。しかし、すべてのウォレットが新しい base58check バージョンのスクリプトにアップグレードするには、新しいアドレス形式に完全にアップグレードするのとほぼ同じくらいの作業が必要と予想されました。そのため、いくつかの Bitcoin 貢献者たちは、可能な限り最良のアドレス形式を設計することに取り組みました。彼らは base58check にいくつかの問題を見つけました（「公開鍵暗号」「base58check エンコーディング」）（「base58check エンコーディング」）（「エンコーディング」「base58check」）：

- 混在する大文字と小文字の表示が、読み上げや書き写しに不便でした。この章のレガシーアドレスの一つを友人に読み上げて、書き写してもらってみてください。すべての文字に「大文字」や「小文字」といった言葉を前置きしなければならないことに気づくでしょう。また、彼らの書いたものを確認すると、多くの人の手書きでは大文字と小文字のバージョンが似て見えることがあります。

- エラーを検出することはできますが、そのエラーを修正する手助けはできません。例えば、アドレスを手動で入力する際に誤って二つの文字を入れ替えた場合、ウォレットはほぼ確実にミスがあることを警告しますが、エラーがどこにあるのかを見つける手助けはしてくれません。最終的にミスを発見するまでに、いくつかのフラストレーションを感じる数分を費やすかもしれません。

- 混在する大文字と小文字のアルファベットは、QR コードにエンコードする際にも余分なスペースを必要とします。QR コードはウォレット間でアドレスや請求書を共有するためによく使用されます。その余分なスペースのために、QR コードは同じ解像度でより大きくする必要があるか、迅速にスキャンするのが難しくなります。

[role="less_space pagebreak-before"]
- P2SH や segwit のような新しいプロトコル機能をサポートするために、すべての支出者ウォレットのアップグレードが必要です。アップグレード自体は多くのコードを必要としないかもしれませんが、経験上、多くのウォレット作成者は他の作業で忙しく、アップグレードを数年間遅らせることがあります。これは、新しい機能を使用したいすべての人に悪影響を及ぼします。

segwit のアドレス形式に取り組んでいる開発者たちは、bech32 と呼ばれる新しいアドレス形式でこれらの問題のそれぞれに対する解決策を見つけました（「besh thirty-two」と発音します）。「bech」は、1959 年と 1960 年に bech32 の基礎となる巡回コードを発見した三人の個人のイニシャルである BCH を表しています。「32」は bech32 アルファベットの文字数を表しています（base58check の 58 に似ています）：

- Bech32 は数字と単一のケースの文字 (小文字で表示するのが望ましい) のみを使用します。そのアルファベットは base58check のアルファベットのほぼ半分のサイズですが、支払い先の witness 公開鍵ハッシュ (P2WPKH) スクリプトの bech32 アドレスは、同等の P2PKH スクリプトのレガシーアドレスよりもわずかに長いだけです。

- Bech32 はエラーを検出し、修正を支援することができます。期待される長さのアドレスでは、4 文字以下に影響を与えるエラーを数学的に確実に検出します。これは base58check よりも信頼性が高いです。より長いエラーの場合、それを検出しない確率は 10 億分の 1 未満であり、これは base58check とほぼ同じ信頼性です。さらに良いことに、わずかなエラーで入力されたアドレスの場合、ユーザにそのエラーが発生した場所を教えることができ、ユーザは小さな転記ミスを迅速に修正できます。エラーが入力されたアドレスの例については <<bech32_typo_detection>> を参照してください。
+
[[bech32_typo_detection]]
.Bech32 typo detection
====
Address:
  bc1p9nh05ha8wrljf7ru236awpass:[<u><strong>n</strong></u>]4t2x0d5ctkkywmpass:[<u><strong>v</strong></u>]9sclnm4t0av2vgs4k3au7

Detected errors shown in bold and underlined.  Generated using the
https://oreil.ly/paWIx[bech32 address decoder demo].
====

- Bech32 は小文字のみで書くのが望ましいですが、QR コードにアドレスをエンコードする前にその小文字を大文字に置き換えることができます。これにより、より少ないスペースを使用する特別な QR エンコードモードを使用することができます。同じアドレスの 2 つの QR コードのサイズと複雑さの違いに注目してください <<bech32_qrcode_uc_lc>>。
+
[[bech32_qrcode_uc_lc]]
.The same bech32 address QR encoded in lowercase and uppercase.
image::images/mbc3_0409.png["The same bech32 address QR encoded in lowercase and uppercase"]

- Bech32 は、spender ウォレットがまだ使用されていない出力タイプに支払うことができるようにするために segwit の一部として設計されたアップグレードメカニズムを利用します。この目標は、今日 bech32 アドレスに支払うことができるウォレットを開発し、そのウォレットが将来のプロトコルアップグレードで追加される新機能のユーザに対しても bech32 アドレスに支払うことができるようにすることでした。これにより、P2SH や segwit を完全に使用できるようにするために必要なシステム全体のアップグレードサイクルを再び経験する必要がないことが期待されました。

==== Problems with Bech32 Addresses

Bech32 addresses((("public key cryptography", "bech32 addresses", "problems with", id="pub-key-bech32-prob")))((("addresses", "bech32", "problems with", id="address-bech32-prob")))((("bech32 addresses", "problems with", id="bech32-prob")))は、ある問題を除けばすべての面で成功していたでしょう。アドレスの誤りを検出する能力に関する数学的保証は、ウォレットに入力するアドレスの長さが元のアドレスの長さと同じである場合にのみ適用されます。転記中に文字を追加または削除すると、その保証は適用されず、ウォレットが誤ったアドレスに資金を送ってしまう可能性があります。しかし、保証がなくても、ユーザが文字を追加または削除しても有効なチェックサムを持つ文字列を生成することは非常に稀であり、ユーザの資金は安全であると考えられていました。

残念ながら、bech32アルゴリズムの定数の一つの選択が、アドレスの最後から2番目の位置に「p」で終わるアドレスに「q」を追加または削除することを非常に容易にしてしまいました。その場合、「q」を複数回追加または削除することも可能です。これはチェックサムによって一部は検出されますが、bech32の置換エラーの一兆分の一の期待値よりもはるかに頻繁に見逃されます。例については、<<bech32_length_extension_example>>を参照してください。

[role="less_space pagebreak-before"]
[[bech32_length_extension_example]]
.Extending the length of bech32 address without invalidating its checksum
====
----
Intended bech32 address:
bc1pqqqsq9txsqp

Incorrect addresses with a valid checksum:
bc1pqqqsq9txsqqqqp
bc1pqqqsq9txsqqqqqqp
bc1pqqqsq9txsqqqqqqqqp
bc1pqqqsq9txsqqqqqqqqqp
bc1pqqqsq9txsqqqqqqqqqqqp
----
====
//from segwit_addr import *
//
//for foo in range(0,1000):
//    addr = encode('bc', 1, foo.to_bytes(3,'big'))
//    print(foo, addr)

初期バージョンのsegwit (version 0) では、これは実際的な問題ではありませんでした。v0 segwit出力には22バイトと34バイトの2つの有効な長さのみが定義されていました。それらは42文字または62文字のbech32アドレスに対応しているため、ウォレットが検出できない無効なアドレスに資金を送るためには、bech32アドレスの最後から2番目の位置に「q」を20回追加または削除する必要があります。しかし、将来的にsegwitベースのアップグレードが((("public key cryptography", "bech32 addresses", "problems with", startref="pub-key-bech32-prob")))((("addresses", "bech32", "problems with", startref="address-bech32-prob")))((("bech32 addresses", "problems with", startref="bech32-prob")))実装されると、ユーザにとって問題になる可能性があります。


==== Bech32m

bech32 は segwit v0 ではうまく機能しましたが、開発者たちは後のバージョンの segwit で出力サイズを不必要に制限したくありませんでした。制約がない場合、bech32 アドレス内の「q」を一つ追加または削除するだけで、ユーザが誤って送金先を使えない出力や誰でも使える出力にしてしまう可能性がありました（そのビットコインを誰でも取得できるようになる）。開発者たちは bech32 の問題を徹底的に分析し、アルゴリズム内の定数を一つ変更することでこの問題を解消し、最大で 5 文字の挿入または削除が検出されない確率を 10 億分の 1 以下にすることができると発見しました。

//https://gist.github.com/sipa/a9845b37c1b298a7301c33a04090b2eb

定数が一つ異なる bech32 のバージョンは bech32 modified (bech32m) として知られています。同じ基礎データに対する bech32 と bech32m アドレスのすべての文字は、最後の 6 文字（チェックサム）を除いて同一です。つまり、ウォレットはチェックサムを検証するためにどのバージョンが使用されているかを知る必要がありますが、両方のアドレスタイプには内部バージョンバイトが含まれているため、それを簡単に判断できます。

bech32 と bech32m の両方を扱うために、bech32m ビットコインアドレスのエンコードとパースのルールを見ていきます。これらは bech32 アドレスをパースする能力を含んでおり、ビットコインウォレットの現在の推奨アドレス形式です。

bech32m アドレスは、人間が読める部分 (HRP) で始まります。独自の HRP を作成するためのルールは BIP173 にありますが、ビットコインの場合はすでに選ばれている HRP について知っておくだけで十分です。それは <<bech32_hrps_for_bitcoin>> に示されています。

++++
<table id="bech32_hrps_for_bitcoin">
<caption>ビットコインの Bech32 HRP</caption>
<thead>
<tr>
<th>HRP</th>
<th>ネットワーク</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>bc</p></td>
<td><p>ビットコインメインネット</p></td>
</tr>
<tr>
<td><p>tb</p></td>
<td><p>ビットコインテストネット</p></td>
</tr>
</tbody>
</table>
++++

HRP の後には区切り文字として数字の「1」が続きます。以前のプロトコル区切り文字の提案ではコロンが使われていましたが、ユーザがダブルクリックで単語を選択してコピー＆ペーストする際に、コロンを含めてハイライトが拡張されないオペレーティングシステムやアプリケーションがあるためです。数字を使用することで、bech32m 文字列をサポートするプログラム（他の数字を含む）であれば、ダブルクリックでのハイライトが機能することが保証されました。数字の「1」が選ばれたのは、bech32 文字列ではそれを使用しないことで、数字の「1」と小文字の「l」の間での誤った翻訳を防ぐためです。

bech32m アドレスのもう一つの部分は「データ部分」と呼ばれます。この部分には三つの要素があります：

Witness バージョン::
  区切り文字の直後に bech32m Bitcoin アドレス内で単一の文字としてエンコードされる単一バイトです。この文字は segwit バージョンを表します。文字「q」は segwit v0 の「0」のエンコードで、bech32 アドレスが導入された初期バージョンの segwit を示します。文字「p」は segwit v1（taproot とも呼ばれる）の「1」のエンコードで、bech32m が使用され始めたバージョンです。segwit には 17 のバージョンがあり、Bitcoin では bech32m データ部分の最初のバイトが 0 から 16（含む）までの数字にデコードされることが求められます。

Witness プログラム::
  2 から 40 バイトです。segwit v0 では、この witness プログラムは 20 または 32 バイトでなければなりません。他の長さは無効です。segwit v1 では、執筆時点で定義されている唯一の長さは 32 バイトですが、他の長さが後で定義される可能性があります。

チェックサム::
  正確に 6 文字です。これは BCH コードを使用して作成されるエラー訂正コードの一種です（ただし、Bitcoin アドレスの場合、後で見るように、エラー訂正ではなくエラー検出のみにチェックサムを使用することが重要です）。
//TODO

これらのルールを、bech32 および bech32m アドレスを作成する例を通じて説明しましょう。以下のすべての例では、https://oreil.ly/gpTT6[Python 用の bech32m リファレンスコード]を使用します。

まず、公開時に使用されている異なる segwit 出力のそれぞれに対して、将来の segwit バージョンのための出力スクリプトを一つ生成します。このスクリプトは <<scripts_for_diff_segwit_outputs>> に記載されています。

++++
<table id="scripts_for_diff_segwit_outputs">
<caption>Scripts for different types of segwit outputs</caption>
<thead>
<tr>
<th>Output type</th>
<th>Example script</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>P2WPKH</p></td>
<td><p><code>OP_0 2b626ed108ad00a944bb2922a309844611d25468</code></p></td>
</tr>
<tr>
<td><p>P2WSH</p></td>
<td><p><code>OP_0 648a32e50b6fb7c5233b228f60a6a2ca4158400268844c4bc295ed5e8c3d626f</code></p></td>
</tr>
<tr>
<td><p>P2TR</p></td>
<td><p><code>OP_1 2ceefa5fa770ff24f87c5475d76eab519eda6176b11dbe1618fcf755bfac5311</code></p></td>
</tr>
<tr>
<td><p>Future Example</p></td>
<td><p><code>OP_16 0000</code></p></td>
</tr>
</tbody>
</table>
++++

P2WPKH 出力の場合、ウィットネスプログラムには、<<addresses_for_p2pkh>> で見た P2PKH 出力のコミットメントとまったく同じ方法で構築されたコミットメントが含まれます。公開鍵が SHA256 ハッシュ関数に渡されます。その結果得られる 32 バイトのダイジェストが RIPEMD-160 ハッシュ関数に渡されます。その関数のダイジェスト（コミットメント）がウィットネスプログラムに配置されます。

Pay to Witness Script Hash (P2WSH) 出力の場合、P2SH アルゴリズムは使用しません。代わりにスクリプトを SHA256 ハッシュ関数に渡し、その関数の 32 バイトのダイジェストをウィットネスプログラムで使用します。P2SH では、SHA256 ダイジェストが RIPEMD-160 で再度ハッシュされましたが、場合によってはそれが安全でないことがあります。詳細は <<p2sh_collision_attacks>> を参照してください。RIPEMD-160 を使用しない SHA256 の結果として、P2WSH コミットメントは 32 バイト (256 ビット) であり、20 バイト (160 ビット) ではありません。

Pay-to-Taproot (P2TR) 出力の場合、ウィットネスプログラムは secp256k1 曲線上の点です。それは単純な公開鍵であるかもしれませんが、ほとんどの場合、追加のデータにコミットする公開鍵であるべきです。そのコミットメントについては <<taproot>> で詳しく学びます。

++++
<p class="fix_tracking2">
将来の segwit バージョンの例として、単純に可能な限り高い segwit バージョン番号 (16) と、ヌル値を持つ最小許可サイズのウィットネスプログラム (2 バイト) を使用します。</p>
++++

バージョン番号とウィットネスプログラムがわかったので、それぞれを bech32 アドレスに変換できます。Python 用の bech32m リファレンスライブラリを使ってこれらのアドレスを素早く生成し、何が起こっているのかを詳しく見てみましょう：

----
$ github="https://raw.githubusercontent.com"
$ wget $github/sipa/bech32/master/ref/python/segwit_addr.py

$ python
>>> from segwit_addr import *
>>> from binascii import unhexlify

>>> help(encode)
encode(hrp, witver, witprog)
    Encode a segwit address.

>>> encode('bc', 0, unhexlify('2b626ed108ad00a944bb2922a309844611d25468'))
'bc1q9d3xa5gg45q2j39m9y32xzvygcgay4rgc6aaee'
>>> encode('bc', 0,
unhexlify('648a32e50b6fb7c5233b228f60a6a2ca4158400268844c4bc295ed5e8c3d626f'))
'bc1qvj9r9egtd7mu2gemy28kpf4zefq4ssqzdzzycj7zjhk4arpavfhsct5a3p'
>>> encode('bc', 1, 
unhexlify('2ceefa5fa770ff24f87c5475d76eab519eda6176b11dbe1618fcf755bfac5311'))
'bc1p9nh05ha8wrljf7ru236awm4t2x0d5ctkkywmu9sclnm4t0av2vgs4k3au7'
>>> encode('bc', 16, unhexlify('0000'))
'bc1sqqqqkfw08p'
----

__segwit_addr.py__ ファイルを開いてコードが何をしているかを見てみると、最初に気づくのは bech32 (segwit v0 用) と bech32m (後の segwit バージョン用) の唯一の違いが定数であることです：

----
BECH32_CONSTANT = 1
BECH32M_CONSTANT = 0x2bc830a3
----

次に、チェックサムを生成するコードに気づきます。チェックサムの最終ステップでは、適切な定数が xor 演算を使用して値に統合されます。その単一の値が bech32 と bech32m の唯一の違いです。

チェックサムが作成されると、データ部分の各 5 ビット文字 (ウィットネスバージョン、ウィットネスプログラム、チェックサムを含む) が英数字に変換されます。

出力スクリプトにデコードするには、逆の手順を行います。まず、リファレンスライブラリを使って、2 つのアドレスをデコードしてみましょう。

----
>>> help(decode)
decode(hrp, addr)
    Segwitアドレスをデコードします。

>>> _ = decode("bc", "bc1q9d3xa5gg45q2j39m9y32xzvygcgay4rgc6aaee")
>>>  _[0], bytes(_[1]).hex()
(0, '2b626ed108ad00a944bb2922a309844611d25468')
>>> _ = decode("bc",
        "bc1p9nh05ha8wrljf7ru236awm4t2x0d5ctkkywmu9sclnm4t0av2vgs4k3au7")
>>> _[0], bytes(_[1]).hex()
(1, '2ceefa5fa770ff24f87c5475d76eab519eda6176b11dbe1618fcf755bfac5311')
----

私たちは、witnessバージョンとwitnessプログラムの両方を取得します。これらは、出力スクリプトのテンプレートに挿入できます。

----
<version> <program>
----

例えば：

----
OP_0 2b626ed108ad00a944bb2922a309844611d25468
OP_1 2ceefa5fa770ff24f87c5475d76eab519eda6176b11dbe1618fcf755bfac5311
----

[WARNING]
====
ここで注意すべき可能性のある間違いの一つは、witnessバージョンが `0` の場合は `OP_0` で、これはバイト 0x00 を使用しますが、witnessバージョンが `1` の場合は `OP_1` を使用し、これはバイト 0x51 です。witnessバージョン `2` から `16` までは、それぞれ 0x52 から 0x60 を使用します。
====

bech32mのエンコードまたはデコードを実装する際には、BIP350で提供されているテストベクトルを使用することを強くお勧めします。また、まだ定義されていない将来のsegwitバージョンに関連するテストベクトルに合格することを確認してください。これにより、新しいBitcoin機能が利用可能になったときにすぐにサポートを追加できなくても、ソフトウェアが長年にわたって使用可能になります。

[[priv_formats]]
==== 秘密鍵フォーマット

秘密鍵は、同じ256ビットの数値に対応するさまざまなフォーマットで表現できます。<<table_4-2>> は、秘密鍵を表現するために使用される一般的なフォーマットをいくつか示しています。異なるフォーマットは、異なる状況で使用されます。16進数および生のバイナリフォーマットは、ソフトウェア内部で使用され、ユーザに表示されることはほとんどありません。WIFは、ウォレット間での鍵のインポート/エクスポートに使用され、秘密鍵のQRコード（バーコード）表現によく使用されます。

.Modern Relevancy of Private Key Formats
****
初期の Bitcoin ウォレットソフトウェアは、新しいユーザウォレットが初期化されると、1つまたは複数の独立した秘密鍵を生成しました。初期の鍵セットがすべて使用された場合、ウォレットは追加の秘密鍵を生成することがありました。個々の秘密鍵はエクスポートまたはインポートすることができました。新しい秘密鍵が生成またはインポートされるたびに、ウォレットの新しいバックアップを作成する必要がありました。

後の Bitcoin ウォレットは、すべての秘密鍵が単一のシード値から生成される決定論的ウォレットを使用し始めました。これらのウォレットは、通常のオンチェーン使用の場合、一度だけバックアップを取れば済みます。しかし、ユーザがこれらのウォレットから単一の秘密鍵をエクスポートし、攻撃者がその鍵とウォレットに関する非秘密データを取得した場合、攻撃者はウォレット内の任意の秘密鍵を導出できる可能性があり、ウォレットの資金をすべて盗むことができます。さらに、決定論的ウォレットには鍵をインポートすることができません。つまり、ほとんどの現代のウォレットは個々の鍵をエクスポートまたはインポートする機能をサポートしていません。このセクションの情報は、初期の Bitcoin ウォレットとの互換性が必要な人にとって主に興味深いものです。

詳細は <<hd_wallets>> を参照してください。

****

++++
<table id="table_4-2">
<caption>Private key representations (encoding formats)</caption>
<thead>
<tr>
<th>Type</th>
<th>Prefix</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Hex</p></td>
<td><p>None</p></td>
<td><p>64 hexadecimal digits</p></td>
</tr>
<tr>
<td><p>WIF</p></td>
<td><p>5</p></td>
<td><p>Base58check encoding: base58 with version prefix of 128 and 32-bit checksum</p></td>
</tr>
<tr>
<td><p>WIF-compressed</p></td>
<td><p>K or L</p></td>
<td><p>As above, with added suffix 0x01 before encoding</p></td>
</tr>
</tbody>
</table>
++++

<<table_4-3>> は、異なる形式で生成された秘密鍵を示しています。

++++
<table id="table_4-3">
<caption>Example: Same key, different formats</caption>
<thead>
<tr>
<th>Format</th>
<th>Private key</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Hex</p></td>
<td><p>1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd</p></td>
</tr>
<tr>
<td><p>WIF</p></td>
<td><p>5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</p></td>
</tr>
<tr>
<td><p>WIF-compressed</p></td>
<td><p>KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</p></td>
</tr>
</tbody>
</table>
++++

これらの表現はすべて同じ数値、同じ秘密鍵を示す異なる方法です。見た目は異なりますが、どの形式も簡単に他の形式に変換できます((("private keys", "formats", startref="private-key-format")))。

[[comp_priv]]
==== 圧縮された秘密鍵

一般的に使われる「圧縮された秘密鍵」という用語は誤解を招きます((("private keys", "compressed", id="private-key-compress")))((("compressed private keys", id="compress-private-key")))。なぜなら、秘密鍵が WIF 圧縮形式でエクスポートされると、実際には「非圧縮」秘密鍵よりも 1 バイト _長く_ なります。これは、秘密鍵に 1 バイトのサフィックス（<<table_4-4>> で 01 として示されている）が追加されているためで、このサフィックスは秘密鍵が新しいウォレットからのものであり、圧縮された公開鍵を生成するためにのみ使用されるべきことを示しています。秘密鍵自体は圧縮されず、圧縮することもできません。「圧縮された秘密鍵」という用語は実際には「圧縮された公開鍵のみを生成するための秘密鍵」を意味し、「非圧縮の秘密鍵」は「非圧縮の公開鍵のみを生成するための秘密鍵」を意味します。さらなる混乱を避けるために、エクスポート形式を「WIF 圧縮」または「WIF」と呼び、秘密鍵自体を「圧縮された」と呼ばないようにしてください。

<<table_4-4>> は、同じ鍵を WIF および WIF 圧縮形式でエンコードしたものを示しています。

++++
<table id="table_4-4">
<caption>例：同じ鍵、異なる形式</caption>
<thead>
<tr>
<th>形式</th>
<th>秘密鍵</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Hex</p></td>
<td><p>1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</p></td>
</tr>
<tr>
<td><p>WIF</p></td>
<td><p>5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</p></td>
</tr>
<tr>
<td><p>Hex 圧縮</p></td>
<td><p>1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD01</p></td>
</tr>
<tr>
<td><p>WIF 圧縮</p></td>
<td><p>KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</p></td>
</tr>
</tbody>
</table>
++++

Hex 圧縮秘密鍵形式には末尾に 1 バイト（Hex で 01）が追加されていることに注意してください。WIF および WIF 圧縮形式の base58 エンコードバージョンのプレフィックスは同じ（0x80）ですが、数値の末尾に 1 バイトが追加されると、base58 エンコードの最初の文字が 5 から _K_ または _L_ に変わります。これは、数値 100 と数値 99 の 10 進エンコードの違いに相当します。100 は 99 よりも 1 桁長いだけでなく、プレフィックスが 9 ではなく 1 になります。長さが変わると、プレフィックスにも影響します。base58 では、数値の長さが 1 バイト増えると、プレフィックス 5 が _K_ または _L_ に変わります。

これらの形式は互換的に使用されるわけではありません。圧縮公開鍵を実装している新しいウォレットでは、秘密鍵は常に WIF 圧縮形式（_K_ または _L_ プレフィックス付き）でのみエクスポートされます。ウォレットが古い実装で圧縮公開鍵を使用していない場合、秘密鍵は常に WIF（5 プレフィックス付き）でのみエクスポートされます。ここでの目的は、これらの秘密鍵をインポートするウォレットに対して、ブロックチェーン上で圧縮または非圧縮の公開鍵とアドレスを検索する必要があるかどうかを示すことです。

Bitcoin ウォレットが圧縮公開鍵を実装できる場合、すべてのトランザクションでそれらを使用します。ウォレット内の秘密鍵は、曲線上の公開鍵ポイントを導出するために使用され、これが圧縮されます。圧縮公開鍵は Bitcoin アドレスを生成するために使用され、それがトランザクションで使用されます。圧縮公開鍵を実装している新しいウォレットから秘密鍵をエクスポートする際、WIF は修正され、秘密鍵に 1 バイトのサフィックス +01+ が追加されます。結果として得られる base58check エンコードされた秘密鍵は「圧縮 WIF」と呼ばれ、古いウォレットからの WIF エンコード（非圧縮）キーの場合のように「5」ではなく、文字 _K_ または _L_ で始まります。

=== 高度な鍵とアドレス

以下のセクションでは、バニティアドレスやペーパーウォレットなどの高度な形式の鍵とアドレスについて見ていきます。

==== バニティアドレス

バニティアドレスは、人間が読めるメッセージを含む有効な Bitcoin アドレスです。たとえば、+1LoveBPzzD72PUXLzCkYAtGFYmK5vYNR33+ は、最初の 4 文字が「Love」という単語を形成する有効なアドレスです。バニティアドレスを生成するには、望ましいパターンを持つ Bitcoin アドレスが見つかるまで、何十億もの候補となる秘密鍵を生成してテストする必要があります。バニティ生成アルゴリズムにはいくつかの最適化がありますが、プロセスは基本的にランダムに秘密鍵を選び、公開鍵を導出し、Bitcoin アドレスを導出し、それが望ましいバニティパターンと一致するかどうかを確認し、一致が見つかるまで何十億回も繰り返すことを含みます。

一度、希望するパターンに一致するバニティアドレスが見つかると、そのアドレスから導出された秘密鍵を所有者が使用して、他のアドレスとまったく同じ方法でビットコインを使うことができます。バニティアドレスは他のアドレスと比べて安全性が高いわけでも低いわけでもありません。これらは他のアドレスと同様に、楕円曲線暗号 (ECC) とセキュアハッシュアルゴリズム (SHA) に依存しています。バニティパターンで始まるアドレスの秘密鍵を見つけるのが、他のアドレスの秘密鍵を見つけるよりも簡単ということはありません。

ユージニアはフィリピンで活動する子供向けの慈善団体のディレクターです。ユージニアが募金活動を組織しており、その募金活動を宣伝するためにバニティビットコインアドレスを使用したいと考えているとしましょう。ユージニアは「1Kids」で始まるバニティアドレスを作成して、子供向けの慈善募金活動を促進します。このバニティアドレスがどのように作成されるのか、そしてユージニアの慈善活動の安全性にとって何を意味するのかを見てみましょう。

===== バニティアドレスの生成

ビットコインアドレスは、base58 アルファベットで表現された単なる数字であることを理解することが重要です。「1Kids」のようなパターンを探すことは、+1Kids11111111111111111111111111111+ から +1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz+ の範囲内のアドレスを探すことと見なすことができます。この範囲には約 58^29^ (約 1.4 × 10^51^) のアドレスがあり、すべて「1Kids」で始まります。<<table_4-11>> は、1Kids というプレフィックスを持つアドレスの範囲を示しています。

++++
<table id="table_4-11">
<caption>“1Kids”で始まるバニティアドレスの範囲</caption>
<tbody>
<tr>
<td><p><strong>From</strong></p></td>
<td><p><code>1Kids11111111111111111111111111111</code></p></td>
</tr>
<tr>
<td/>
<td><p><code>1Kids11111111111111111111111111112</code></p></td>
</tr>
<tr>
<td/>
<td><p><code>1Kids11111111111111111111111111113</code></p></td>
</tr>
<tr>
<td/>
<td><p><code>…​</code></p></td>
</tr>
<tr>
<td><p><strong>To</strong></p></td>
<td><p><code>1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz</code></p></td>
</tr>
</tbody>
</table>
++++

「1Kids」というパターンを数字として見て、ビットコインアドレスでこのパターンがどのくらいの頻度で見つかるかを見てみましょう (<<table_4-12>> を参照)。特別なハードウェアを持たない一般的なデスクトップコンピュータ PC は、1 秒間に約 100,000 の鍵を検索できます。

++++
<table id="table_4-12">
<caption>バニティパターン (1KidsCharity) の頻度とデスクトップ PC での平均検索時間</caption>
<thead>
<tr>
<th>長さ</th>
<th>パターン</th>
<th>頻度</th>
<th>平均検索時間</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>1</p></td>
<td><p>1K</p></td>
<td><p>58 鍵に 1 つ</p></td>
<td><p>&lt; 1 ミリ秒</p></td>
</tr>
<tr>
<td><p>2</p></td>
<td><p>1Ki</p></td>
<td><p>3,364 鍵に 1 つ</p></td>
<td><p>50 ミリ秒</p></td>
</tr>
<tr>
<td><p>3</p></td>
<td><p>1Kid</p></td>
<td><p>195,000 鍵に 1 つ</p></td>
<td><p>&lt; 2 秒</p></td>
</tr>
<tr>
<td><p>4</p></td>
<td><p>1Kids</p></td>
<td><p>1,100 万鍵に 1 つ</p></td>
<td><p>1 分</p></td>
</tr>
<tr>
<td><p>5</p></td>
<td><p>1KidsC</p></td>
<td><p>6 億 5,600 万鍵に 1 つ</p></td>
<td><p>1 時間</p></td>
</tr>
<tr>
<td><p>6</p></td>
<td><p>1KidsCh</p></td>
<td><p>380 億鍵に 1 つ</p></td>
<td><p>2 日</p></td>
</tr>
<tr>
<td><p>7</p></td>
<td><p>1KidsCha</p></td>
<td><p>2.2 兆鍵に 1 つ</p></td>
<td><p>3–4 ヶ月</p></td>
</tr>
<tr>
<td><p>8</p></td>
<td><p>1KidsChar</p></td>
<td><p>128 兆鍵に 1 つ</p></td>
<td><p>13–18 年</p></td>
</tr>
<tr>
<td><p>9</p></td>
<td><p>1KidsChari</p></td>
<td><p>7 千兆鍵に 1 つ</p></td>
<td><p>800 年</p></td>
</tr>
<tr>
<td><p>10</p></td>
<td><p>1KidsCharit</p></td>
<td><p>400 千兆鍵に 1 つ</p></td>
<td><p>46,000 年</p></td>
</tr>
<tr>
<td><p>11</p></td>
<td><p>1KidsCharity</p></td>
<td><p>23 百京鍵に 1 つ</p></td>
<td><p>250 万年</p></td>
</tr>
</tbody>
</table>
++++

ご覧のとおり、エウジェニアが「1KidsCharity」というバニティアドレスをすぐに作成することはありません。たとえ数千台のコンピュータにアクセスできたとしてもです。各追加文字は難易度を 58 倍に増加させます。7 文字以上のパターンは通常、複数のグラフィックス処理ユニット (GPU) を搭載したカスタムビルドのデスクトップなど、専門のハードウェアによって見つかります。GPU システムでのバニティ検索は、汎用 CPU での検索よりも何桁も速いです。

別の方法として、バニティアドレスを見つけるためにバニティマイナーのプールに作業をアウトソースすることができます。https://oreil.ly/99K81[バニティプール]は、高速なハードウェアを持つ人々が他人のためにバニティアドレスを検索してビットコインを稼ぐことができるサービスです。エウジェニアは料金を支払うことで、7 文字のパターンのバニティアドレスの検索をアウトソースし、数ヶ月間 CPU 検索を実行する代わりに数時間で結果を得ることができます。

バニティアドレスの生成はブルートフォースの作業です。ランダムなキーを試し、結果として得られるアドレスが希望するパターンに一致するか確認し、成功するまで繰り返します。

===== バニティアドレスのセキュリティとプライバシー

バニティアドレス（「プライバシー」「バニティアドレス」）は、ビットコインの初期の頃に人気がありましたが、2023年にはほとんど使用されなくなりました。この傾向には二つの主な原因が考えられます。

決定性ウォレット：<<recovery_code_intro>> で見たように、ほとんどの現代のウォレットでは、いくつかの単語や文字を書き留めるだけで、すべてのキーをバックアップすることが可能です。これは、決定性アルゴリズムを使用して、ウォレット内のすべてのキーをこれらの単語や文字から導出することで実現されます。ユーザが作成するすべてのバニティアドレスに対して追加のデータをバックアップしない限り、決定性ウォレットでバニティアドレスを使用することはできません。より実用的には、決定性キー生成を使用するほとんどのウォレットは、バニティジェネレータからの秘密鍵やキーの調整をインポートすることを許可していません。

アドレスの再利用を避ける：バニティアドレスを使用して同じアドレスに複数の支払いを受け取ると、それらすべての支払いの間にリンクが作成されます。これは、ユージニアの非営利団体が収入と支出を税務当局に報告する必要がある場合には許容されるかもしれません。しかし、ユージニアに支払う人や彼女から支払いを受ける人のプライバシーを低下させることにもなります。例えば、アリスは匿名で寄付したいかもしれませんし、ボブは他の顧客にユージニアに割引価格を提供していることを知られたくないかもしれません。

// https://github.com/MakisChristou/vanitybech

上記の問題が解決されない限り、将来的に多くのバニティアドレスが見られることはないでしょう（「アドレス」「バニティ」）（「バニティアドレス」）（「公開鍵暗号」「バニティアドレス」）。

[[paper_wallets]]
==== ペーパーウォレット

ペーパーウォレット（「公開鍵暗号」「ペーパーウォレット」）（「ペーパーウォレット」）（「ウォレット」「ペーパー」）は、紙に印刷された秘密鍵です。しばしばペーパーウォレットには、利便性のために対応するビットコインアドレスも含まれますが、これは必須ではありません。なぜなら、秘密鍵から導出することができるからです。

[WARNING]
====
ペーパーウォレットは時代遅れの技術であり、ほとんどのユーザにとって危険です。生成する際には多くの微妙な落とし穴があり、その中でも特に生成コードが「バックドア」で妥協されている可能性があります。この方法で多くのビットコインが盗まれています。ペーパーウォレットは情報提供のみを目的としてここに示されていますが、ビットコインの保管には使用しないでください。リカバリーコードを使用してキーをバックアップし、可能であればハードウェア署名デバイスを使用してキーを保管し、トランザクションに署名してください。ペーパー [.keep-together]#ウォレットを使用しないでください。#
====

ペーパーウォレットには多くのデザインとサイズがあり、さまざまな機能があります。<<paper_wallet_simple>> はサンプルのペーパーウォレットを示しています。

[[paper_wallet_simple]]
.シンプルなペーパーウォレットの例。
image::images/mbc3_0410.png[]

一部は贈り物として渡すことを意図しており、クリスマスや新年などの季節のテーマがあります。他のものは銀行の金庫やセーフに保管することを目的としており、プライベートキーが不透明なスクラッチオフステッカーで隠されているか、折りたたまれて改ざん防止の接着箔で封印されています。その他のデザインでは、チケットの半券のように取り外し可能な形でキーとアドレスの追加コピーを備えており、火災、洪水、その他の自然災害に対して複数のコピーを保管することができます。

ビットコインの元々の公開鍵に焦点を当てたデザインから、bech32m や pay to taproot のような現代のアドレスやスクリプト、さらには将来のビットコインのアップグレード用のアドレスまで、ビットコインプロトコルが支払者に支払いを受け取るべきウォレットを識別させる方法を学びました。しかし、実際にあなたのウォレットが支払いを受け取るときには、ウォレットデータに何かが起こったとしてもそのお金にアクセスできるという保証が欲しいでしょう。次の章では、ビットコインウォレットがさまざまな脅威から資金を保護するように設計されている方法を見ていきます。

It seems like you haven't provided the Markdown content yet. Please paste the text you would like me to translate, and I'll get started on it.
