[[tx_fees]]
== Transaction Fees

++++
<p class="fix_tracking">
<a data-type="xref" href="#c_signatures">#c_signatures</a> でアリスが作成したデジタル署名は、彼女が自分の秘密鍵を知っていて、ボブに支払う取引にコミットしたことを証明するだけです。彼女は、同じ出力 (ビットコイン) を使ってボブに支払う代わりにキャロルに支払う取引にコミットする別の署名を作成することができます。これら二つの取引は、特定の出力を消費する取引は一つしか有効なブロックチェーンに含めることができないため、<em>競合する取引</em> となります。フルノードがどの鍵がどのビットコインを制御しているかを判断するために使用するブロックチェーンは、最も多くのプルーフ・オブ・ワークを持つブロックチェーンです。
</p>
++++

競合する取引から自分を守るために、ボブはアリスからの取引が十分な深さでブロックチェーンに含まれるまで待ってから、受け取ったお金を自分のものとして使うのが賢明です (<<confirmations>> を参照)。アリスの取引がブロックチェーンに含まれるためには、取引の _ブロック_ に含まれる必要があります。一定の時間内に生成されるブロックの数は限られており、各ブロックには限られたスペースしかありません。そのブロックを作成するマイナーだけが、どの取引を含めるかを選択できます。マイナーは、どの取引を含めるかを選ぶ基準を自由に設定でき、取引を一切含めないこともできます。

++++
<div data-type="note">
<p class="fix_tracking"> この章で「取引」と言うときは、ブロック内の最初の取引を除くすべての取引を指します。ブロック内の最初の取引は <em>コインベース取引</em> であり、<a data-type="xref" href="#coinbase_transactions">#coinbase_transactions</a> で説明されているように、ブロックを生成したマイナーが報酬を受け取るためのものです。他の取引とは異なり、コインベース取引は前の取引の出力を消費せず、他の取引に適用されるいくつかのルールの例外でもあります。コインベース取引は取引手数料を支払わず、手数料の引き上げも必要なく、取引のピン止めの対象にもならず、手数料に関する以下の議論にはほとんど関係がないため、この章では無視します。
</p>
</div>
++++

ほとんどすべてのマイナーが、どのトランザクションをブロックに含めるかを選択する基準は、収益を最大化することです。ビットコインは、トランザクションがそのトランザクションをブロックに含めるマイナーにお金を渡すことができるメカニズムを提供することで、これに対応するように特別に設計されています。このメカニズムを「トランザクション手数料」と呼びますが、通常の意味での手数料ではありません。プロトコルや特定のマイナーによって設定された金額ではなく、オークションでの入札に非常に似ています。購入される商品は、トランザクションが消費するブロック内の限られたスペースの一部です。マイナーは、入札によって最大の収益を得られるトランザクションのセットを選びます。

この章では、これらの入札、つまりトランザクション手数料のさまざまな側面と、それがビットコインのトランザクションの作成と管理にどのように影響するかを探ります。

### 誰がトランザクション手数料を支払うのか？

ほとんどの支払いシステムには、何らかの形で取引のための手数料が含まれていますが、この手数料は通常の買い手には隠されています。たとえば、商人は、現金またはクレジットカードで支払うかにかかわらず、同じ商品を同じ価格で広告するかもしれませんが、彼らの支払い処理業者はクレジット取引に対して銀行が現金預金に対して請求するよりも高い手数料を請求するかもしれません。

ビットコインでは、ビットコインの支出はすべて認証されなければならず（通常は署名で）、支出者の許可なしにトランザクションが手数料を支払うことはできません。トランザクションの受取人が別のトランザクションで手数料を支払うことは可能です（後でその使用例を見ます）が、単一のトランザクションで自分の手数料を支払いたい場合、その手数料は支出者によって合意されたものである必要があります。それは隠すことができません。

ビットコインのトランザクションは、支出者が支払う手数料をコミットするためにトランザクション内で追加のスペースを必要としないように設計されています。つまり、別のトランザクションで手数料を支払うことは可能ですが、単一のトランザクションで手数料を支払うことが最も効率的で（したがって最も安価です）。

ビットコインにおいて、手数料は入札であり、支払われる金額は取引が確認されるまでの時間を決定する要因となります。支払者と受取者の両方が通常、取引が迅速に確認されることを望むため、通常は支払者だけが手数料を選択できることが問題になることがあります。この問題の解決策については <<cpfp>> で見ていきます。しかし、多くの一般的な支払いフローでは、取引が迅速に確認されることを最も望む当事者、つまりより高い手数料を支払う意欲が最も高い当事者は支払者です。

これらの技術的および実用的な理由から、ビットコインでは支払者が取引手数料を支払うのが慣例となっています。例外として、未確認の取引を受け入れる商人や、署名後にすぐに取引をブロードキャストしないプロトコル（これにより、支払者が現在の市場に適した手数料を選択できなくなる）があります。これらの例外については後で詳しく見ていきます。

=== 手数料と手数料率

各取引は単一の手数料しか支払いません。取引の大きさは関係ありません。しかし、取引が大きくなるほど、マイナーがブロックに収められる取引の数は減少します。そのため、マイナーは市場で同等の商品を比較するのと同じ方法で取引を評価します。つまり、価格を数量で割ります。

あなたが複数の異なる米袋のコストをそれぞれの重さで割って、重さあたりの最安値（最良の取引）を見つけるように、マイナーは取引の手数料をそのサイズ（重さとも呼ばれる）で割って、重さあたりの最高手数料（最も収益が高い）を見つけます。ビットコインでは、取引のサイズを重さで割ったものを _手数料率_ と呼びます。ビットコインの変遷により、手数料率は異なる単位で表現されることがあります：

- BTC/Bytes（現在ではほとんど使われないレガシー単位）
- BTC/Kilobytes（現在ではほとんど使われないレガシー単位）
- BTC/Vbytes（ほとんど使われない）
- BTC/Kilo-vbyte（主にビットコインコアで使用）
- Satoshi/Vbyte（今日最も一般的に使用される）
- Satoshi/Weight（これも一般的に使用される）

手数料率を表示する際には、sat/vbyte または sat/weight 単位を使用することをお勧めします。

[WARNING]
====
手数料率の入力を受け付ける際には注意が必要です。ユーザがある単位で表示された手数料率を異なる単位のフィールドにコピー＆ペーストすると、手数料を 1,000 倍も多く支払ってしまう可能性があります。逆に分子を切り替えると、理論上は 100,000,000 倍も多く支払ってしまう可能性があります。ウォレットはユーザが過剰な手数料率を支払うのを難しくし、ウォレット自身が信頼できるデータソースを使用して生成したものでない手数料率については、ユーザに確認を促すことを検討するべきです。

過剰な手数料、または *absurd fee* とも呼ばれるものは、現在の手数料率推定器が次のブロックでトランザクションを確認するために必要だと予想する額を大幅に上回る手数料率です。ウォレットはユーザが過剰な手数料率を選ぶことを完全に防ぐべきではありませんが、偶然にそのような手数料率を使用するのを難しくするべきです。ユーザが稀に手数料を多く支払う正当な理由がある場合もあります。
====

### 適切な手数料率の推定

トランザクションの確認を待つ時間を長くすることで、より低い手数料率を支払うことができると確立されています。ただし、手数料率が低すぎるとトランザクションが確認されない可能性があります。手数料率はブロック空間のオープンオークションでの入札であるため、特定の時間までにトランザクションを確認するために必要な手数料率を完全に予測することはできません。しかし、最近の他のトランザクションが支払った手数料率に基づいて大まかな推定を生成することができます。

フルノードは、受信した各トランザクションについて次の 3 つの情報を記録できます：そのトランザクションを最初に受信した時間（ブロック高）、そのトランザクションが確認されたブロック高、およびそのトランザクションが支払った手数料率です。似たような高さで到着し、似たような高さで確認され、似たような手数料を支払ったトランザクションをグループ化することで、特定の手数料率を支払ったトランザクションが確認されるまでにかかるブロック数を計算できます。そして、現在同様の手数料率を支払うトランザクションが同様のブロック数で確認されると仮定できます。Bitcoin Core にはこれらの原則を使用する手数料率推定器が含まれており、`estimatesmartfee` RPC を使用して、トランザクションが高い確率で確認されるまでに待つブロック数を指定するパラメータと共に呼び出すことができます（例えば、144 ブロックは約 1 日です）：

----
$ bitcoin-cli -named estimatesmartfee conf_target=144
{
  "feerate": 0.00006570,
  "blocks": 144
}
----

多くのウェブベースのサービスも API として手数料の見積もりを提供しています。最新のリストについては、https://oreil.ly/TB6IN を参照してください。

前述のとおり、手数料率の見積もりは完璧にはなりません。一般的な問題として、基本的な需要が変化し、均衡が調整され、価格（手数料）が新たな高値に上昇したり、最低値に向かって減少したりすることがあります。
手数料率が下がると、以前は通常の手数料率を支払っていた取引が、今では高い手数料率を支払っていることになり、予想よりも早く確認されることになります。すでに送信した取引の手数料率を下げる方法はないので、高い手数料率を支払うことになります。しかし、手数料率が上がると、これらの取引の手数料率を上げる方法が必要になります。これを _fee bumping_ と呼びます。ビットコインでは、replace by fee (RBF) と child pays for parent (CPFP) の 2 種類の fee bumping が一般的に使用されています。

[[rbf]]
=== Replace By Fee (RBF) Fee Bumping

RBF fee bumping を使用して取引の手数料を増やすには、より高い手数料を支払う競合するバージョンの取引を作成します。2 つ以上の取引は、1 つの有効なブロックチェーンに含めることができない場合、_競合する取引_ と見なされ、マイナーはそのうちの 1 つだけを選択する必要があります。競合は、2 つ以上の取引が同じ UTXO の 1 つを消費しようとする場合、つまり、それぞれが同じアウトポイント（以前の取引の出力への参照）を含む入力を含む場合に発生します。

無制限の数の競合する取引を作成し、それらをリレーするフルノードのネットワークを通じて送信することで、大量の帯域幅を消費することを防ぐために、Bitcoin Core および取引の置換をサポートする他のフルノードは、各置換取引が置換される取引よりも高い手数料率を支払うことを要求します。Bitcoin Core は現在、置換取引が元の取引よりも高い総手数料を支払うことも要求していますが、この要件には望ましくない副作用があり、執筆時点では開発者がこれを削除する方法を模索しています。

Bitcoin Core (「Bitcoin Core」「RBF variants」 id="bitcoin-core-rbf") は現在、RBF の 2 つのバリエーションをサポートしています。

Opt-in RBF::
  未確認のトランザクションは、トランザクションの作成者がより高い手数料率のバージョンに置き換えることを許可したいことをマイナーやフルノードに示すことができます。このシグナルとその使用ルールは BIP125 に指定されています。この記事の執筆時点では、これは数年前から Bitcoin Core でデフォルトで有効になっています。

Full RBF::
  どの未確認トランザクションも、より高い手数料率のバージョンに置き換えることができます。この記事の執筆時点では、これは Bitcoin Core でオプションで有効にできます（ただし、デフォルトでは無効です）。

.なぜ RBF のバリエーションが 2 つあるのですか？
****
RBF の 2 つの異なるバージョンがある理由は、Full RBF が議論を呼んでいるからです。初期の Bitcoin バージョンではトランザクションの置き換えが許可されていましたが、この動作は数回のリリースで無効化されました。その間、現在 Bitcoin Core と呼ばれるソフトウェアを使用しているマイナーやフルノードは、受け取った未確認トランザクションの最初のバージョンを他のバージョンに置き換えることはありませんでした。一部の商人はこの動作を期待するようになりました。彼らは、適切な手数料率を支払った有効な未確認トランザクションは最終的に確認されると仮定し、そのような未確認トランザクションを受け取った直後に商品やサービスを提供しました。

しかし、Bitcoin プロトコルには、未確認トランザクションが最終的に確認されることを保証する方法はありません。この章の前述のように、すべてのマイナーは、どのトランザクションを確認しようとするか、またそれらのトランザクションのどのバージョンを選ぶかを自分で決めることができます。Bitcoin Core はオープンソースソフトウェアであるため、そのソースコードのコピーを持っている人は誰でもトランザクションの置き換えを追加（または削除）できます。たとえ Bitcoin Core がオープンソースでなかったとしても、Bitcoin はオープンプロトコルであり、十分に有能なプログラマーがゼロから再実装することができ、再実装者はトランザクションの置き換えを含めるか含めないかを選ぶことができます。

トランザクションの置き換えは、一部の商人がすべての合理的な未確認トランザクションが最終的に確認されるという仮定を破ります。トランザクションの代替バージョンは、元のバージョンと同じ出力に支払うことができますが、それらの出力のいずれにも支払う必要はありません。未確認トランザクションの最初のバージョンが商人に支払う場合、2 番目のバージョンは支払わないかもしれません。商人が最初のバージョンに基づいて商品やサービスを提供したが、2 番目のバージョンが確認された場合、商人はそのコストに対する支払いを受け取ることができません。

一部の商人やそれをサポートする人々は、Bitcoin Core でトランザクションの置換が再度有効化されないように求めました。他の人々は、トランザクションの置換には、最初に支払った手数料率が低すぎた場合に手数料を引き上げる能力を含む利点があると指摘しました。

最終的に、Bitcoin Core に取り組む開発者たちは妥協案を実装しました。すべての未確認トランザクションを置換可能にするのではなく (完全な RBF)、置換を許可したいとシグナルを送ったトランザクションのみを置換可能にするように Bitcoin Core をプログラムしました (オプトイン RBF)。商人は受け取ったトランザクションにオプトインシグナルがあるかどうかを確認し、そのシグナルがあるトランザクションをないものとは異なる扱いにすることができます。

これは根本的な懸念を変えるものではありません。誰でも Bitcoin Core のコピーを変更したり、再実装を作成して完全な RBF を許可することができます。そして、実際に一部の開発者はこれを行いましたが、彼らのソフトウェアを使用した人は少ないようです。

数年後、Bitcoin Core に取り組む開発者たちは妥協案を少し変更しました。デフォルトでオプトイン RBF を維持することに加えて、ユーザが完全な RBF を有効にするオプションを追加しました。十分なマイニングハッシュレートとリレーするフルノードがこのオプションを有効にすれば、未確認のトランザクションが最終的により高い手数料率を支払うバージョンに置換されることが可能になります。この記事を書いている時点では、それが実現したかどうかは不明です ((("Bitcoin Core", "RBF variants", startref="bitcoin-core-rbf")))。

ユーザとして、RBF 手数料引き上げを使用する予定がある場合は、まずそれをサポートするウォレットを選ぶ必要があります。例えば、https://oreil.ly/IhMzx に「送信サポート」があると記載されているウォレットの一つです。

開発者として、RBF 手数料引き上げを実装する予定がある場合は、まずオプトイン RBF を行うか完全な RBF を行うかを決定する必要があります。この記事を書いている時点では、オプトイン RBF が確実に機能する唯一の方法です。たとえ完全な RBF が信頼できるようになったとしても、オプトイントランザクションの置換が完全な RBF の置換よりもわずかに早く確認される数年間が続く可能性があります。オプトイン RBF を選択する場合、ウォレットは BIP125 で指定されたシグナリングを実装する必要があります。これはトランザクションのシーケンスフィールドのいずれかを簡単に修正することです (<<sequence>> を参照)。完全な RBF を選択する場合、トランザクションにシグナリングを含める必要はありません。RBF に関連するその他のすべては、両方のアプローチで同じです。

トランザクションの手数料を引き上げる必要がある場合は、置き換えたい元のトランザクションと少なくとも 1 つの同じ UTXO を使用する新しいトランザクションを作成します。受取人（または受取人たち）に支払うトランザクションの出力は同じにしておきたいでしょう。手数料の増加分は、お釣りの出力の値を減らすか、トランザクションに追加の入力を加えることで支払うことができます。開発者は、これらの作業をすべて行い、ユーザに手数料率をどの程度引き上げるべきかを尋ねる（または提案する）手数料引き上げインターフェースを提供するべきです。

[WARNING]
====
同じトランザクションの置き換えを複数回行う際には非常に注意してください。すべてのバージョンのトランザクションが互いに競合することを確認しなければなりません。競合しない場合、複数の別々のトランザクションが確認され、受取人に過剰に支払う可能性があります。例えば：

- トランザクションバージョン 0 は入力 _A_ を含みます。
- トランザクションバージョン 1 は入力 _A_ と _B_ を含みます（例：追加の手数料を支払うために入力 _B_ を追加する必要がありました）。
- トランザクションバージョン 2 は入力 _B_ と _C_ を含みます（例：追加の手数料を支払うために入力 _C_ を追加する必要がありましたが、_C_ が十分に大きかったため、入力 _A_ は不要になりました）。

このシナリオでは、バージョン 0 のトランザクションを保存したマイナーは、バージョン 0 とバージョン 2 の両方のトランザクションを確認することができます。両方のバージョンが同じ受取人に支払う場合、彼らは二重に支払われることになります（そしてマイナーは 2 つの別々のトランザクションから手数料を受け取ります）。

この問題を回避する簡単な方法は、置き換えトランザクションが常に前のバージョンのトランザクションと同じ入力をすべて含むようにすることです。
====

RBF 手数料引き上げの他のタイプの手数料引き上げに対する利点は、ブロックスペースの使用が非常に効率的であることです。置き換えトランザクションは、しばしば置き換えるトランザクションと同じサイズです。たとえ大きくなったとしても、最初から手数料率を引き上げていた場合にユーザが作成したであろうトランザクションと同じサイズであることが多いです。

RBF 手数料引き上げの基本的な欠点は、通常、トランザクションの作成者、つまりトランザクションに署名やその他の認証データを提供する必要があった人々だけが実行できることです。例外として、sighash フラグを使用して追加の入力を許可するように設計されたトランザクションがあります（<<sighash_types>> を参照）が、それには独自の課題があります。一般に、未確認のトランザクションの受取人であり、それをより早く（または確実に）確認したい場合、RBF 手数料引き上げを使用することはできません。別の方法が必要です。

追加の問題として、RBF (replace by fee) に関連する問題があります。これについては <<transaction_pinning>> で詳しく探ります。

[[cpfp]]
=== Child Pays for Parent (CPFP) Fee Bumping

未確認トランザクションの出力を受け取った誰もが、その出力を使うことでマイナーにそのトランザクションを確認するインセンティブを与えることができます。確認したいトランザクションは _親トランザクション_ と呼ばれます。親トランザクションの出力を使うトランザクションは _子トランザクション_ と呼ばれます。

<<outpoints>> で学んだように、確認されたトランザクションのすべての入力は、ブロックチェーン上で以前に現れたトランザクションの未使用出力を参照しなければなりません（同じブロック内で以前に現れたものでも、前のブロックでも構いません）。つまり、子トランザクションを確認したいマイナーは、その親トランザクションも確認する必要があります。親トランザクションがまだ確認されていない場合でも、子トランザクションが十分に高い手数料を支払う場合、マイナーは両方を同じブロックで確認することが利益になるかどうかを考慮することができます。

親トランザクションと子トランザクションの両方をマイニングする利益を評価するために、マイナーはそれらを _トランザクションパッケージ_ として見ます。これには、合計サイズと合計手数料が含まれ、手数料をサイズで割ることで _パッケージ手数料率_ を計算できます。マイナーは、知っているすべての個々のトランザクションとトランザクションパッケージを手数料率でソートし、マイニングしようとしているブロックに含める最高収益のものを選びます。ブロックに含めることができる最大サイズ（重量）までです。さらに利益になる可能性のあるパッケージを見つけるために、マイナーは複数世代にわたるパッケージを評価することができます（例：未確認の親トランザクションがその子および孫と組み合わされる場合）。これは _祖先手数料率マイニング_ と呼ばれます。

Bitcoin Core は、何年も前から祖先手数料レートマイニングを実装しており、執筆時点ではほぼすべてのマイナーがこれを使用していると考えられています。これは、ウォレットが子トランザクションを使用して親トランザクションの手数料を支払う (CPFP) ことで、受信トランザクションの手数料を引き上げることが実用的であることを意味します。

CPFP には RBF よりもいくつかの利点があります。トランザクションから出力を受け取る人は誰でも CPFP を使用できます。これには、支払いの受取人と支出者 (支出者が変更出力を含めた場合) の両方が含まれます。また、元のトランザクションを置き換える必要がないため、RBF よりも一部の商人にとっては混乱が少ないです。

CPFP の RBF に対する主な欠点は、通常 CPFP の方がブロックスペースを多く使用することです。RBF では、手数料引き上げトランザクションは、置き換えるトランザクションと同じサイズであることがよくあります。CPFP では、手数料引き上げが完全に別のトランザクションを追加します。余分なブロックスペースを使用するには、手数料引き上げのコストを超える追加の手数料を支払う必要があります。

CPFP にはいくつかの課題があり、その一部は <<transaction_pinning>> で探ります。特に言及する必要があるもう一つの問題は、最低中継手数料レートの問題であり、((("transaction fees", "fee bumping", "CPFP (child pays for parent)", startref="transaction-fees-bump-cpfp")))((("fee bumping", "CPFP (child pays for parent)", startref="fee-bump-cpfp")))((("CPFP (child pays for parent) fee bumping", startref="cpfp-ch9"))) パッケージリレーによって対処されます。

=== パッケージリレー

初期のバージョンの Bitcoin Core は、後でリレーおよびマイニングするためにメモリプールに保存する未確認トランザクションの数に制限を設けていませんでした (<<mempool>> を参照)。もちろん、コンピュータには物理的な制限があります。メモリ (RAM) やディスクスペースなど、フルノードが無制限の数の未確認トランザクションを保存することはできません。後のバージョンの Bitcoin Core は、約 1 日分のトランザクションを保持するようにメモリプールのサイズを制限し、最も高い手数料レートのトランザクションまたはパッケージのみを保存します。

ほとんどのケースでは非常にうまく機能しますが、依存関係の問題を引き起こします。トランザクションパッケージの手数料率を計算するには、親トランザクションと子孫トランザクションの両方が必要です。しかし、親トランザクションが十分に高い手数料率を支払わない場合、ノードのメモリプールに保持されません。ノードが親トランザクションにアクセスできない状態で子トランザクションを受け取った場合、そのトランザクションに対して何もできません。

この問題の解決策は、トランザクションをパッケージとして中継する能力、すなわち _パッケージリレー_ です。これにより、受信ノードは個々のトランザクションを操作する前に、パッケージ全体の手数料率を評価できます。この記事の執筆時点では、Bitcoin Core の開発者たちはパッケージリレーの実装において大きな進展を遂げており、この本が出版される頃には限定的な初期バージョンが利用可能になるかもしれません。

パッケージリレーは、Lightning Network (LN) のような時間に敏感な事前署名済みトランザクションに基づくプロトコルにとって特に重要です。非協力的なケースでは、RBF を使用して手数料を引き上げることができない事前署名済みトランザクションがあり、それらは CPFP に依存せざるを得ません。これらのプロトコルでは、いくつかのトランザクションがブロードキャストされる必要があるずっと前に作成されることがあり、適切な手数料率を見積もることが事実上不可能になります。事前署名済みトランザクションがノードのメモリプールに入るために必要な額を下回る手数料率を支払う場合、子トランザクションで手数料を引き上げる方法がありません。それが原因でトランザクションが時間内に確認されない場合、正直なユーザが資金を失う可能性があります。この重大な問題の解決策がパッケージリレーです。

[[transaction_pinning]]
=== トランザクションピニング

++++
<p class="fix_tracking">
RBF と CPFP の手数料引き上げは、基本的なケースではどちらも機能しますが、マイナーやフルノードの中継に対するサービス拒否攻撃を防ぐために設計されたルールが両方の方法に関連しています。これらのルールの不幸な副作用として、手数料引き上げを使用できなくなることがあります。トランザクションの手数料引き上げを不可能または困難にすることを <em>トランザクションピニング</em> と呼びます。</p>
++++

トランザクションの関係性に関する主要なサービス拒否の懸念の一つは、トランザクションの関係性の影響に関するものです。トランザクションの出力が消費されると、そのトランザクションの識別子 (txid) が子トランザクションによって参照されます。しかし、トランザクションが置き換えられると、置き換えられたトランザクションは異なる txid を持ちます。その置き換えトランザクションが確認されると、その子孫のいずれも同じブロックチェーンに含めることができません。子孫トランザクションを再作成し再署名することは可能ですが、それが必ずしも行われるとは限りません。これは RBF と CPFP に関連していますが、異なる影響を及ぼします。

- RBF の文脈では、Bitcoin Core は置き換えトランザクションを受け入れるとき、元のトランザクションとそれに依存するすべての子孫トランザクションを忘れることでシンプルにしています。マイナーが置き換えを受け入れる方が利益になるようにするため、Bitcoin Core は、忘れられるすべてのトランザクションよりも多くの手数料を支払う場合にのみ置き換えトランザクションを受け入れます。

このアプローチの欠点は、アリスがボブに支払う小さなトランザクションを作成できることです。ボブはその出力を使って大きな子トランザクションを作成できます。その後、アリスが元のトランザクションを置き換えたい場合、彼女とボブが元々支払った額よりも大きな手数料を支払う必要があります。例えば、アリスの元のトランザクションが約 100 vbytes で、ボブのトランザクションが約 100,000 vbytes で、両者が同じ手数料率を使用していた場合、アリスはトランザクションを RBF 手数料バンプするために元々支払った額の 1,000 倍以上を支払う必要があります。

- CPFP の文脈では、ノードがパッケージをブロックに含めることを考慮するたびに、そのパッケージ内のトランザクションを同じブロックに含めるために考慮する他のパッケージから削除する必要があります。例えば、子トランザクションが 25 の祖先に対して支払う場合、それらの祖先のそれぞれが 25 の他の子を持っていると、ブロックにパッケージを含めるには約 625 パッケージ (25^2^) を更新する必要があります。同様に、25 の子孫を持つトランザクションがノードのメモリプールから削除される場合 (例えば、ブロックに含まれるため)、それらの子孫のそれぞれが 25 の他の祖先を持っていると、さらに 625 パッケージを更新する必要があります。パラメータを倍にするたびに (例えば、25 から 50 に)、ノードが実行する必要のある作業量が 4 倍になります。

さらに、トランザクションとそのすべての子孫は、そのトランザクションの代替バージョンが採掘された場合、メモリプールに長期間保持しても役に立ちません。これらのトランザクションは、まれなブロックチェーンの再編成がない限り、確認されることはありません。Bitcoin Core は、現在のブロックチェーンで確認できなくなったすべてのトランザクションをメモリプールから削除します。最悪の場合、それはノードの帯域幅を大量に浪費し、トランザクションが正しく伝播するのを妨げる可能性があります。

これらの問題や関連する他の問題を防ぐために、Bitcoin Core は親トランザクションがメモリプール内で最大 25 の祖先または子孫を持つことを制限し、それらすべてのトランザクションの合計サイズを 100,000 vbytes に制限しています。このアプローチの欠点は、トランザクションがすでに多くの子孫を持っている場合 (またはそれとその子孫が大きすぎる場合)、ユーザが CPFP 手数料バンプを作成できないことです。

トランザクションのピニングは偶然に起こることもありますが、LN のような複数の当事者が関与する時間に敏感なプロトコルにとっては深刻な脆弱性を示します。もし相手方があなたのトランザクションの一つを期限までに確認されないようにすることができれば、彼らはあなたからお金を盗むことができるかもしれません。

プロトコルの開発者たちは、数年間にわたりトランザクションのピニングに関する問題の緩和に取り組んできました。一部の解決策は <<cpfp_carve_out>> に記載されています。他にもいくつかの解決策が提案されており、少なくとも一つの解決策が現在開発中です&mdash;https://oreil.ly/300dv[ephemeral anchors]。

[[cpfp_carve_out]]
=== CPFP カーブアウトとアンカー出力

++++
<p class="fix_tracking2">
2018年、LN に取り組む開発者たちは問題を抱えていました。彼らのプロトコルは、2つの異なる当事者からの署名を必要とするトランザクションを使用します。どちらの当事者も相手を信頼したくないため、信頼が必要ないプロトコルの段階でトランザクションに署名し、後で相手が義務を果たしたくない（または果たせない）時に、どちらかがそれらのトランザクションをブロードキャストできるようにします。このアプローチの問題は、トランザクションがいつブロードキャストされるかが不明であり、将来の適切な手数料率を合理的に見積もる能力を超えている可能性があることです。</p>
++++

理論的には、開発者たちは RBF（特別な sighash フラグを使用）または CPFP を使用して手数料のバンピングを可能にするようにトランザクションを設計することができましたが、これらのプロトコルはどちらもトランザクションのピニングに対して脆弱です。関与するトランザクションが時間に敏感であることを考えると、相手方がトランザクションのピニングを使用してトランザクションの確認を遅らせることを許すと、悪意のある当事者が正直な当事者からお金を盗むために使用できる再現可能なエクスプロイトにつながる可能性があります。

LN 開発者の Matt Corallo は、CPFP 手数料の引き上げに特別な例外を設けるという解決策を提案しました。これを _CPFP carve out_ と呼びます。通常の CPFP のルールでは、親トランザクションに 26 個以上の子孫を持たせる場合や、親とそのすべての子孫が 100,000 vbytes を超えるサイズになる場合には、追加の子孫を含めることを禁じています。しかし、CPFP carve out のルールでは、未確認の祖先を持たない未確認トランザクションの直接の子である限り、1,000 vbytes 以下の単一の追加トランザクションをパッケージに追加することができます。

++++
<p class="fix_tracking">
例えば、ボブとマロリーがそれぞれに出力を持つトランザクションに共同署名したとします。マロリーはそのトランザクションをブロードキャストし、彼女の出力を使って 25 個の子トランザクションまたは 100,000 vbytes に等しい任意の小さい数の子トランザクションを添付します。carve-out がなければ、ボブは CPFP 手数料の引き上げのために彼の出力に別の子トランザクションを添付することができません。しかし、carve-out があれば、彼はトランザクションの 2 つの出力のうち、彼に属するものを使って、1,000 vbytes 未満の子トランザクションを作成することができます（これは十分なスペースです）。</p>
++++

CPFP carve-out を複数回使用することは許可されていないため、これは二者間プロトコルにのみ有効です。より多くの参加者を含むプロトコルへの拡張提案もありますが、その需要はあまりなく、開発者はトランザクションピンニング攻撃に対するより一般的な解決策の構築に集中しています。

この記事の執筆時点では、ほとんどの人気のある LN 実装は _anchor outputs_ と呼ばれるトランザクションテンプレートを使用しており、これは CPFP carve out と共に使用するように設計されています。


=== トランザクションへの手数料の追加

トランザクションのデータ構造には手数料のフィールドがありません。
代わりに、手数料は入力の合計と出力の合計の差として暗黙的に示されます。すべての入力からすべての出力を差し引いた後に残る余剰額が、マイナーによって収集される手数料です：

[latexmath]
++++
\begin{equation}
{Fees = Sum(Inputs) - Sum(Outputs)}
\end{equation}
++++

これはトランザクションのやや混乱を招く要素であり、重要なポイントです。なぜなら、自分でトランザクションを構築する場合、入力を使い切らずに非常に大きな手数料を誤って含めないようにする必要があるからです。つまり、必要に応じてお釣りを作成することで、すべての入力を考慮しなければ、マイナーに非常に大きなチップを渡すことになってしまいます。

例えば、20 ビットコインの UTXO を使って 1 ビットコインの支払いを行う場合、19 ビットコインのお釣り出力を自分のウォレットに戻す必要があります。そうしないと、19 ビットコインの「残り」がトランザクション手数料としてカウントされ、あなたのトランザクションをブロックにマイニングしたマイナーによって収集されます。優先的な処理を受け、マイナーを非常に喜ばせることができますが、これはおそらくあなたが意図したことではないでしょう。

[WARNING]
====
手動で構築したトランザクションでお釣り出力を追加し忘れると、お釣りをトランザクション手数料として支払うことになります。「お釣りは取っておいて！」というのは、あなたが意図したことではないかもしれません。
====

[[fee_sniping]]
=== 手数料スナイピングに対するタイムロック防御

手数料スナイピングは、マイナーが過去のブロックを書き換えようとする際に、将来のブロックからより高い手数料のトランザクションを「狙い撃ち」して [.keep-together]#収益性# を最大化する理論的な攻撃シナリオです。

例えば、存在する最高のブロックがブロック #100,000 だとしましょう。チェーンを延長するためにブロック #100,001 をマイニングしようとする代わりに、一部のマイナーがブロック #100,000 を再マイニングしようとします。これらのマイナーは、候補ブロック #100,000 にまだマイニングされていない有効なトランザクションを含めることができます。同じトランザクションでブロックを再マイニングする必要はありません。実際、最も収益性の高い（kB あたりの手数料が最も高い）トランザクションを選択してブロックに含めるインセンティブがあります。彼らは「古い」ブロック #100,000 にあったトランザクションや、現在のメモリプールからのトランザクションを含めることができます。基本的に、ブロック #100,000 を再作成する際に、トランザクションを「現在」から書き換えられた「過去」に引き込むオプションがあります。

現在、この攻撃はあまり利益を生みません。なぜなら、ブロック補助金がブロックごとの総手数料よりもはるかに高いからです。しかし、将来的には取引手数料が報酬の大部分（あるいは報酬の全体）を占めるようになるでしょう。その時、このシナリオは避けられなくなります。

いくつかのウォレットは、次のブロックまたはそれ以降のブロックにのみ含まれるように制限するロックタイムを設定することで、手数料スナイピングを抑制しています。私たちのシナリオでは、ウォレットは作成するすべての取引に対してロックタイムを 100,001 に設定します。通常の状況では、このロックタイムは影響を与えません。取引はどのみちブロック #100,001 にしか含まれないからです。それが次のブロックです。

しかし、再編成攻撃の下では、マイナーはメモリプールから高手数料の取引を引き出すことができません。なぜなら、それらの取引はすべてブロック #100,001 にタイムロックされているからです。彼らは #100,000 を、その時点で有効だった取引でしか再マイニングできず、実質的に新しい手数料を得ることはできません。

これにより手数料スナイピングが完全に防止されるわけではありませんが、場合によっては利益を減少させ、ブロック補助金が減少する中でビットコインネットワークの安定性を維持するのに役立ちます。すべてのウォレットが、ロックタイムフィールドの他の用途を妨げない場合には、手数料スナイピング防止を実装することをお勧めします。

ビットコインが成熟し続け、補助金が減少し続けるにつれて、手数料はビットコインユーザにとってますます重要になります。これは、取引を迅速に確認するための日常的な使用においても、新しいプルーフ・オブ・ワークでビットコイン取引を保護し続けるためのインセンティブを提供する上でも重要です。
