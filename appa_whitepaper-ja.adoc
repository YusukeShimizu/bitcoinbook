[[satoshi_whitepaper]]
[appendix]
== The Bitcoin Whitepaper [.keep-together]#by Satoshi Nakamoto#


[NOTE]
====
これは、サトシ・ナカモトによって2008年10月に発表されたオリジナルのホワイトペーパーを完全に再現したものです。
====

=== Bitcoin - A Peer-to-Peer Electronic Cash System

サトシ・ナカモト

_satoshin@gmx.com_

pass:[<a href="https://bitcoin.org/en/" class="orm:hideurl"><em>www.bitcoin.org</em></a>]

*概要.* 完全にピアツーピアの電子現金システムは、金融機関を介さずに一方から他方へ直接オンライン支払いを送信できるようにします。デジタル署名は部分的な解決策を提供しますが、二重支払いを防ぐために信頼できる第三者が依然として必要である場合、主な利点は失われます。私たちは、ピアツーピアネットワークを使用して二重支払い問題の解決策を提案します。ネットワークは、トランザクションをハッシュベースのプルーフ・オブ・ワークの継続的なチェーンにハッシュ化することでタイムスタンプを付け、プルーフ・オブ・ワークを再実行しない限り変更できない記録を形成します。最も長いチェーンは、目撃されたイベントの順序の証拠としてだけでなく、最大のCPUパワープールから来たことの証拠としても機能します。CPUパワーの過半数がネットワークを攻撃するために協力していないノードによって制御されている限り、彼らは最も長いチェーンを生成し、攻撃者を凌駕します。ネットワーク自体は最小限の構造を必要とします。メッセージはベストエフォートベースでブロードキャストされ、ノードは自由にネットワークを離れたり再参加したりでき、彼らが不在の間に何が起こったかの証拠として最も長いプルーフ・オブ・ワークチェーンを受け入れます。

==== Introduction
インターネット上の商取引は、電子決済を処理するために信頼できる第三者として機能する金融機関にほぼ完全に依存するようになっています。このシステムはほとんどの取引において十分に機能しますが、信頼ベースのモデルの固有の弱点に悩まされています。完全に不可逆的な取引は実際には不可能であり、金融機関は紛争の仲裁を避けることができません。仲裁のコストは取引コストを増加させ、実際的な最小取引サイズを制限し、小規模なカジュアル取引の可能性を排除します。また、不可逆的なサービスに対する不可逆的な支払いを行う能力の喪失という広範なコストもあります。逆転の可能性があるため、信頼の必要性が広がります。商人は顧客に対して警戒し、通常は必要としない情報を求めて煩わせます。一定の割合の詐欺は避けられないものとして受け入れられています。これらのコストと支払いの不確実性は、物理的な通貨を使用することで対面で回避できますが、信頼できる第三者なしに通信チャネルを介して支払いを行うメカニズムは存在しません。

暗号学的証明に基づく電子決済システムが必要です。これにより、信頼できる第三者を必要とせずに、任意の二者が直接取引を行うことができます。計算上逆転が実質的に不可能な取引は、売り手を詐欺から守り、買い手を保護するための通常のエスクロー機構も簡単に実装できます。この論文では、ピアツーピアの分散タイムスタンプサーバを使用して、取引の時系列順序の計算証明を生成することで、二重支出問題の解決策を提案します。システムは、正直なノードが協力する攻撃者ノードのグループよりも多くの CPU パワーを集団で制御している限り安全です。

==== 取引
私たちは、電子コインをデジタル署名の連鎖として定義します。各所有者は、前の取引のハッシュと次の所有者の公開鍵をデジタル署名し、これらをコインの末尾に追加することでコインを次の所有者に移転します。受取人は署名を確認して、所有権の連鎖を検証できます。

image::images/mbc3_0401.png["Transactions"]

もちろん問題は、受取人が所有者の一人がコインを二重支出していないことを確認できないことです。一般的な解決策は、信頼できる中央機関、またはミントを導入し、すべての取引を二重支出のためにチェックすることです。各取引の後、コインは新しいコインを発行するためにミントに返されなければならず、ミントから直接発行されたコインのみが二重支出されないと信頼されます。この解決策の問題は、すべての取引が銀行のようにミントを通過しなければならず、ミントを運営する会社にお金のシステム全体の運命が依存することです。

受取人が以前の所有者が以前の取引に署名していないことを知る方法が必要です。私たちの目的では、最も早い取引が重要であり、後の二重支出の試みは気にしません。取引の不在を確認する唯一の方法は、すべての取引を把握することです。ミントベースのモデルでは、ミントがすべての取引を把握し、どれが最初に到着したかを決定しました。これを信頼できる第三者なしで達成するためには、取引を公に発表する必要があります [1]。そして、参加者が受信された順序の単一の履歴に同意するためのシステムが必要です。受取人は、各取引の時点で、ノードの過半数がそれが最初に受信されたと同意したという証拠を必要とします。

==== タイムスタンプサーバー
私たちが提案する解決策は、タイムスタンプサーバーから始まります。タイムスタンプサーバーは、タイムスタンプを付けるアイテムのブロックのハッシュを取り、そのハッシュを新聞や Usenet 投稿などで広く公開することで機能します [2-5]。タイムスタンプは、そのデータがその時点で存在していたことを証明します。なぜなら、ハッシュに含まれるためには当然その時点で存在していなければならないからです。各タイムスタンプは、そのハッシュに前のタイムスタンプを含め、チェーンを形成し、追加されるタイムスタンプがそれ以前のものを強化します。

image::images/mbc3_aain02.png["timestamp server"]

==== プルーフ・オブ・ワーク
ピアツーピアベースで分散型タイムスタンプサーバーを実装するためには、新聞や Usenet 投稿の代わりに、Adam Back の Hashcash に似たプルーフ・オブ・ワークシステムを使用する必要があります [6]。プルーフ・オブ・ワークは、ハッシュ化したときに、例えば SHA-256 で、ハッシュが一定数のゼロビットで始まるような値をスキャンすることを含みます。必要なゼロビットの数に対する平均的な作業量は指数的であり、単一のハッシュを実行することで検証できます。私たちのタイムスタンプネットワークでは、ブロックのノンスをインクリメントして、ブロックのハッシュが必要なゼロビットを持つ値を見つけることでプルーフ・オブ・ワークを実装します。一度 CPU 努力がプルーフ・オブ・ワークを満たすように費やされると、そのブロックは作業をやり直さない限り変更できません。後のブロックがそれに続いてチェーンされると、そのブロックを変更するための作業には、それ以降のすべてのブロックをやり直すことが含まれます。

image::images/mbc3_aain03.png["pow"]

プルーフ・オブ・ワークは、過半数決定における代表性を決定する問題も解決します。もし過半数が一つの IP アドレス一票に基づいていた場合、多くの IP を割り当てることができる誰かによって覆される可能性があります。プルーフ・オブ・ワークは本質的に一つの CPU 一票です。過半数の決定は、最も多くのプルーフ・オブ・ワークの努力が投資された最長のチェーンによって表されます。もし過半数の CPU パワーが正直なノードによって制御されている場合、正直なチェーンは最も速く成長し、競合するチェーンを追い越します。過去のブロックを変更するには、攻撃者はそのブロックとそれ以降のすべてのブロックのプルーフ・オブ・ワークをやり直し、正直なノードの作業に追いつき、追い越さなければなりません。後で示すように、遅い攻撃者が追いつく確率は、後続のブロックが追加されるにつれて指数関数的に減少します。

ハードウェアの速度向上やノード運用への関心の変動を補うために、プルーフ・オブ・ワークの難易度は、1 時間あたりの平均ブロック数を目標とする移動平均によって決定されます。ブロックが速く生成されすぎる場合、難易度は上がります。

==== ネットワーク

ネットワークを運用するための手順は次のとおりです：

1. 新しいトランザクションはすべてのノードにブロードキャストされます。
2. 各ノードは新しいトランザクションをブロックにまとめます。
3. 各ノードは自分のブロックに対して難しいプルーフ・オブ・ワークを見つける作業を行います。
4. ノードがプルーフ・オブ・ワークを見つけたら、そのブロックをすべてのノードにブロードキャストします。
5. ノードは、そのブロック内のすべてのトランザクションが有効であり、まだ使用されていない場合にのみブロックを受け入れます。
6. ノードは、受け入れたブロックのハッシュを前のハッシュとして使用し、チェーン内の次のブロックを作成する作業を行うことで、ブロックの受け入れを表明します。

ノードは常に最も長いチェーンを正しいものと見なし、それを拡張する作業を続けます。もし 2 つのノードが同時に次のブロックの異なるバージョンをブロードキャストした場合、あるノードは一方を先に受け取るかもしれません。その場合、最初に受け取ったものに対して作業を行いますが、他のブランチも保存しておき、そちらが長くなった場合に備えます。次のプルーフ・オブ・ワークが見つかり、どちらかのブランチが長くなったときに、タイは解消されます。その時点で、他のブランチで作業していたノードは長い方に切り替わります。

新しいトランザクションのブロードキャストは、必ずしもすべてのノードに到達する必要はありません。多くのノードに到達すれば、すぐにブロックに取り込まれます。ブロックのブロードキャストも、メッセージがドロップされても耐性があります。ノードがブロックを受け取らなかった場合、次のブロックを受け取ったときにそれを要求し、見逃したことに気づきます。

==== インセンティブ
慣例により、ブロック内の最初のトランザクションは、ブロックの作成者が所有する新しいコインを開始する特別なトランザクションです。これにより、ノードがネットワークをサポートするインセンティブが追加され、コインを流通に初めて分配する方法が提供されます。中央の発行機関がないためです。一定量の新しいコインを安定的に追加することは、金鉱掘りが資源を費やして金を流通に追加することに似ています。私たちの場合、それは CPU 時間と電力が費やされることです。

インセンティブはトランザクション手数料で資金提供することもできます。トランザクションの出力値が入力値よりも少ない場合、その差額はトランザクション手数料となり、トランザクションを含むブロックのインセンティブ値に追加されます。あらかじめ決められた数のコインが流通に入った後は、インセンティブは完全にトランザクション手数料に移行し、完全にインフレフリーになることができます。

インセンティブはノードが正直であることを促進するのに役立つかもしれません。貪欲な攻撃者がすべての正直なノードよりも多くの CPU パワーを集めることができた場合、彼はそれを使って支払いを取り戻すことで人々を欺くか、新しいコインを生成するかを選ばなければなりません。彼は、システムを破壊し、自分自身の富の有効性を損なうよりも、他のすべての人を合わせたよりも多くの新しいコインを彼に与えるルールに従う方が利益があると考えるべきです。

==== ディスクスペースの再利用

++++
<p>コイン内の最新のトランザクションが十分な数のブロックの下に埋められると、それ以前の使用済みトランザクションはディスクスペースを節約するために破棄できます。これをブロックのハッシュを壊さずに行うために、トランザクションはマークルツリーでハッシュされ、ブロックのハッシュにはルートのみが含まれます。古いブロックはツリーの枝を切り詰めることで圧縮できます。内部のハッシュは保存する必要がありません。</p>
++++

image::images/mbc3_aain04.png["disk"]

トランザクションのないブロックヘッダーは約 80 バイトです。ブロックが 10 分ごとに生成されると仮定すると、+80 バイト * 6 * 24 * 365 = 4.2MB+ になります。2008 年時点でコンピュータシステムは通常 2GB の RAM を搭載して販売されており、ムーアの法則は年間 1.2GB の成長を予測しているため、ブロックヘッダーをメモリに保持しなければならない場合でもストレージは問題にならないはずです。

==== 簡易支払い検証

フルネットワークノードを実行せずに支払いを検証することが可能です。ユーザは、最長のプルーフ・オブ・ワークチェーンのブロックヘッダーのコピーを保持するだけでよく、ネットワークノードに問い合わせて最長のチェーンを持っていると確信するまでそれを取得し、トランザクションをタイムスタンプされたブロックにリンクするマークルブランチを取得します。彼はトランザクションを自分で確認することはできませんが、それをチェーンの場所にリンクすることで、ネットワークノードがそれを受け入れたことを確認でき、その後に追加されたブロックがネットワークがそれを受け入れたことをさらに確認します。


image::images/mbc3_aain05.png["spv"]

このように、正直なノードがネットワークを制御している限り、検証は信頼できますが、攻撃者によってネットワークが圧倒された場合には脆弱になります。ネットワークノードは自分自身でトランザクションを検証できますが、簡略化された方法は、攻撃者がネットワークを圧倒し続ける限り、攻撃者の偽造トランザクションに騙される可能性があります。これに対抗するための一つの戦略は、ネットワークノードが無効なブロックを検出したときにアラートを受け入れ、ユーザのソフトウェアが完全なブロックとアラートされたトランザクションをダウンロードして不一致を確認するよう促すことです。頻繁に支払いを受ける企業は、より独立したセキュリティと迅速な検証のために、自分自身のノードを運用したいと考えるでしょう。

==== 値の結合と分割
コインを個別に扱うことも可能ですが、送金のたびに1セントごとに別々のトランザクションを作成するのは煩雑です。値を分割および結合できるようにするために、トランザクションには複数の入力と出力が含まれます。通常、以前の大きなトランザクションからの単一の入力、または小額を結合した複数の入力があり、出力は最大で2つです。1つは支払い用で、もう1つはお釣りがあれば送信者に戻すためのものです。

image::images/mbc3_aain06.png["combining-splitting"]

ここで、トランザクションが複数のトランザクションに依存し、それらのトランザクションがさらに多くのトランザクションに依存するファンアウトは問題ではないことに注意してください。トランザクションの履歴の完全な独立したコピーを抽出する必要はありません。

==== プライバシー

従来の銀行モデルは、関係者と信頼できる第三者にのみ情報へのアクセスを制限することで、ある程度のプライバシーを達成しています。すべての取引を公に発表する必要があるため、この方法は使えませんが、情報の流れを別の場所で断つことでプライバシーを維持することができます。それは公開鍵を匿名に保つことです。一般の人々は、誰かが誰かに金額を送っていることを見ることができますが、その取引が誰に関連しているかの情報はありません。これは、株式取引所が公開する情報のレベルに似ています。個々の取引の時間とサイズ、「テープ」は公開されますが、当事者が誰であったかは明かされません。

image::images/mbc3_aain07.png["privacy"]

追加の防火壁として、各取引に新しい鍵ペアを使用し、共通の所有者にリンクされないようにするべきです。マルチインプット取引では、インプットが同じ所有者に属していたことが明らかになるため、いくつかのリンクは避けられません。鍵の所有者が明らかになると、リンクによって同じ所有者に属する他の取引が明らかになるリスクがあります。

==== 計算

攻撃者が正直なチェーンよりも速く代替チェーンを生成しようとするシナリオを考えます。たとえこれが達成されたとしても、システムが任意の変更に開かれるわけではありません。例えば、何もないところから価値を生み出したり、攻撃者に属していなかったお金を取ったりすることはできません。ノードは無効な取引を支払いとして受け入れず、正直なノードはそれを含むブロックを決して受け入れません。攻撃者は、最近使ったお金を取り戻すために自分の取引の一つを変更しようとすることしかできません。

正直なチェーンと攻撃者のチェーンの競争は、二項ランダムウォークとして特徴付けることができます。成功イベントは、正直なチェーンが1ブロック延長され、そのリードが+1増加することです。失敗イベントは、攻撃者のチェーンが1ブロック延長され、ギャップが-1減少することです。

++++
<p>攻撃者がある欠損から追いつく確率は、ギャンブラーの破産問題 (Gambler's Ruin problem) に類似しています。無限のクレジットを持つギャンブラーが欠損から始め、ブレークイーブンに達するために無限の試行を行うと仮定します。彼がブレークイーブンに達する確率、または攻撃者が正直なチェーンに追いつく確率を次のように計算できます<a href="#ref_eight">[8]</a>：</p>
++++

p = 正直なノードが次のブロックを見つける確率

q = 攻撃者が次のブロックを見つける確率

q~z~ = 攻撃者が z ブロック遅れから追いつく確率


++++
<div data-type="equation">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML" >
  <mstyle mathsize="1.2000em">
    <msub>
      <mi>q</mi>
      <mi>z</mi>
    </msub>
    <mo>=</mo>
    <mrow>
      <mo fence="true" form="prefix">{</mo>
      <mtable columnalign="center center">
        <mtr>
          <mtd>
            <mn>1</mn>
          </mtd>
          <mtd>
            <mrow>
              <mtext>if</mtext>
              <mspace width="0.2778em"></mspace>
              <mi>p</mi>
              <mo>≤</mo>
              <mi>q</mi>
            </mrow>
          </mtd>
        </mtr>
        <mtr>
          <mtd>
            <mrow>
              <mo form="prefix" stretchy="false">(</mo>
              <mi>q</mi>
              <mo lspace="0em" rspace="0em">⁄</mo>
              <mi>p</mi>
              <msup>
                <mo form="postfix" stretchy="false">)</mo>
                <mi>z</mi>
              </msup>
            </mrow>
          </mtd>
          <mtd>
            <mrow>
              <mtext>if</mtext>
              <mspace width="0.2778em"></mspace>
              <mi>p</mi>
              <mo>&gt;</mo>
              <mi>q</mi>
            </mrow>
          </mtd>
        </mtr>
      </mtable>
      <mo fence="true" form="postfix">}</mo>
    </mrow>
  </mstyle>
</math>
</div>
++++

p > q という仮定のもとでは、攻撃者が追いつく必要のあるブロック数が増えるにつれて、確率は指数関数的に低下します。彼に不利な状況で、早い段階で幸運な突進をしない限り、彼のチャンスはさらに遅れを取るにつれてほとんどなくなります。

新しい取引の受取人が、送信者が取引を変更できないと十分に確信するまでどれくらい待つ必要があるかを考えます。送信者が、しばらくの間受取人に支払いをしたと信じさせた後、時間が経過した後に自分自身に支払いを戻すことを望む攻撃者であると仮定します。それが起こったとき、受取人は警告を受けますが、送信者はそれが手遅れになることを望んでいます。

受取人は新しい鍵ペアを生成し、署名の直前に公開鍵を送信者に渡します。これにより、送信者が事前にブロックチェーンを準備し、運良く十分に先行するまで継続的に作業し、その瞬間に取引を実行することを防ぎます。取引が送信されると、不正な送信者は秘密裏に彼の取引の別バージョンを含む並行チェーンで作業を開始します。

受取人は、取引がブロックに追加され、その後 z ブロックがリンクされるまで待ちます。彼は攻撃者がどれだけ進捗したか正確には知りませんが、正直なブロックがブロックごとに平均的な期待時間を要したと仮定すると、攻撃者の潜在的な進捗は期待値が次のポアソン分布になります：

++++
<div data-type="equation">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML" >
  <mstyle mathsize="1.2000em">
    <mi>λ</mi>
    <mo>=</mo>
    <mi>z</mi>
    <mfrac>
      <mi>q</mi>
      <mi>p</mi>
    </mfrac>
  </mstyle>
</math>
</div>
++++

攻撃者が今でも追いつく可能性を得るために、彼が達成した可能性のある進捗の各量に対するポアソン密度を、そこから追いつく可能性と掛け合わせます：

++++
<div data-type="equation">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML" >
  <mstyle mathsize="1.2000em">
    <mrow>
      <munderover>
        <mo movablelimits="false">∑</mo>
        <mrow>
          <mi>k</mi>
          <mo>=</mo>
          <mn>0</mn>
        </mrow>
        <mi>∞</mi>
      </munderover>
    </mrow>
    <mfrac>
      <mrow>
        <msup>
          <mi>λ</mi>
          <mi>k</mi>
        </msup>
        <msup>
          <mi>e</mi>
          <mrow>
            <mo>−</mo>
            <mi>λ</mi>
          </mrow>
        </msup>
      </mrow>
      <mrow>
        <mi>k</mi>
        <mo form="postfix" stretchy="false">!</mo>
      </mrow>
    </mfrac>
    <mo>⋅</mo>
    <mrow>
      <mo fence="true" form="prefix">{</mo>
      <mtable columnalign="center center">
        <mtr>
          <mtd>
            <mrow>
              <mo form="prefix" stretchy="false">(</mo>
              <mi>q</mi>
              <mo lspace="0em" rspace="0em">⁄</mo>
              <mi>p</mi>
              <msup>
                <mo form="postfix" stretchy="false">)</mo>
                <mrow>
                  <mo form="prefix" stretchy="false">(</mo>
                  <mi>z</mi>
                  <mo>−</mo>
                  <mi>k</mi>
                  <mo form="postfix" stretchy="false">)</mo>
                </mrow>
              </msup>
            </mrow>
          </mtd>
          <mtd>
            <mrow>
              <mtext>if</mtext>
              <mspace width="0.2778em"></mspace>
              <mi>k</mi>
              <mo>≤</mo>
              <mi>z</mi>
            </mrow>
          </mtd>
        </mtr>
        <mtr>
          <mtd>
            <mn>1</mn>
          </mtd>
          <mtd>
            <mrow>
              <mtext>if</mtext>
              <mspace width="0.2778em"></mspace>
              <mi>k</mi>
              <mo>&gt;</mo>
              <mi>z</mi>
            </mrow>
          </mtd>
        </mtr>
      </mtable>
      <mo fence="true" form="postfix">}</mo>
    </mrow>
  </mstyle>
</math>
</div>
++++

分布の無限の尾を合計しないように再配置します...

++++
<div data-type="equation">
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML" >
  <mstyle mathsize="1.2000em">
    <mn>1</mn>
    <mo>−</mo>
    <mrow>
      <munderover>
        <mo movablelimits="false">∑</mo>
        <mrow>
          <mi>k</mi>
          <mo>=</mo>
          <mn>0</mn>
        </mrow>
        <mi>z</mi>
      </munderover>
    </mrow>
    <mfrac>
      <mrow>
        <msup>
          <mi>λ</mi>
          <mi>k</mi>
        </msup>
        <msup>
          <mi>e</mi>
          <mrow>
            <mo>−</mo>
            <mi>λ</mi>
          </mrow>
        </msup>
      </mrow>
      <mrow>
        <mi>k</mi>
        <mo form="postfix" stretchy="false">!</mo>
      </mrow>
    </mfrac>
    <mrow>
      <mo fence="true" form="prefix">(</mo>
      <mn>1</mn>
      <mo>−</mo>
      <mo form="prefix" stretchy="false">(</mo>
      <mi>q</mi>
      <mo lspace="0em" rspace="0em">⁄</mo>
      <mi>p</mi>
      <msup>
        <mo form="postfix" stretchy="false">)</mo>
        <mrow>
          <mo form="prefix" stretchy="false">(</mo>
          <mi>z</mi>
          <mo>−</mo>
          <mi>k</mi>
          <mo form="postfix" stretchy="false">)</mo>
        </mrow>
      </msup>
      <mo fence="true" form="postfix">)</mo>
    </mrow>
  </mstyle>
</math>
</div>
++++

Cコードに変換します...

[source,c]
----
#include <math.h>
double AttackerSuccessProbability(double q, int z)
{
    double p = 1.0 - q;
    double lambda = z * (q / p);
    double sum = 1.0;
    int i, k;
    for (k = 0; k <= z; k++)
    {
        double poisson = exp(-lambda);
        for (i = 1; i <= k; i++)
            poisson *= lambda / i;
        sum -= poisson * (1 - pow(q / p, z - k));
    }
    return sum;
}
----

いくつかの結果を実行すると、z とともに確率が指数関数的に減少することがわかります。
----
q=0.1
z=0 P=1.0000000
z=1 P=0.2045873
z=2 P=0.0509779
z=3 P=0.0131722
z=4 P=0.0034552
z=5 P=0.0009137
z=6 P=0.0002428
z=7 P=0.0000647
z=8 P=0.0000173
z=9 P=0.0000046
z=10 P=0.0000012
----
----
q=0.3
z=0 P=1.0000000
z=5 P=0.1773523
z=10 P=0.0416605
z=15 P=0.0101008
z=20 P=0.0024804
z=25 P=0.0006132
z=30 P=0.0001522
z=35 P=0.0000379
z=40 P=0.0000095
z=45 P=0.0000024
z=50 P=0.0000006
----
0.1%未満のPを解く...
----
P < 0.001
q=0.10 z=5
q=0.15 z=8
q=0.20 z=11
q=0.25 z=15
q=0.30 z=24
q=0.35 z=41
q=0.40 z=89
q=0.45 z=340
----


==== Conclusion
私たちは信頼に依存しない電子取引のシステムを提案しました。通常のデジタル署名からなるコインの枠組みから始めました。これは所有権の強力な管理を提供しますが、二重支出を防ぐ方法がなければ不完全です。これを解決するために、私たちはプルーフ・オブ・ワークを使用して取引の公開履歴を記録するピア・ツー・ピアネットワークを提案しました。正直なノードが CPU パワーの過半数を制御している場合、攻撃者が変更するのは計算上非現実的になります。このネットワークは、その構造化されていないシンプルさにおいて堅牢です。ノードはほとんど調整なしに一斉に動作します。メッセージは特定の場所にルーティングされる必要がなく、ベストエフォートで配信されるだけでよいため、ノードを識別する必要はありません。ノードは自由にネットワークを離れたり再参加したりでき、離れている間に何が起こったかの証拠としてプルーフ・オブ・ワークチェーンを受け入れます。彼らは CPU パワーで投票し、有効なブロックを拡張する作業を行うことでそれを受け入れ、無効なブロックには作業を拒否することで拒否を表明します。必要なルールとインセンティブは、このコンセンサスメカニズムで強制することができます。

==== References
++++
<p>
<span id="ref_one">[1]</span> W. Dai, "b-money," <a href="http://www.weidai.com/bmoney.txt"><em>http://www.weidai.com/bmoney.txt</em></a>, 1998.
</p>
<p>
<span id="ref_two">[2]</span> H. Massias, X.S. Avila, and J.-J. Quisquater, "Design of a secure timestamping service with minimal trust requirements," In 20th Symposium on Information Theory in the Benelux, May 1999.
</p>
<p>
<span id="ref_three">[3]</span> S. Haber, W.S. Stornetta, "How to time-stamp a digital document," In Journal of Cryptology, vol 3, no 2, pages 99-111, 1991.
</p>

<p>
<span id="ref_four">[4]</span> D. Bayer, S. Haber, W.S. Stornetta, "Improving the efficiency and reliability of digital time-stamping," In Sequences II: Methods in Communication, Security and Computer Science, pages 329-334, 1993.
</p>


<p>
<span id="ref_five">[5]</span> S. Haber, W.S. Stornetta, 「Secure names for bit-strings」, In Proceedings of the 4th ACM Conference on Computer and Communications Security, pages 28-35, April 1997.
</p>

<p>
<span id="ref_six">[6]</span> A. Back, 「Hashcash - a denial of service counter-measure」, <a href="http://www.hashcash.org/papers/hashcash.pdf"><em>http://www.hashcash.org/papers/hashcash.pdf</em></a>, 2002.
</p>

<p>
<span id="ref_seven">[7]</span> R.C. Merkle, 「Protocols for public key cryptosystems」, In Proc. 1980 Symposium on Security and Privacy, IEEE Computer Society, pages 122-133, April 1980.
</p>

<p>
<span id="ref_eight">[8]</span> W. Feller, 「An introduction to probability theory and its applications」, 1957.
</p>
++++

=== ライセンス

このホワイトペーパーは 2008 年 10 月に Satoshi Nakamoto によって発表されました。後に (2009 年) ビットコインソフトウェアのサポートドキュメントとして追加され、同じ MIT ライセンスが適用されています。この書籍では、フォーマット以外の変更を加えずに MIT ライセンスの条件の下で再現されています：

The MIT License (MIT)
Copyright (c) 2008 Satoshi Nakamoto

本ソフトウェアおよび関連するドキュメントファイル (以下「ソフトウェア」) のコピーを取得するすべての人に対し、ソフトウェアを制限なく使用、コピー、変更、統合、公開、配布、サブライセンス、または販売する権利を無償で許可します。また、ソフトウェアが提供される人々に同様の権利を許可することができます。ただし、以下の条件に従うものとします：

上記の著作権表示および本許可表示は、ソフトウェアのすべてのコピーまたは重要な部分に含める必要があります。

本ソフトウェアは「現状のまま」提供され、商品性、特定目的への適合性および非侵害に関する保証を含む、明示または黙示のいかなる保証もありません。著者または著作権者は、本ソフトウェアまたは本ソフトウェアの使用またはその他の取引に起因または関連して発生するいかなる請求、損害またはその他の責任についても責任を負いません。

It seems like you haven't provided the Markdown file yet. Please go ahead and paste the content you would like translated, and I'll assist you with the translation according to the specified rules.
