[[blockchain]]
== ブロックチェーン

ブロックチェーンは、すべての確認済みビットコイン取引の履歴です。これにより、すべてのフルノードが独立してどの鍵とスクリプトがどのビットコインを制御しているかを判断できます。この章では、ブロックチェーンの構造を見て、暗号学的コミットメントやその他の巧妙なトリックをどのように利用して、フルノード（時には軽量クライアント）にとって各部分の検証を容易にしているかを見ていきます。

ブロックチェーンのデータ構造は、トランザクションのブロックの順序付けられたバックリンクリストです。ブロックチェーンはフラットファイルとして、またはシンプルなデータベースに保存できます。ブロックは「後ろ」にリンクされており、それぞれがチェーン内の前のブロックを参照しています。ブロックチェーンはしばしば縦に積み重ねられたものとして視覚化され、ブロックが互いに重なり合い、最初のブロックがスタックの基礎として機能します。このブロックが積み重なった視覚化により、最初のブロックからの距離を指す「高さ」や、最近追加されたブロックを指す「トップ」または「ティップ」といった用語が使われます。

ブロックチェーン内の各ブロックは、ブロックのヘッダーに対して SHA256 暗号学的ハッシュアルゴリズムを使用して生成されたハッシュによって識別されます。各ブロックは、ブロックヘッダー内の「前のブロックハッシュ」フィールドを通じて、_親_ ブロックとして知られる前のブロックにコミットします。各ブロックを親にリンクするハッシュのシーケンスは、最初に作成されたブロック、_ジェネシスブロック_ として知られるものまで遡るチェーンを作成します。

ブロックには親が一つしかありませんが、複数の子供を持つことができます。各子供は同じ親ブロックにコミットします。異なるマイナーによってほぼ同時に異なるブロックが発見されたときに発生する一時的な状況であるブロックチェーンの「フォーク」の間に、複数の子供が生じます（<<forks>>を参照）。最終的には、1つの子ブロックだけがすべてのフルノードによって受け入れられるブロックチェーンの一部となり、「フォーク」は解決されます。

「前のブロックハッシュ」フィールドはブロックヘッダー内にあり、それによって_現在の_ ブロックのハッシュに影響を与えます。親ブロックに対する変更は、子ブロックのハッシュの変更を必要とし、それが孫のポインタの変更を必要とし、それが孫を変更し、という具合に続きます。このシーケンスにより、ブロックに多くの世代が続くと、そのブロックを変更するにはすべての後続ブロックの再計算を強制する必要があることが保証されます。このような再計算には莫大な計算（したがってエネルギー消費）が必要となるため、長いブロックチェーンの存在はブロックチェーンの深い歴史を変更することを非現実的にし、これがビットコインのセキュリティの重要な特徴です。

ブロックチェーンを考える一つの方法は、地質層や氷河のコアサンプルの層のように考えることです。表面の層は季節によって変わることもあれば、定着する前に吹き飛ばされることもあります。しかし、数インチ深く進むと、地質層はますます安定してきます。数百フィート下を見れば、何百万年も乱されていない過去のスナップショットを見ていることになります。ブロックチェーンでは、最近のいくつかのブロックは、フォークによるチェーンの再編成がある場合に修正されることがあります。上位の6ブロックは、数インチの表土のようなものです。しかし、ブロックチェーンを6ブロック以上深く進むと、ブロックが変わる可能性はますます低くなります。100ブロック前になると、非常に安定しているため、新しいブロックを作成する報酬を含むコインベーストランザクションが使用可能になります。プロトコルは常に、より長いチェーンによってチェーンが元に戻されることを許可しており、どのブロックも逆転される可能性は常に存在しますが、そのようなイベントの確率は時間が経つにつれて減少し、最終的にはごくわずかになります。

=== ブロックの構造

ブロックは、ブロックチェーンに含めるためのトランザクションを集約するコンテナデータ構造です。ブロックはメタデータを含むヘッダーと、そのサイズの大部分を占める長いトランザクションのリストで構成されています。ブロックヘッダーは80バイトですが、ブロック内のすべてのトランザクションの合計サイズは約4,000,000バイトに達することがあります。したがって、すべてのトランザクションを含む完全なブロックは、ブロックヘッダーの約50,000倍の大きさになる可能性があります。<<block_structure1>> は、Bitcoin Core がブロックの構造をどのように保存しているかを示しています。

++++
<table id="block_structure1">
<caption>The structure of a block</caption>
<thead>
<tr>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>4 bytes</p></td>
<td><p>Block Size</p></td>
<td><p>The size of the block, in bytes, following this field</p></td>
</tr>
<tr>
<td><p>80 bytes</p></td>
<td><p>Block Header</p></td>
<td><p>Several fields form the block header</p></td>
</tr>
<tr>
<td><p>1–3 bytes (compactSize)</p></td>
<td><p>Transaction Counter</p></td>
<td><p>How many transactions follow</p></td>
</tr>
<tr>
<td><p>Variable</p></td>
<td><p>Transactions</p></td>
<td><p>The transactions recorded in this block</p></td>
</tr>
</tbody>
</table>
++++

[[block_header]]
=== ブロックヘッダー

ブロックヘッダーは、<<block_header_structure_ch09>> に示すように、ブロックのメタデータで構成されます。

++++
<table id="block_header_structure_ch09">
<caption>ブロックヘッダーの構造</caption>
<thead>
<tr>
<th>サイズ</th>
<th>フィールド</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>4 バイト</p></td>
<td><p>バージョン</p></td>
<td><p>元々はバージョンフィールドでしたが、その用途は時間とともに進化しています</p></td>
</tr>
<tr>
<td><p>32 バイト</p></td>
<td><p>前のブロックハッシュ</p></td>
<td><p>チェーン内の前の（親）ブロックのハッシュ</p></td>
</tr>
<tr>
<td><p>32 バイト</p></td>
<td><p>マークルルート</p></td>
<td><p>このブロックのトランザクションのマークルツリーのルートハッシュ</p></td>
</tr>
<tr>
<td><p>4 バイト</p></td>
<td><p>タイムスタンプ</p></td>
<td><p>このブロックの概算作成時間（Unix エポック時間）</p></td>
</tr>
<tr>
<td><p>4 バイト</p></td>
<td><p>ターゲット</p></td>
<td><p>このブロックのプルーフ・オブ・ワークターゲットのコンパクトなエンコーディング</p></td>
</tr>
<tr>
<td><p>4 バイト</p></td>
<td><p>ナンス</p></td>
<td><p>プルーフ・オブ・ワークアルゴリズムに使用される任意のデータ</p></td>
</tr>
</tbody>
</table>
++++

ナンス、ターゲット、およびタイムスタンプはマイニングプロセスで使用され、<<mining>> で詳しく説明します。

[[block_hash]]
=== ブロック識別子：ブロックヘッダーハッシュとブロック高

ブロックの主な識別子は、その暗号学的ハッシュです。これは、ブロックヘッダーを SHA256 アルゴリズムで 2 回ハッシュすることによって行われるコミットメントです。結果として得られる 32 バイトのハッシュは _ブロックハッシュ_ と呼ばれますが、より正確には _ブロックヘッダーハッシュ_ です。pass:[<span class="keep-together">なぜなら、計算に使用されるのはブロックヘッダーのみだからです。例えば、</span>] +000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f+ は、ビットコインのブロックチェーン上の最初のブロックのブロックハッシュです。ブロックハッシュはブロックを一意かつ明確に識別し、ブロックヘッダーを単にハッシュすることで任意のノードによって独立して導出できます。

ブロックハッシュは実際にはブロックのデータ構造内に含まれていないことに注意してください。代わりに、ブロックハッシュはネットワークからブロックを受信した際に各ノードによって計算されます。ブロックハッシュは、インデックス作成やディスクからのブロックの高速な取得を容易にするために、ブロックのメタデータの一部として別のデータベーステーブルに保存されることがあります。

ブロックを識別する第二の方法は、ブロックチェーン内での位置によるもので、これは pass:[<span class="keep-together"><em>ブロック高</em> と呼ばれます。ジェネシスブロックはブロック高 0 (ゼロ) にあり、</span>] pass:[<span class="keep-together">次のブロックハッシュによって以前に参照された同じブロックです</span>] +000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f+。したがって、ブロックはブロックハッシュを参照するか、ブロック高を参照するかの二つの方法で識別できます。最初のブロックの「上」に追加される各後続のブロックは、ブロックチェーン内で「上」に一つ位置します。これは、箱が一つの上に積み重ねられているようなものです。この本の執筆中の 2023 年中頃には、ブロック高 800,000 に達しており、2009 年 1 月に作成された最初のブロックの上に 800,000 個のブロックが積み重ねられていることを意味します。

ブロックハッシュとは異なり、ブロック高は一意の識別子ではありません。単一のブロックは常に特定の不変のブロック高を持ちますが、その逆は真ではありません。ブロック高は常に単一のブロックを識別するわけではありません。二つ以上のブロックが同じブロック高を持ち、ブロックチェーン内で同じ位置を競うことがあります。このシナリオについては、セクション <<forks>> で詳しく説明されています。初期のブロックでは、ブロック高もブロックのデータ構造の一部ではなく、ブロック内に保存されていませんでした。各ノードは、ビットコインネットワークから受信した際に、ブロックチェーン内でのブロックの位置 (高さ) を動的に識別しました。後のプロトコル変更 (BIP34) により、ブロック高がコインベーストランザクションに含まれるようになりましたが、その目的は各ブロックが異なるコインベーストランザクションを持つことを保証するためでした。ノードは依然としてコインベースフィールドを検証するためにブロックの高さを動的に識別する必要があります。ブロック高は、インデックス付きデータベーステーブルのメタデータとして保存され、高速な取得が可能になることもあります。

[TIP]
====
ブロックの _ブロックハッシュ_ は常に単一のブロックを一意に識別します。ブロックには常に特定の _ブロック高_ もあります。しかし、特定のブロック高が単一のブロックを識別するとは限りません。むしろ、2つ以上のブロックがブロックチェーン内の単一の位置を競うことがあります((("ブロック", "識別子", startref="block-identify")))((("ブロックヘッダハッシュ", startref="block-header-hash")))((("ブロック高", startref="block-height")))。
====

=== ジェネシスブロック

ブロックチェーン内の最初のブロック((("ブロックチェーン", "ジェネシスブロック", id="blockchain-genesis")))((("ジェネシスブロック", id="genesis-block")))((("Bitcoin Core", "ジェネシスブロック", id="bitcoin-core-genesis")))は _ジェネシスブロック_ と呼ばれ、2009年に作成されました。これはブロックチェーン内のすべてのブロックの共通の祖先であり、任意のブロックから始めて時間を遡ってチェーンをたどると、最終的にジェネシスブロックに到達します。

すべてのノードは常に少なくとも1つのブロックを持つブロックチェーンから始まります。なぜなら、ジェネシスブロックは Bitcoin Core 内に静的にエンコードされており、変更することができないからです。すべてのノードは常にジェネシスブロックのハッシュと構造、作成された固定時間、さらにはその中の単一のトランザクションを「知って」います。したがって、すべてのノードは信頼できるブロックチェーンを構築するための安全な「ルート」としての出発点を持っています。

Bitcoin Core クライアント内に静的にエンコードされたジェネシスブロックを以下で確認してください：
https://oreil.ly/FqPW5[_chainparams.cpp_]

以下の識別子ハッシュはジェネシスブロックに属します：

----
000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f
----

このブロックハッシュをほぼすべてのブロックエクスプローラウェブサイト（例えば _blockstream.info_）で検索すると、このブロックの内容を説明するページが見つかり、そのハッシュを含む URL が表示されます：

[quote]
____
https://blockstream.info/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f
____

あるいは、コマンドラインで Bitcoin Core を使用してブロックを取得することもできます：

----
$ bitcoin-cli getblock \
  000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f
----
[source,json]
----
{
  "hash": "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f",
  "confirmations": 790496,
  "height": 0,
  "version": 1,
  "versionHex": "00000001",
  "merkleroot": "4a5e1e4baab89f3a32518a88c3[...]76673e2cc77ab2127b7afdeda33b",
  "time": 1231006505,
  "mediantime": 1231006505,
  "nonce": 2083236893,
  "bits": "1d00ffff",
  "difficulty": 1,
  "chainwork": "[...]000000000000000000000000000000000000000000000100010001",
  "nTx": 1,
  "nextblockhash": "00000000839a8e6886ab5951d7[...]fc90947ee320161bbf18eb6048",
  "strippedsize": 285,
  "size": 285,
  "weight": 1140,
  "tx": [
    "4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b"
  ]
}
----

ジェネシスブロックにはメッセージが含まれています。コインベーストランザクションの入力には「The Times 03/Jan/2009 Chancellor on brink of second bailout for banks.」というテキストが含まれています。このメッセージは、イギリスの新聞 _The Times_ の見出しを引用することで、このブロックが作成された最も早い日付の証拠を提供することを意図していました。また、独立した通貨システムの重要性を皮肉を込めて思い出させる役割も果たしています。ビットコインの立ち上げは、前例のない世界的な金融危機と同時に行われました。このメッセージは、ビットコインの創設者であるサトシ・ナカモトによって最初のブロックに埋め込まれました。

=== ブロックチェーンにおけるブロックのリンク

ビットコインのフルノードは、ジェネシスブロックの後に続くブロックチェーン内のすべてのブロックを検証します。ノードのローカルなブロックチェーンのビューは、新しいブロックが見つかりチェーンを拡張するたびに常に更新されます。ノードがネットワークから受信したブロックを受け取ると、これらのブロックを検証し、既存のブロックチェーンのビューにリンクします。リンクを確立するために、ノードは受信したブロックヘッダを調べ、「前のブロックハッシュ」を探します。

たとえば、ノードがローカルのブロックチェーンコピーに 277,314 ブロックを持っていると仮定します。ノードが知っている最後のブロックは 277,314 ブロックで、そのブロックヘッダハッシュは次のとおりです：

----
00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249
----

その後、ビットコインノードはネットワークから新しいブロックを受信し、次のように解析します：

[source,json]
----
{
    "size" : 43560,
    "version" : 2,
    "previousblockhash" :
        "00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249",
    "merkleroot" :
        "5e049f4030e0ab2debb92378f53c0a6e09548aea083f3ab25e1d94ea1155e29d",
    "time" : 1388185038,
    "difficulty" : 1180923195.25802612,
    "nonce" : 4215469401,
    "tx" : [
        "257e7497fb8bc68421eb2c7b699dbab234831600e7352f0d9e6522c7cf3f6c77",
        "[... many more transactions omitted ...]",
        "05cfd38f6ae6aa83674cc99e4d75a1458c165b7ab84725eda41d018a09176634"
    ]
}
----

この新しいブロックを見て、ノードは +previousblockhash+ フィールドを見つけます。これは親ブロックのハッシュを含んでいます。これはノードが知っているハッシュであり、高さ 277,314 のチェーン上の最後のブロックのものです。したがって、この新しいブロックはチェーン上の最後のブロックの子であり、既存のブロックチェーンを拡張します。ノードはこの新しいブロックをチェーンの末尾に追加し、ブロックチェーンを新しい高さ 277,315 で長くします。<<chain_of_blocks>> は、+previousblockhash+ フィールドで参照によってリンクされた 3 つのブロックのチェーンを示しています。

[[chain_of_blocks]]
.各ブロックが前のブロックヘッダーハッシュを参照することでチェーンにリンクされています。
image::images/mbc3_1101.png[]

[[merkle_trees]]
=== マークルツリー

ビットコインブロックチェーン内の各ブロック((("ブロックチェーン", "マークルツリー", id="blockchain-merkle")))((("マークルツリー", id="merkle-tree-explain")))は、ブロック内のすべてのトランザクションの要約を _マークルツリー_ を使用して含んでいます。

_マークルツリー_ は、_バイナリハッシュツリー_ としても知られ、((("バイナリハッシュツリー")))大規模なデータセットの整合性を効率的に要約および検証するために使用されるデータ構造です。マークルツリーは暗号学的ハッシュを含むバイナリツリーです。「ツリー」という用語は、コンピュータサイエンスで分岐するデータ構造を説明するために使用されますが、これらのツリーは通常、図では「ルート」が上部にあり、「葉」が下部にある逆さまに表示されます。以下の例で確認できます。

マークルツリーはビットコインで、ブロック内のすべてのトランザクションを要約し、トランザクション全体のセットに対する全体的なコミットメントを生成し、トランザクションがブロックに含まれているかどうかを非常に効率的に検証するプロセスを可能にします。マークルツリーは、要素のペアを再帰的にハッシュして、_ルート_ または _マークルルート_ と呼ばれる 1 つのハッシュになるまで構築されます。ビットコインのマークルツリーで使用される暗号学的ハッシュアルゴリズムは、SHA256 を 2 回適用したもので、ダブル SHA256 とも呼ばれます。

N 個のデータ要素がハッシュ化され、マークルツリーにまとめられると、約 +log~2~(N)+ 回の計算で任意のデータ要素がツリーに含まれているかどうかを確認できます。これにより、非常に効率的なデータ構造となります。

マークルツリーは下から上に構築されます。次の例では、A、B、C、D の 4 つのトランザクションから始め、これらがマークルツリーの_葉_を形成します（<<simple_merkle>> を参照）。トランザクション自体はマークルツリーに保存されません。代わりに、そのデータがハッシュ化され、結果のハッシュが各葉ノードに H~A~、H~B~、H~C~、H~D~ として保存されます。

++++
<pre data-type="codelisting">
H<sub>A</sub> = SHA256(SHA256(Transaction A))
</pre>
++++

連続するペアの葉ノードは、2 つのハッシュを連結してハッシュ化することで親ノードにまとめられます。例えば、親ノード H~AB~ を構築するには、子ノードの 32 バイトのハッシュを連結して 64 バイトの文字列を作成します。その文字列を二重ハッシュして親ノードのハッシュを生成します。

++++
<pre data-type="codelisting">
H<sub>AB</sub> = SHA256(SHA256(H<sub>A</sub> || H<sub>B</sub>))
</pre>
++++

このプロセスは、最上部に 1 つのノード、つまりマークルルートと呼ばれるノードが残るまで続きます。その 32 バイトのハッシュはブロックヘッダに保存され、4 つのトランザクションすべてのデータを要約します。<<simple_merkle>> は、ノードのペアごとのハッシュによってルートが計算される様子を示しています。

[[simple_merkle]]
.マークルツリー内のノードの計算。
image::images/mbc3_1102.png["merkle_tree"]

マークルツリーは二分木であるため、葉ノードの数は偶数である必要があります。要約するトランザクションの数が奇数の場合、最後のトランザクションハッシュが複製され、偶数の葉ノードが作成されます。これを_バランスツリー_とも呼びます（((("balanced merkle trees")))）。これは <<merkle_tree_odd>> に示されており、トランザクション C が複製されています。同様に、任意のレベルで処理するハッシュの数が奇数の場合、最後のハッシュが複製されます。

[[merkle_tree_odd]]
.データ要素を偶数にするために 1 つのデータ要素を複製します。
image::images/mbc3_1103.png["merkle_tree_odd"]


.A Design Flaw in Bitcoin's Merkle Tree
****
Bitcoin Core のソースコードにある拡張コメントを、ここに若干の修正を加えて再現しています。これは、Bitcoin のマークルツリーにおける奇数要素の重複に関する設計上の重大な問題を説明しています。

____
警告！暗号について学んでいる、またはマークルツリーを使用する新しいシステムを設計しているためにこれを読んでいる場合、次のマークルツリーアルゴリズムには、重複する txid に関連する重大な欠陥があり、脆弱性 (CVE-2012-2459) を引き起こすことを覚えておいてください。

その理由は、特定のレベルでリスト内のハッシュの数が奇数の場合、次のレベルを計算する前に最後のハッシュが重複するためです (これはマークルツリーでは珍しいことです)。これにより、特定のトランザクションのシーケンスが同じマークルルートを導くことになります。例えば、<<cve_tree>> にある 2 つのツリーです。

[[cve_tree]]
[role="width-90"]
.異なる数のリーフを持つが同じルートを持つ 2 つの Bitcoin スタイルのマークルツリー。
image::images/mbc3_1104.png["異なる数のリーフを持つが同じルートを持つ 2 つの Bitcoin スタイルのマークルツリー"]

トランザクションリスト [1,2,3,4,5,6] と [1,2,3,4,5,6,5,6] (5 と 6 が繰り返されている) は、同じルートハッシュ A を生成します (なぜなら (F) と (F,F) のハッシュが C だからです)。

この脆弱性は、そのようなトランザクションリストを持つブロックを、重複なしで元のブロックと同じマークルルートおよび同じブロックハッシュで送信できることから生じ、検証に失敗します。しかし、受信ノードがそのブロックを永久に無効とマークすると、同じブロックの未修正 (したがって潜在的に有効な) バージョンを受け入れることができなくなります。これを防ぐために、リストの最後で 2 つの同一のハッシュを一緒にハッシュしようとする場合を検出し、それを無効なマークルルートを持つブロックと同様に扱います。二重 SHA256 の衝突がないと仮定すると、これはマークルルートに影響を与えずにトランザクションを変更する既知のすべての方法を検出します。

++++
<p data-type="attribution">Bitcoin Core <em>src/consensus/merkle.cpp</em></p>
++++
____

****

[role="less_space pagebreak-before"]
4 つのトランザクションからツリーを構築する同じ方法は、任意のサイズのツリーを構築するために一般化できます。Bitcoin では、1 つのブロックに数千のトランザクションが含まれることが一般的であり、それらはまったく同じ方法で要約され、単一のマークルルートとしてわずか 32 バイトのデータを生成します。<<merkle_tree_large>> では、16 のトランザクションから構築されたツリーを見ることができます。図ではルートがリーフノードよりも大きく見えますが、実際には同じサイズで、わずか 32 バイトです。ブロックに 1 つのトランザクションがあるか、1 万のトランザクションがあるかにかかわらず、マークルルートは常にそれらを 32 バイトに要約します。

特定のトランザクションがブロックに含まれていることを証明するために、ノードは約 +log~2~(N)+ 個の 32 バイトのハッシュを生成するだけで済みます。これにより、特定のトランザクションをツリーのルートに接続する _認証パス_ または _マークルパス_ を構成します。これは、トランザクションの数が増加するにつれて特に重要です。なぜなら、トランザクションの数の 2 を底とする対数は、はるかにゆっくりと増加するからです。これにより、Bitcoin ノードは 10 または 12 個のハッシュ (320–384 バイト) のパスを効率的に生成でき、マルチメガバイトのブロック内の千以上のトランザクションのうちの 1 つのトランザクションの証明を提供できます。

[[merkle_tree_large]]
.多くのデータ要素を要約するマークルツリー。
image::images/mbc3_1105.png["merkle_tree_large"]

<<merkle_tree_path>> では、ノードはトランザクション K がブロックに含まれていることを証明するために、4 つの 32 バイトのハッシュ (合計 128 バイト) だけのマークルパスを生成できます。このパスは、4 つのハッシュ (背景がシェードで示されています) H~L~、H~IJ~、H~MNOP~、および H~ABCDEFGH~ で構成されています。これらの 4 つのハッシュが認証パスとして提供されることで、どのノードも H~K~ (図の下部で黒い背景) がマークルルートに含まれていることを、4 つの追加のペアワイズハッシュ H~KL~、H~IJKL~、H~IJKLMNOP~、およびマークルツリーのルート (図で破線で囲まれています) を計算することで証明できます。

[[merkle_tree_path]]
.データ要素の包含を証明するために使用されるマークルパス。
image::images/mbc3_1106.png["merkle_tree_path"]

マークルツリーの効率性は、規模が大きくなるにつれて明らかになります。最大のブロックは 4,000,000 バイトでほぼ 16,000 件のトランザクションを保持できますが、それら 16,000 件のトランザクションのいずれかがそのブロックの一部であることを証明するには、トランザクションのコピー、80 バイトのブロックヘッダのコピー、および 448 バイトのマークル証明が必要なだけです。これにより、最大の証明は、最大の Bitcoin ブロックのほぼ 10,000 分の 1 のサイズになります。

### マークルツリーと軽量クライアント {#merkle-trees-and-lightweight-clients}

マークルツリーは、軽量クライアントで広く使用されています。軽量クライアントはすべてのトランザクションを持っておらず、フルブロックをダウンロードせず、ブロックヘッダのみをダウンロードします。ブロック内のすべてのトランザクションをダウンロードせずに、トランザクションがブロックに含まれていることを検証するために、マークルパスを使用します。

たとえば、ウォレットに含まれるアドレスへの入金に関心がある軽量クライアントを考えてみましょう。軽量クライアントは、ピアへの接続にブルームフィルタ（<<bloom_filters>> を参照）を設定し、受信するトランザクションを関心のあるアドレスを含むものに限定します。ピアがブルームフィルタに一致するトランザクションを見つけた場合、そのブロックを +merkleblock+ メッセージを使って送信します。+merkleblock+ メッセージには、ブロックヘッダと、関心のあるトランザクションをブロック内のマークルルートにリンクするマークルパスが含まれています。軽量クライアントはこのマークルパスを使用して、トランザクションをブロックヘッダに接続し、そのトランザクションがブロックに含まれていることを確認できます。軽量クライアントはまた、ブロックヘッダを使用してブロックをブロックチェーンの残り部分にリンクします。トランザクションとブロック間、およびブロックとブロックチェーン間のこれら二つのリンクの組み合わせにより、トランザクションがブロックチェーンに記録されていることが証明されます。全体として、軽量クライアントはブロックヘッダとマークルパスのデータを 1 キロバイト未満しか受信しません。これは、フルブロック（現在約 2 MB）((("blockchain", "merkle trees", startref="blockchain-merkle")))((("merkle trees", startref="merkle-tree-explain")))よりも千倍以上少ないデータ量です。

### Bitcoin's Test Blockchains

ビットコインで使用されるブロックチェーンが一つだけではないことに驚くかもしれません。2009 年 1 月 3 日にサトシ・ナカモトによって作成された、私たちがこの章で学んだジェネシスブロックを持つ「メイン」のビットコインブロックチェーンは、_mainnet_ と呼ばれています((("mainnet")))。テスト目的で使用される他のビットコインブロックチェーンもあります。現在、_testnet_、_signet_、_regtest_ があります。それぞれを順に見ていきましょう。

#### Testnet: Bitcoin's Testing Playground

Testnet は、テスト目的で使用されるテストブロックチェーン、ネットワーク、および通貨の名前です((("blockchain", "test blockchains", "testnet", id="blockchain-test-testnet")))((("test blockchains", "testnet", id="test-block-testnet")))((("testnet", id="testnet")))。testnet は、ウォレット、テストビットコイン（testnet コイン）、マイニング、および mainnet の他のすべての機能を備えた完全なライブ P2P ネットワークです。最も重要な違いは、testnet コインが無価値であることを意図している点です。


ビットコインのメインネットでの本番利用を目的としたソフトウェア開発は、まずテストネットでテストコインを使ってテストすることができます。これにより、バグによる金銭的損失から開発者を守り、バグによる意図しない動作からネットワークを保護します。

現在のテストネットは _testnet3_ と呼ばれています。これはテストネットの3回目の反復で、前のテストネットから難易度をリセットするために2011年2月に再起動されました。Testnet3は大規模なブロックチェーンで、2023年には30 GBを超えています。完全に同期するには時間がかかり、コンピュータのリソースを消費します。メインネットほどではありませんが、「軽量」とも言えません。

[TIP]
====
この本で説明されているテストネットや他のテストブロックチェーンは、誤って本物のビットコインをテストアドレスに送ってしまうのを防ぐために、メインネットのアドレスとは異なるアドレスプレフィックスを使用しています。メインネットのアドレスは +1+、+3+、または +bc1+ で始まります。この本で言及されているテストネットワークのアドレスは +m+、+n+、または +tb1+ で始まります。他のテストネットワークやテストネットワーク上で開発されている新しいプロトコルは、他のアドレスプレフィックスや変更を使用することがあります。
====

===== テストネットの使用

Bitcoin Core は、他の多くのビットコインプログラムと同様に、メインネットの代わりにテストネットでの操作を完全にサポートしています。Bitcoin Core のすべての機能は、ウォレット、テストネットコインのマイニング、フルテストネットノードの同期を含め、テストネット上で動作します。

[role="less_space pagebreak-before"]
メインネットの代わりにテストネットで Bitcoin Core を起動するには、+testnet+ スイッチを使用します。

----
$ bitcoind -testnet
----

ログには、bitcoind がデフォルトの bitcoind ディレクトリの +testnet3+ サブディレクトリに新しいブロックチェーンを構築していることが表示されるはずです。

----
bitcoind: Using data directory /home/username/.bitcoin/testnet3
----

bitcoind に接続するには、+bitcoin-cli+ コマンドラインツールを使用しますが、これもテストネットモードに切り替える必要があります。

----
$ bitcoin-cli -testnet getblockchaininfo
{
  "chain": "test",
  "blocks": 1088,
  "headers": 139999,
  "bestblockhash": "0000000063d29909d475a1c[...]368e56cce5d925097bf3a2084370128",
  "difficulty": 1,
  "mediantime": 1337966158,
  "verificationprogress": 0.001644065914099759,
  "chainwork": "[...]000000000000000000000000000000000000000000044104410441",
  "pruned": false,
  "softforks": [

----
  
テストネット3は、他のフルノード実装（Go で書かれた +btcd+ や JavaScript で書かれた +bcoin+ など）でも実行でき、他のプログラミング言語やフレームワークで実験したり学んだりすることができます。

テストネット3は、メインネットのすべての機能（<<segwit>> や <<taproot>> を参照）をサポートしています。そのため、テストネット3はセグリゲーテッド・ウィットネス機能のテストにも使用できます。

===== テストネットの問題点

テストネットはビットコインと同じデータ構造を使用するだけでなく、ビットコインとほぼ同じプルーフ・オブ・ワーク（PoW）セキュリティメカニズムも使用しています。テストネットの顕著な違いは、最小難易度がビットコインの半分であり、前のブロックのタイムスタンプから20分以上経過している場合、その最小難易度でブロックを含めることが許可されている点です。

残念ながら、ビットコインのPoWセキュリティメカニズムは経済的インセンティブに依存するように設計されていますが、価値を持つことが禁止されているテストブロックチェーンにはそのインセンティブが存在しません。メインネットでは、マイナーはトランザクション手数料を支払うため、ユーザのトランザクションをブロックに含めるインセンティブがあります。しかし、テストネットでは、トランザクションには手数料と呼ばれるものが含まれていますが、それらの手数料には経済的価値がありません。つまり、テストネットのマイナーがトランザクションを含める唯一のインセンティブは、ユーザや開発者がソフトウェアをテストするのを助けたいという理由です。

残念ながら、システムを混乱させることを好む人々は、少なくとも短期的にはより強いインセンティブを感じることがよくあります。PoWマイニングは許可不要で行えるように設計されているため、意図が善意であろうとそうでなかろうと、誰でもマイニングできます。つまり、破壊的なマイナーがユーザのトランザクションを含めずにテストネットで連続して多くのブロックを作成することができます。これらの攻撃が発生すると、テストネットはユーザや開発者にとって使い物にならなくなります。

==== Signet: 権威証明テストネット

許可不要のPoWに依存するシステムが経済的インセンティブを導入せずに高い使用性を提供する方法は知られていません。そのため、ビットコインプロトコルの開発者は代替案を検討し始めました。主な目標は、ソフトウェアが最小限の変更でテストネット上で動作できるように、ビットコインの構造をできるだけ多く保持しつつ、役立つ環境を提供することでした。二次的な目標は、新しいソフトウェアの開発者が簡単に独自のテストネットワークを作成できる再利用可能な設計を作成することでした。

Bitcoin Core やその他のソフトウェアで実装されているソリューションは、BIP325 で定義されている _signet_ と呼ばれます。signet は、各ブロックが信頼できる権限によって承認されたことを証明する（署名など）証拠を含む必要があるテストネットワークです。

Bitcoin のマイニングは許可不要で誰でも行えますが、signet のマイニングは完全に許可制です。許可を得た者だけが行えます。これは Bitcoin のメインネットに対しては全く受け入れられない変更であり、そのようなソフトウェアは誰も使わないでしょうが、コインに価値がなく、ソフトウェアやシステムのテストが唯一の目的であるテストネットでは合理的です。

BIP325 signet は、自分自身で簡単に作成できるように設計されています。他の誰かが運営している signet の運用方法に不満がある場合は、自分自身の signet を開始し、それにソフトウェアを接続することができます。

===== デフォルト signet とカスタム signet

Bitcoin Core は、執筆時点で最も広く使用されていると考えられるデフォルト signet をサポートしています。これは現在、そのプロジェクトの 2 人の貢献者によって運営されています。+signet+ パラメータと他の signet 関連のパラメータなしで Bitcoin Core を起動すると、この signet を使用することになります。

執筆時点で、デフォルト signet は約 150,000 ブロックを持ち、サイズは約 1 ギガバイトです。これは Bitcoin のメインネットと同じ機能をすべてサポートしており、Bitcoin Inquisition プロジェクトを通じて提案されたアップグレードのテストにも使用されています。Bitcoin Inquisition プロジェクトは、signet 上でのみ動作するように設計された Bitcoin Core のソフトウェアフォークです。

異なる signet を使用したい場合は、_カスタム signet_ と呼ばれるものを使用する必要があります。その際には、ブロックが承認されたときに使用されるスクリプト、_チャレンジ_ スクリプトと呼ばれるものを知っておく必要があります。これは標準的な Bitcoin スクリプトであり、マルチシグなどの機能を使用して複数の人がブロックを承認できるようにすることができます。また、カスタム signet 上のピアのアドレスを提供するシードノードに接続する必要があるかもしれません。例えば：

----
bitcoind -signet -signetchallenge=0123...cdef -signetseednode=example.com:1234
----

執筆時点では、マイニングソフトウェアの公開テストは testnet3 で行うことを推奨しており、その他の Bitcoin ソフトウェアの公開テストはデフォルトの signet で行うことを推奨しています。

選択した signet とやり取りするには、testnet を使用したときと同様に、+bitcoin-cli+ に +-signet+ パラメータを使用します。例えば：

----
$ bitcoin-cli -signet getblockchaininfo
{
  "chain": "signet",
  "blocks": 143619,
  "headers": 143619,
  "bestblockhash": "000000c46cb3505ddd296537[...]ad1c5768e2908439382447572a93",
  "difficulty": 0.003020638517858618,
  "time": 1684530244,
  "mediantime": 1684526116,
  "verificationprogress": 0.999997961940662,
  "initialblockdownload": false,
  "chainwork": "[...]000000000000000000000000000000000000000000019ab37d2194",
  "size_on_disk": 769525915,
  "pruned": false,
  "warnings": ""
}
----

==== Regtest: ローカルブロックチェーン

Regtest（「回帰テスト」の略）は、ローカルブロックチェーンをテスト目的で作成できる Bitcoin Core の機能です。signet や testnet3 とは異なり、これらは公開されており共有されるテストブロックチェーンですが、regtest ブロックチェーンはローカルテストのために閉じたシステムとして実行することを意図しています。regtest ブロックチェーンはゼロから起動します。他のノードをネットワークに追加することも、単一のノードで Bitcoin Core ソフトウェアをテストするために実行することもできます。

Bitcoin Core を regtest モードで起動するには、+regtest+ フラグを使用します：

----
$ bitcoind -regtest
----

testnet と同様に、Bitcoin Core はデフォルトディレクトリの _regtest_ サブディレクトリに新しいブロックチェーンを初期化します：

----
bitcoind: Using data directory /home/username/.bitcoin/regtest
----

[role="less_space pagebreak-before"]
コマンドラインツールを使用するには、+regtest+ フラグも指定する必要があります。regtest ブロックチェーンを調べるために +getblockchaininfo+ コマンドを試してみましょう：

----
$ bitcoin-cli -regtest getblockchaininfo
{
  "chain": "regtest",
  "blocks": 0,
  "headers": 0,
  "bestblockhash": "0f9188f13cb7b2c71f2a335e3[...]b436012afca590b1a11466e2206",
  "difficulty": 4.656542373906925e-10,
  "mediantime": 1296688602,
  "verificationprogress": 1,
  "chainwork": "[...]000000000000000000000000000000000000000000000000000002",
  "pruned": false,
  [...]
----

ご覧のとおり、まだブロックはありません。デフォルトのウォレットを作成し、アドレスを取得してから、報酬を得るためにいくつかのブロック (500 ブロック) をマイニングしましょう。

----
$ bitcoin-cli -regtest createwallet ""

$ bitcoin-cli -regtest getnewaddress
bcrt1qwvfhw8pf79kw6tvpmtxyxwcfnd2t4e8v6qfv4a

$ bitcoin-cli -regtest generatetoaddress 500 \
  bcrt1qwvfhw8pf79kw6tvpmtxyxwcfnd2t4e8v6qfv4a
[
  "3153518205e4630d2800a4cb65b9d2691ac68eea99afa7fd36289cb266b9c2c0",
  "621330dd5bdabcc03582b0e49993702a8d4c41df60f729cc81d94b6e3a5b1556",
  "32d3d83538ba128be3ba7f9dbb8d1ef03e1b536f65e8701893f70dcc1fe2dbf2",
  ...,
  "32d55180d010ffebabf1c3231e1666e9eeed02c905195f2568c987c2751623c7"
]
----

これらのブロックをすべてマイニングするのに数秒しかかからないので、テストには非常に便利です。ウォレットの残高を確認すると、最初の 400 ブロックの報酬を獲得したことがわかります (コインベース報酬は 100 ブロック深くなるまで使用できません)。

----
$ bitcoin-cli -regtest getbalance
12462.50000000
----

=== 開発のためのテストブロックチェーンの使用

Bitcoin のさまざまなブロックチェーン (regtest, signet, testnet3, mainnet) は、ビットコイン開発のためのさまざまなテスト環境を提供します。Bitcoin Core や他のフルノードコンセンサスクライアントの開発、ウォレットや取引所、eコマースサイトなどのアプリケーションの開発、さらには新しいスマートコントラクトや複雑なスクリプトの開発を行う場合でも、テストブロックチェーンを使用してください。

テスト用ブロックチェーンを使用して、開発パイプラインを確立することができます。コードを開発する際には、まずローカルで regtest を使ってテストしてください。公開ネットワークで試す準備ができたら、signet または testnet に切り替えて、より多様なコードやアプリケーションが存在する動的な環境にコードをさらします。最終的に、コードが期待通りに動作することに自信が持てたら、mainnet に切り替えて本番環境にデプロイします。変更や改善、バグ修正などを行う際には、再びパイプラインを開始し、まず regtest で各変更をデプロイし、その後 signet または testnet、最終的に本番環境にデプロイします。

ブロックチェーンがどのようなデータを含んでいるか、そして暗号学的コミットメントがどのようにしてさまざまな部分を安全に結びつけているかを理解したので、次に計算上のセキュリティを提供し、上に構築されたすべてのブロックを無効にせずにブロックを変更できないようにする特別なコミットメント、つまり Bitcoin のマイニング機能について見ていきます。
