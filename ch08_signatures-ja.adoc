[[c_signatures]]
== デジタル署名

現在、Bitcoin では 2 つの署名アルゴリズムが使用されています。それは、_schnorr 署名アルゴリズム_ と _楕円曲線デジタル署名アルゴリズム_ (_ECDSA_) です。これらのアルゴリズムは、<<elliptic_curve>> で説明されているように、楕円曲線の秘密鍵/公開鍵ペアに基づくデジタル署名に使用されます。これらは、segwit v0 P2WPKH 出力の消費、segwit v1 P2TR キーパス消費、およびスクリプト関数 +OP_CHECKSIG+、+OP_CHECKSIGVERIFY+、+OP_CHECKMULTISIG+、[.keep-together]#+OP_CHECKMULTISIGVERIFY+、# および +OP_CHECKSIGADD+ によって使用されます。これらのいずれかが実行されるたびに、署名が提供されなければなりません。

デジタル署名は Bitcoin において 3 つの目的を果たします。まず、署名は秘密鍵の管理者、すなわち資金の所有者がその資金の消費を_承認_したことを証明します。次に、承認の証拠は_否認できない_（非否認性）ものです。第三に、承認された取引が認証されていない第三者によって変更されないこと、つまりその_完全性_が保たれていることを示します。

[NOTE]
====
各トランザクション入力とそれに含まれる可能性のある署名は、他の入力や署名とは_完全に_独立しています。複数の当事者が協力してトランザクションを構築し、それぞれが 1 つの入力にのみ署名することができます。この事実を利用して、プライバシーのために複数の当事者が関与するトランザクションを作成するプロトコルがいくつかあります。
====

この章では、デジタル署名がどのように機能するか、そして秘密鍵を明かすことなくその管理権を証明する方法について見ていきます。

[role="less_space pagebreak-before"]
=== デジタル署名の仕組み

デジタル署名は 2 つの部分から成ります。最初の部分は、秘密鍵（署名鍵）を使用してメッセージ（トランザクション）に署名を作成するためのアルゴリズムです。第二の部分は、メッセージと対応する公開鍵を与えられたときに、誰でも署名を検証できるアルゴリズムです。


==== デジタル署名の作成

Bitcoin におけるデジタル署名アルゴリズムの使用では、署名される「メッセージ」はトランザクション、またはより正確にはトランザクション内の特定のデータのサブセットのハッシュである _コミットメントハッシュ_（<<sighash_types>> を参照）と呼ばれるものです。署名鍵はユーザの秘密鍵です。その結果が署名となります：

[latexmath]
++++
\begin{equation}
Sig = F_{sig}(F_{hash}(m), x)
\end{equation}
++++

ここで：

* _x_ は署名用の秘密鍵
* _m_ は署名するメッセージ、コミットメントハッシュ（トランザクションの一部など）
* _F_~_hash_~ はハッシュ関数
* _F_~_sig_~ は署名アルゴリズム
* _Sig_ は結果として得られる署名

schnorr 署名と ECDSA 署名の数学的詳細については、<<schnorr_signatures>> と <<ecdsa_signatures>> を参照してください。

schnorr 署名と ECDSA 署名の両方で、関数 _F_~_sig_~ は 2 つの値から構成される署名 +Sig+ を生成します。異なるアルゴリズムではこの 2 つの値に違いがあり、これについては後で詳しく説明します。2 つの値が計算された後、それらはバイトストリームにシリアライズされます。ECDSA 署名の場合、エンコーディングには _Distinguished Encoding Rules_、または _DER_ と呼ばれる国際標準のエンコーディングスキームが使用されます。schnorr 署名の場合は、よりシンプルなシリアライズ形式が使用されます。

==== 署名の検証

署名検証アルゴリズムは、メッセージ（トランザクションの一部と関連データのハッシュ）、署名者の公開鍵、および署名を受け取り、このメッセージと公開鍵に対して署名が有効である場合に ++TRUE++ を返します。

署名を検証するには、署名、シリアライズされたトランザクション、消費される出力に関するデータ、および署名の作成に使用された秘密鍵に対応する公開鍵が必要です。基本的に、署名の検証は「この公開鍵を生成した秘密鍵のコントローラだけが、このトランザクションに対してこの署名を生成できた」ということを意味します。

[[sighash_types]]
==== 署名ハッシュタイプ (SIGHASH)

デジタル署名（Bitcoin の場合はトランザクションそのものに適用されます）は、署名者が特定のトランザクションデータに対して _コミットメント_ を示すものです。最も単純な形では、署名はほぼすべてのトランザクションに適用され、すべての入力、出力、およびその他のトランザクションフィールドにコミットします。しかし、署名はトランザクション内のデータの一部にのみコミットすることもでき、これはこのセクションで見るように、さまざまなシナリオで役立ちます。

Bitcoin の署名には、+SIGHASH+ フラグを使用して、トランザクションのどの部分のデータが秘密鍵によって署名されたハッシュに含まれるかを示す方法があります。+SIGHASH+ フラグは署名に追加される 1 バイトで、すべての署名には明示的または暗黙的な +SIGHASH+ フラグがあります。このフラグは入力ごとに異なる場合があります。3 つの署名された入力を持つトランザクションは、異なる +SIGHASH+ フラグを持つ 3 つの署名を持ち、それぞれの署名がトランザクションの異なる部分に署名（コミット）します。

各入力には 1 つ以上の署名が含まれることがあります。その結果、1 つの入力に異なる +SIGHASH+ フラグを持つ署名があり、トランザクションの異なる部分にコミットすることがあります。また、Bitcoin トランザクションには異なる「所有者」からの入力が含まれることがあり、部分的に構築されたトランザクションで 1 つの入力にのみ署名し、他の人と協力して有効なトランザクションを作成するために必要なすべての署名を集めることがあります。多くの +SIGHASH+ フラグタイプは、Bitcoin ネットワーク外で複数の参加者が協力して部分的に署名されたトランザクションを更新することを考えるときにのみ意味を持ちます。

+SIGHASH+ フラグには、+ALL+、+NONE+、+SINGLE+ の 3 つがあります。詳細は <<sighash_types_and_their>> を参照してください。

++++
<table id="sighash_types_and_their">
<caption>
<span class="plain"><code>SIGHASH</code></span> タイプとその意味</caption>
<thead>
<tr>
<th><code>SIGHASH</code> フラグ</th>
<th>値</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>ALL</code></p></td>
<td><p><code>0x01</code></p></td>
<td><p>署名はすべての入力と出力に適用されます</p></td>
</tr>
<tr>
<td><p><code>NONE</code></p></td>
<td><p><code>0x02</code></p></td>
<td><p>署名はすべての入力に適用され、出力には適用されません</p></td>
</tr>
<tr>
<td><p><code>SINGLE</code></p></td>
<td><p><code>0x03</code></p></td>
<td><p>署名はすべての入力に適用されますが、署名された入力と同じインデックス番号を持つ 1 つの出力にのみ適用されます</p></td>
</tr>
</tbody>
</table>
++++

さらに、修飾子フラグとして +SIGHASH_ANYONECANPAY+ があります。これは前述の各フラグと組み合わせることができます。+ANYONECANPAY+ が設定されている場合、1 つの入力のみが署名され、残りの入力（およびそのシーケンス番号）は変更可能な状態に残されます。+ANYONECANPAY+ の値は +0x80+ であり、ビット単位の OR 演算によって適用され、<<sighash_types_with_modifiers>> に示すようにフラグが組み合わされます。

[role="less_space pagebreak-before"]
++++
<table id="sighash_types_with_modifiers">
<caption>
<span class="plain"><code>SIGHASH</code></span> types with modifiers and their meanings</caption>
<thead>
<tr>
<th><code>SIGHASH</code> flag</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>ALL|ANYONECANPAY</code></p></td>
<td><p><code>0x81</code></p></td>
<td><p>署名は 1 つの入力とすべての出力に適用されます</p></td>
</tr>
<tr>
<td><p><code>NONE|ANYONECANPAY</code></p></td>
<td><p><code>0x82</code></p></td>
<td><p>署名は 1 つの入力に適用され、出力には適用されません</p></td>
</tr>
<tr>
<td><p><code>SINGLE|ANYONECANPAY</code></p></td>
<td><p><code>0x83</code></p></td>
<td><p>署名は 1 つの入力と同じインデックス番号の出力に適用されます</p></td>
</tr>
</tbody>
</table>
++++

+SIGHASH+ フラグが署名および検証時に適用される方法は、トランザクションのコピーが作成され、その中の特定のフィールドが省略または切り詰められる（長さをゼロに設定して空にする）というものです。結果として得られるトランザクションはシリアライズされます。+SIGHASH+ フラグはシリアライズされたトランザクションデータに含まれ、その結果がハッシュ化されます。このハッシュダイジェスト自体が署名される「メッセージ」です。使用される +SIGHASH+ フラグによって、トランザクションの異なる部分が含まれます。+SIGHASH+ フラグ自体を含めることで、署名は +SIGHASH+ タイプにもコミットされるため、変更できません（例：マイナーによって）。

<<serialization_of_signatures_der>> では、DER エンコードされた署名の最後の部分が +01+ であり、これは ECDSA 署名の +SIGHASH_ALL+ フラグであることがわかります。これによりトランザクションデータがロックされ、アリスの署名はすべての入力と出力の状態にコミットされます。これは最も一般的な署名形式です。

いくつかの他の +SIGHASH+ タイプと、それらが実際にどのように使用されるかを見てみましょう：

+ALL|ANYONECANPAY+ :: この構造は「クラウドファンディング」スタイルのトランザクションを作成するために使用できます。資金を集めようとしている人は、単一の出力を持つトランザクションを構築できます。この単一の出力は、資金調達者に「目標」金額を支払います。このようなトランザクションは、入力がないため明らかに無効です。しかし、他の人が自分の入力を寄付として追加することで修正できます。彼らは自分の入力を +ALL|ANYONECANPAY+ で署名します。出力の価値に達するまで十分な入力が集まらない限り、トランザクションは無効です。各寄付は「誓約」であり、目標金額全体が集まるまで資金調達者が集めることはできません。残念ながら、このプロトコルは資金調達者が自分自身の入力（または資金を貸してくれる誰かからの入力）を追加することで回避され、指定された価値に達していなくても寄付を集めることができます。

+NONE+ :: この構造は、特定の金額の「持参人払い小切手」または「白紙小切手」を作成するために使用できます。すべての入力にコミットしますが、出力を変更することができます。誰でも自分のビットコインアドレスを出力スクリプトに書き込むことができます。これだけでは、どのマイナーも出力先を変更して自分のものにすることができますが、トランザクション内の他の必要な署名が +SIGHASH_ALL+ または出力にコミットする別のタイプを使用している場合、それらの支出者が第三者（マイナーなど）が出力を変更することなく、出力先を変更することができます。

+NONE|ANYONECANPAY+ :: この構造は「ダストコレクター」を構築するために使用できます。ウォレットに小さな UTXO を持っているユーザは、UTXO の価値を超える手数料のコストなしにこれらを使うことができません。<<uneconomical_outputs>> を参照してください。このタイプの署名を使用すると、非経済的な UTXO を誰でも集約して、いつでも使用することができます。

+SIGHASH+ システムを変更または拡張するためのいくつかの提案があります。この記事執筆時点で最も広く議論されている提案は BIP118 で、これは新しい sighash フラグを 2 つ追加することを提案しています。+SIGHASH_ANYPREVOUT+ を使用した署名は、入力のアウトポイントフィールドにコミットせず、特定のウィットネスプログラムの以前の出力を使用して支出することができます。例えば、アリスが同じウィットネスプログラム（例：彼女のウォレットからの単一の署名を要求する）に対して同じ金額の 2 つの出力を受け取った場合、どちらかの出力を支出するための +SIGHASH_ANYPREVOUT+ 署名をコピーして、同じ出力先に他の出力を支出するために使用することができます。

+SIGHASH_ANYPREVOUTANYSCRIPT+ を使用した署名は、アウトポイント、金額、ウィットネスプログラム、またはタップルートのマークルツリー（スクリプトツリー）の特定のリーフにコミットしないため、署名が満たすことができる任意の以前の出力を使用して支出することができます。例えば、アリスが異なる金額と異なるウィットネスプログラム（例：1つは単一の署名を要求し、もう1つは彼女の署名と他のデータを要求する）で2つの出力を受け取った場合、これらの出力のいずれかを支出するための +SIGHASH_ANYPREVOUTANYSCRIPT+ 署名はコピーされ、同じ宛先に他の出力を支出するために使用される可能性があります（2番目の出力の追加データが知られていると仮定します）。

2つの ++SIGHASH_ANYPREVOUT++ オプコードの主な期待される使用法は、ライトニングネットワーク（LN）で使用されるような改善されたペイメントチャネルですが、他にもいくつかの使用法が説明されています。

[NOTE]
====
+SIGHASH+ フラグがユーザのウォレットアプリケーションでオプションとして提示されることはあまりありません。シンプルなウォレットアプリケーションは [.keep-together]#+SIGHASH_ALL+# フラグで署名します。LNノードのようなより高度なアプリケーションは、代替の +SIGHASH+ フラグを使用することがありますが、代替フラグの影響を理解するために広範にレビューされたプロトコルを使用します。
====

[[schnorr_signatures]]
=== シュノア署名

1989年に、クラウス・シュノアは彼の名前と同義となった署名アルゴリズムを説明する論文を発表しました。このアルゴリズムは、ビットコインや他の多くのアプリケーションが使用する楕円曲線暗号（ECC）に特有のものではありませんが、今日ではECCと最も強く関連付けられているかもしれません。シュノア署名にはいくつかの優れた特性があります。

証明可能なセキュリティ：
  シュノア署名のセキュリティの数学的証明は、離散対数問題（DLP）の解決の難しさ、特にビットコインの楕円曲線（EC）に依存し、ハッシュ関数（ビットコインで使用されるSHA256関数のような）が予測不可能な値を生成する能力、ランダムオラクルモデル（ROM）に依存します。他の署名アルゴリズムは追加の依存関係を持つか、ECC-シュノアと同等のセキュリティを得るためにより大きな公開鍵や署名を必要とします（脅威が古典的なコンピュータと定義される場合；他のアルゴリズムは量子コンピュータに対してより効率的なセキュリティを提供するかもしれません）。

Linearity::
  Schnorr 署名には数学者が _linearity_（線形性）と呼ぶ特性があります。これは、特定の2つの特性を持つ関数に適用されます。最初の特性は、2つ以上の変数を合計してからその合計に関数を適用することが、各変数に独立して関数を適用してから結果を合計することと同じ値を生成するというものです。例えば、_f(x_ + _y_ + _z)_ == _f(x)_ + _f(y)_ + _f(z)_ です。この特性は _additivity_（加法性）と呼ばれます。2つ目の特性は、変数を掛けてからその積に関数を適用することが、変数に関数を適用してから同じ量で掛けることと同じ値を生成するというものです。例えば、_f(a_ × _x)_ == _a_ × _f(x)_ です。この特性は _homogeneity of degree 1_（1次の同次性）と呼ばれます。
+
暗号操作において、いくつかの関数は秘密（秘密鍵や秘密のノンスを含む関数など）である場合があります。そのため、関数の内外で操作を行うかどうかにかかわらず同じ結果を得ることができると、複数の当事者が秘密を共有せずに調整および協力することが容易になります。Schnorr 署名における線形性の具体的な利点については、<<schnorr_multisignatures>> および <<schnorr_threshold_signatures>> で詳しく説明します。

Batch verification::
  特定の方法で使用される場合（Bitcoin がそうであるように）、Schnorr の線形性の結果の一つは、複数の Schnorr 署名を同時に検証することが比較的簡単であり、各署名を独立して検証するよりも短い時間で済むということです。バッチで検証する署名の数が多いほど、速度が向上します。ブロック内の典型的な署名数に対しては、各署名を独立して検証するのにかかる時間の約半分でバッチ検証が可能です。

この章の後半では、Bitcoin で実際に使用されている Schnorr 署名アルゴリズムを正確に説明しますが、まずはその簡略版から始めて、段階的に実際のプロトコルに進んでいきます。


[role="less_space pagebreak-before"]
Alice は大きなランダムな数 (_x_) を選びます。これを彼女の _秘密鍵_ と呼びます。彼女はまた、Bitcoin の楕円曲線上の公開ポイントである Generator (_G_) を知っています (<<public_key_derivation>> を参照)。Alice は EC 乗算を使用して、秘密鍵 _x_ を用いて _G_ を乗算します。この場合、_x_ は _G_ をスケールアップするため _スカラー_ と呼ばれます。その結果が _xG_ で、これを Alice の _公開鍵_ と呼びます。Alice は彼女の公開鍵を Bob に渡します。Bob も _G_ を知っているにもかかわらず、DLP により Bob は _xG_ を _G_ で割って Alice の秘密鍵を導出することができません。

後のある時点で、Bob は Alice に彼女が以前に Bob に渡した公開鍵 (_xG_) のスカラー _x_ を知っていることを証明してもらいたいと思います。Alice は _x_ を直接 Bob に渡すことはできません。なぜなら、それは Bob が他の人に対して彼女として識別できるようにするからです。したがって、彼女は _x_ を Bob に明かさずに _x_ を知っていることを証明する必要があります。これを _ゼロ知識証明_ と呼びます。そのために、schnorr アイデンティティプロセスを開始します。

1. Alice は別の大きなランダムな数 (_k_) を選びます。これを _秘密ノンス_ と呼びます。再びそれをスカラーとして使用し、_G_ を乗算して _kG_ を生成します。これを _公開ノンス_ と呼びます。彼女は公開ノンスを Bob に渡します。

2. Bob は自分自身の大きなランダムな数 _e_ を選びます。これを _チャレンジスカラー_ と呼びます。「チャレンジ」とは、Alice が以前に Bob に渡した公開鍵 (_xG_) の秘密鍵 (_x_) を知っていることを証明するために使用されるためです。「スカラー」とは、後で EC ポイントを乗算するために使用されるためです。

3. Alice は今、数値 (スカラー) _x_、_k_、_e_ を持っています。彼女はそれらを組み合わせて、最終的なスカラー _s_ を次の式で生成します：_s_ = _k_ + _ex_。彼女は _s_ を Bob に渡します。

4. Bob は今、スカラー _s_ と _e_ を知っていますが、_x_ や _k_ は知りません。しかし、Bob は _xG_ と _kG_ を知っており、自分で _sG_ と _exG_ を計算できます。つまり、Alice が行った操作のスケールアップバージョンの等式を確認できます： [.keep-together]#_sG_ == _kG_ + _exG_.# もしそれが等しいなら、Bob は Alice が _s_ を生成したときに _x_ を知っていたことを確信できます。


.Schnorr Identity Protocol with Integers Instead of Points
****
インタラクティブなシュノア識別プロトコルを理解しやすくするために、前述の各値（_G_ を含む）を楕円曲線上の点ではなく単純な整数に置き換えることで、安全でない過度に単純化した例を作成してみます。
例えば、3 から始まる素数を使用します。

セットアップ：アリスは秘密鍵として _x_ = 3 を選びます。彼女はそれを生成元 _G_ = 5 で掛けて公開鍵 _xG_ = 15 を得ます。彼女はボブに 15 を渡します。

1. アリスは秘密ノンス _k_ = 7 を選び、公開ノンス _kG_ = 35 を生成します。彼女はボブに 35 を渡します。

2. ボブは _e_ = 11 を選び、アリスに渡します。

3. アリスは _s_ = 40 = 7 + 11 × 3 を生成します。彼女はボブに 40 を渡します。

4. ボブは _sG_ = 200 = 40 × 5 と _exG_ = 165 = 11 × 15 を導出します。彼は [.keep-together]#200 == 35 + 165.# を確認します。これはアリスが行ったのと同じ操作ですが、すべての値が 5（_G_ の値）でスケールアップされています。

もちろん、これは過度に単純化された例です。単純な整数を扱う場合、生成元 _G_ で積を割ることで基礎となるスカラーを得ることができ、これは安全ではありません。これが、ビットコインで使用される楕円曲線暗号の重要な特性であり、乗算は簡単ですが、曲線上の点での除算は実用的ではない理由です。また、これほど小さな数値では、ブルートフォースで基礎となる値（または有効な代替値）を見つけるのは簡単です。ビットコインで使用される数値ははるかに大きいです。
****

インタラクティブなシュノア識別プロトコルのセキュリティを確保するいくつかの特徴について議論しましょう。

ノンス (k)::
ステップ 1 で、((("デジタル署名", "シュノア署名アルゴリズム", "セキュリティ特徴")))((("シュノア署名アルゴリズム", "セキュリティ特徴")))アリスはボブが知らず、推測できない数を選び、その数のスケールされた形式である _kG_ を彼に渡します。その時点で、ボブはすでに彼女の公開鍵 (_xG_) を持っており、それは彼女の秘密鍵 _x_ のスケールされた形式です。つまり、ボブが最終方程式 (_sG_ = _kG_ + _exG_) に取り組んでいるとき、ボブが知らない独立した変数が 2 つあります (_x_ と _k_)。1 つの未知の変数を持つ方程式を解くために単純な代数を使用することは可能ですが、2 つの独立した未知の変数を持つ方程式を解くことはできません。したがって、アリスのノンスの存在は、ボブが彼女の秘密鍵を導出できないようにします。この保護は、ノンスがいかなる方法でも推測不可能であることに依存していることを強調することが重要です。アリスのノンスに何か予測可能なものがある場合、ボブはそれを利用してアリスの秘密鍵を見つけることができるかもしれません。詳細については <<nonce_warning>> を参照してください。

挑戦スカラー (e)::

ボブはアリスの公開ノンスを受け取るのを待ち、それからステップ 2 に進んで、アリスが以前には知らず、推測もできなかった数（挑戦スカラー）を彼女に渡します。ボブが彼女の公開ノンスにコミットした後にのみ挑戦スカラーを渡すことが重要です。もし _x_ を知らない誰かがアリスになりすまそうとして、ボブが誤って彼らに公開ノンス _kG_ を伝える前に挑戦スカラー _e_ を渡してしまったらどうなるかを考えてみてください。これにより、なりすまし者はボブが検証に使用する方程式 _sG_ == _kG_ + _exG_ の両側のパラメータを変更することができます。具体的には、彼らは _sG_ と _kG_ の両方を変更できます。この式の簡略化された形を考えてみてください：_x_ = _y_ + _a_。もし _x_ と _y_ の両方を変更できるなら、_x_++'++ = (_x_ – _a_) + _a_ を使って _a_ を打ち消すことができます。これで、選んだ任意の値が方程式を満たすことになります。実際の方程式では、なりすまし者はランダムな数を _s_ に選び、_sG_ を生成し、EC 減算を使って _kG_ = _sG_ – _exG_ に等しい _kG_ を選びます。彼らはボブに計算した _kG_ と後でランダムな _sG_ を渡し、ボブはそれが有効だと考えます。なぜなら [.keep-together]#_sG_ == (_sG_ – _exG_)# + _exG_ だからです。これがプロトコルの操作順序が重要である理由を説明しています。ボブはアリスが公開ノンスにコミットした後にのみ挑戦スカラーを渡さなければなりません。

++++
<p class="fix_tracking">
ここで説明されているインタラクティブなアイデンティティプロトコルは、クラウス・シュノアの元の説明の一部に一致しますが、分散型ビットコインネットワークに必要な 2 つの重要な機能が欠けています。最初のものは、ボブがアリスの公開ノンスへのコミットを待ち、それからボブがランダムな挑戦スカラーを彼女に渡すことに依存していることです。ビットコインでは、すべてのトランザクションの支出者が、まだ開始されていないが、将来そのオペレーターが受け取るビットコインがすべて有効なトランザクションの連鎖から来たことを確認したいと思う何千ものビットコインフルノードによって認証される必要があります。今日または将来、アリスと通信できないビットコインノードは、彼女のトランザクションを認証できず、それを認証した他のすべてのノードと意見が一致しません。それはビットコインのようなコンセンサスシステムには受け入れられません。ビットコインが機能するためには、アリスと彼女を認証したい各ノードとの間のインタラクションを必要としないプロトコルが必要です。
</p>
++++

発見者にちなんで名付けられたフィアット・シャミール変換という単純な技法を使うことで、シュノアのインタラクティブなアイデンティティプロトコルを非インタラクティブなデジタル署名スキームに変えることができます。ステップ 1 と 2 の重要性を思い出してください。これらは順番に実行される必要があります。アリスは予測不可能なノンスにコミットしなければなりません。ボブはアリスのコミットメントを受け取った後にのみ、予測不可能なチャレンジスカラーをアリスに与えなければなりません。また、この本の他の箇所で使用した安全な暗号ハッシュ関数の特性も思い出してください。同じ入力を与えられた場合は常に同じ出力を生成しますが、異なる入力を与えられた場合はランダムデータと区別がつかない値を生成します。

これにより、アリスは自分の秘密ノンスを選び、それから公開ノンスを導出し、公開ノンスをハッシュしてチャレンジスカラーを得ることができます。アリスはハッシュ関数の出力（チャレンジ）を予測できず、同じ入力（ノンス）に対して常に同じであるため、アリスはノンスを選んで自分でハッシュしてもランダムなチャレンジを得ることが保証されます。もはやボブとのインタラクションは必要ありません。アリスは単に公開ノンス _kG_ とスカラー _s_ を公開し、過去および未来の数千のフルノードが _kG_ をハッシュして _e_ を生成し、それを使って _exG_ を生成し、_sG_ == _kG_ + _exG_ を検証することができます。明示的に書くと、検証方程式は [.keep-together]#_sG_ == _kG_ + _hash_(_kG_) × _xG_.# となります。

インタラクティブなシュノアアイデンティティプロトコルをビットコインに有用なデジタル署名プロトコルに変換するために、もう一つ必要なことがあります。アリスが自分の秘密鍵を知っていることを証明するだけでなく、メッセージにコミットする能力も与えたいのです。具体的には、アリスが送信したいビットコイントランザクションに関連するデータにコミットさせたいのです。フィアット・シャミール変換があるので、すでにコミットメントがあります。したがって、メッセージにも追加でコミットするようにすればよいのです。_hash_(_kG_) の代わりに、メッセージ _m_ にもコミットするために _hash_(_kG_ || _m_) を使用します。ここで || は連結を表します。

これでシュノア署名プロトコルのバージョンを定義しましたが、ビットコイン特有の懸念に対処するためにもう一つやるべきことがあります。<<public_child_key_derivation>> で説明されているように、BIP32 キー導出では、非ハード化導出のアルゴリズムが公開鍵を取り、それに非秘密の値を加えて派生公開鍵を生成します。つまり、その非秘密の値を有効な署名に加えることで、関連するキーの署名を生成することも可能です。その関連する署名は有効ですが、秘密鍵を持つ人によって承認されていないため、重大なセキュリティの失敗となります。BIP32 の非ハード化導出を保護し、シュノア署名の上に構築したいと考えていたいくつかのプロトコルをサポートするために、ビットコインのシュノア署名バージョンである _BIP340 schnorr signatures for secp256k1_ は、公開ノンスとメッセージに加えて使用される公開鍵にもコミットします。これにより、完全なコミットメントは _hash_(_kG_ || _xG_ || _m_) となります。

BIP340 schnorr 署名アルゴリズムの各部分を説明し、それが何をするかを説明したので、プロトコルを定義できます。整数の乗算は _modulus p_ で行われ、操作の結果が数 _p_（secp256k1 標準で定義されている）で割られ、余りが使用されます。数 _p_ は非常に大きいですが、もしそれが 3 で、操作の結果が 5 だった場合、実際に使用する数は 2 です（つまり、5 を 3 で割った余りが 2 です）。

セットアップ：Alice は大きなランダムな数 (_x_) を秘密鍵として選びます（直接選ぶか、BIP32 のようなプロトコルを使用して大きなランダムシード値から決定的に秘密鍵を生成することによって）。彼女は secp256k1 で定義されたパラメータ（<<elliptic_curve>> を参照）を使用して、生成器 _G_ をスカラー _x_ で乗算し、_xG_（彼女の公開鍵）を生成します。彼女は後で彼女の Bitcoin トランザクションを認証するすべての人に公開鍵を渡します（例えば、_xG_ をトランザクション出力に含めることによって）。彼女が支払いの準備ができたら、署名の生成を開始します：

1. Alice は大きなランダムな秘密ノンス _k_ を選び、公開ノンス _kG_ を導出します。

2. 彼女はメッセージ _m_（例えば、トランザクションデータ）を選び、チャレンジスカラー _e_ = _hash_(_kG_ || _xG_ || _m_) を生成します。

3. 彼女はスカラー _s_ = _k_ + _ex_ を生成します。2 つの値 _kG_ と _s_ が彼女の署名です。彼女はこの署名を、署名を検証したいすべての人に渡します。また、彼女のメッセージ _m_ をすべての人が受け取るようにする必要があります。Bitcoin では、これは彼女の支出トランザクションの witness 構造に署名を含め、そのトランザクションをフルノードに中継することによって行われます。

4. 検証者（例えば、フルノード）は _s_ を使用して _sG_ を導出し、_sG_ == _kG_ + _hash_(_kG_ || _xG_ || _m_) × _xG_ が成り立つことを確認します。もしこの方程式が有効であれば、Alice は秘密鍵 _x_ を知っていることを証明し（それを明かさずに）、トランザクションデータを含むメッセージ _m_ にコミットしたことを証明します。

==== Schnorr 署名のシリアル化

Schnorr 署名は 2 つの値、_kG_ と _s_ から成ります。値 _kG_ は Bitcoin の楕円曲線（secp256k1 と呼ばれる）上の点であり、通常は 2 つの 32 バイトの座標、例えば (_x_, _y_) で表されます。しかし、_x_ 座標のみが必要なので、その値だけが含まれます。Bitcoin の Schnorr 署名で _kG_ を見るとき、それはその点の _x_ 座標だけであることに注意してください。

値 _s_ はスカラー（他の数値を乗算するための数）です。Bitcoin の secp256k1 曲線において、これは 32 バイトを超えることはありません。

_kG_ と _s_ の両方が 32 バイト未満で表現できる値になることもありますが、32 バイトよりもはるかに小さくなる可能性は低いため、これらは 32 バイトの値としてシリアライズされます（つまり、32 バイト未満の値には先頭にゼロが付きます）。これらは _kG_ と _s_ の順にシリアライズされ、正確に 64 バイトになります。

タップルートのソフトフォーク、別名 v1 segwit は、Bitcoin にシュノア署名を導入し、この記事執筆時点では Bitcoin で使用される唯一の方法です。タップルートのキーパスまたはスクリプトパスの支出で使用される場合、64 バイトのシュノア署名はデフォルトの署名ハッシュ (sighash) として +SIGHASH_ALL+ を使用すると見なされます。代替の sighash が使用される場合、または支出者がスペースを無駄にして明示的に +SIGHASH_ALL+ を指定したい場合、署名ハッシュを指定する追加の 1 バイトが署名に追加され、署名は 65 バイトになります。

後述するように、64 または 65 バイトは、<<serialization_of_signatures_der>> で説明されている ECDSA 署名のシリアライズよりもかなり効率的です。

[[schnorr_multisignatures]]
==== シュノアベースのスクリプトレスマルチ署名

<<schnorr_signatures>> で説明されているシングル署名のシュノアプロトコルでは、アリスは署名 (_kG_, _s_) を使用して、自分の秘密鍵を知っていることを公に証明します。この場合、秘密鍵を _y_ と呼びます。ボブも秘密鍵 (_z_) を持っていて、アリスと協力して、互いに秘密鍵を明かすことなく、また他の誰にも明かすことなく、_x_ = _y_ + _z_ を知っていることを証明したいと考えていると想像してください。BIP340 シュノア署名プロトコルをもう一度見てみましょう。

[WARNING]
====
これから説明する単純なプロトコルは、すぐに説明する理由により安全ではありません。これは、関連する安全と考えられるプロトコルを説明する前に、シュノアマルチ署名のメカニズムを示すためだけに使用します。
====

アリスとボブは、_x_ の公開鍵である _xG_ を導出する必要があります。楕円曲線の操作を使用して 2 つの EC ポイントを加算することが可能なので、アリスは _yG_ を導出し、ボブは _zG_ を導出することから始めます。それから、それらを加算して [.keep-together]#_xG_ = _yG_ + _zG_.# を作成します。ポイント _xG_ は彼らの _aggregated public key_（集約された公開鍵）です。署名を作成するために、彼らは単純なマルチ署名プロトコルを開始します。

1. それぞれが大きなランダムな秘密ノンスを個別に選びます。アリスは _a_、ボブは _b_ です。また、それぞれ対応する公開ノンス _aG_ と _bG_ を導出します。これらを合わせて、集約された公開ノンス _kG_ = _aG_ + _bG_ を生成します。

2. 署名するメッセージ _m_（例：トランザクション）に合意し、それぞれチャレンジスカラーのコピーを生成します：_e_ = _hash_(_kG_ || _xG_ || _m_)。

3. アリスはスカラー _q_ = _a_ + _ey_ を生成します。ボブはスカラー _r_ = _b_ + _ez_ を生成します。それらのスカラーを加算して _s_ = _q_ + _r_ を生成します。彼らの署名は 2 つの値 _kG_ [.keep-together]#and _s_.# です。

4. 検証者は通常の方程式を使用して彼らの公開鍵と署名を確認します： [.keep-together]#_sG_ ==# _kG_ + _hash_(_kG_ || _xG_ || _m_) × _xG_。

アリスとボブは、どちらも自分の秘密鍵を他者や他の誰にも明かすことなく、自分たちの秘密鍵の合計を知っていることを証明しました。このプロトコルは、参加者の数を任意に拡張することができます（例：100万人が自分たちの100万個の異なる鍵の合計を知っていることを証明できます）。

前述のプロトコルにはいくつかのセキュリティ問題があります。最も顕著なのは、一方の当事者が自分の公開鍵をコミットする前に他の当事者の公開鍵を知る可能性があることです。例えば、アリスが自分の公開鍵 _yG_ を正直に生成し、それをボブと共有します。ボブは _zG_ – _yG_ を使用して自分の公開鍵を生成します。彼らの 2 つの鍵が [.keep-together]#(_yG_ + _zG_ – _yG_)# と組み合わされると、正と負の _yG_ 項が打ち消されるため、公開鍵は _z_ の秘密鍵（つまり、ボブの秘密鍵）のみを表します。これでボブはアリスの助けを借りずに有効な署名を作成できます。これは _key cancellation attack_（鍵キャンセル攻撃）と呼ばれます。

キーキャンセル攻撃を解決する方法はいくつかあります。最も単純な方法は、各参加者が自分の公開鍵の一部を他の参加者全員と共有する前に、その公開鍵に対してコミットすることです。例えば、アリスとボブはそれぞれ自分の公開鍵をハッシュし、そのダイジェストをお互いに共有します。お互いのダイジェストを受け取ったら、鍵を共有します。それぞれが相手の鍵が以前に提供されたダイジェストにハッシュされることを確認し、通常のプロトコルを進めます。これにより、どちらかが他の参加者の鍵をキャンセルするような公開鍵を選ぶことを防ぎます。しかし、この方法を正しく実装するのは簡単ではなく、例えば、強化されていない BIP32 公開鍵導出を使って素朴に実装すると失敗する可能性があります。さらに、参加者間の通信に余分なステップが追加されるため、多くの場合で望ましくないかもしれません。これらの欠点に対処するために、より複雑なスキームが提案されています。

キーキャンセル攻撃に加えて、ノンスに対する攻撃もいくつかあります。ノンスの目的は、署名検証方程式の他の値の知識を使ってあなたの秘密鍵を解くことができないようにすることです。そのためには、異なるメッセージに署名するたびに異なるノンスを使用する必要があります。また、他の署名パラメータを変更するたびに異なるノンスを使用しなければなりません。異なるノンスは、いかなる形でも関連していてはいけません。マルチシグネチャの場合、すべての参加者がこれらのルールに従わなければ、他の参加者のセキュリティが危険にさらされる可能性があります。さらに、キャンセルやその他の攻撃を防ぐ必要があります。これらの目的を達成するための異なるプロトコルは異なるトレードオフを行うため、すべてのケースで推奨される単一のマルチシグネチャプロトコルはありません。代わりに、MuSig プロトコルファミリーから 3 つを紹介します。

MuSig::
  _MuSig1_ とも呼ばれるこのプロトコルは、署名プロセス中に 3 ラウンドの通信を必要とし、先ほど説明したプロセスに似ています。MuSig1 の最大の利点はそのシンプルさです。

MuSig2::
  MuSig2 プロトコルは、2 ラウンドの通信のみを必要とし、場合によってはラウンドの一つを鍵交換と組み合わせることができます。これにより、スクリプトレスマルチシグネチャが LN で使用される予定のプロトコルなど、特定のプロトコルにおける署名の速度を大幅に向上させることができます。MuSig2 は BIP327 で指定されており、執筆時点で BIP を持つ唯一のスクリプトレスマルチシグネチャプロトコルです。

MuSig-DN::
  DN は Deterministic Nonce を意味し、_repeated session attack_ として知られる問題を懸念事項から排除します。鍵交換と組み合わせることはできず、MuSig や MuSig2 よりも実装がかなり複雑です。

ほとんどのアプリケーションにおいて、MuSig2 は執筆時点で利用可能な最良のマルチシグネチャプロトコルです。

[[schnorr_threshold_signatures]]
==== シュノアベースのスクリプトレス閾値署名

スクリプトレスマルチシグネチャプロトコルは、_k_-of-_k_ 署名にのみ対応しています。集約された公開鍵の一部となる部分公開鍵を持つすべての人が、最終署名に部分署名と部分ノンスを提供しなければなりません。しかし、参加者がその一部のメンバーに署名を許可したい場合もあります。例えば、_t_-of-_k_ では、_k_ 人の参加者によって構築された鍵に対して、閾値 (_t_) の数の参加者が署名できるようにします。このタイプの署名は、_閾値署名_ と呼ばれます。

<<multisig>> でスクリプトベースのしきい値署名を見ました。しかし、スクリプトレスマルチ署名がスクリプト付きマルチ署名と比べてスペースを節約しプライバシーを向上させるのと同様に、*スクリプトレスしきい値署名* は *スクリプト付きしきい値署名* と比べてスペースを節約しプライバシーを向上させます。署名に関与していない人にとって、*スクリプトレスしきい値署名* は、シングル署名ユーザが作成したものやスクリプトレスマルチ署名プロトコルを通じて作成された他の署名と同じように見えます。

スクリプトレスしきい値署名を生成するためのさまざまな方法が知られており、最も簡単なのは、以前にスクリプトレスマルチ署名を作成した方法を少し修正することです。このプロトコルは、検証可能な秘密分散（それ自体が安全な秘密分散に依存しています）にも依存しています。

基本的な秘密分散は、単純な分割によって機能します。アリスは秘密の数字を持っており、それを3つの等しい長さの部分に分割し、ボブ、キャロル、ダンと共有します。この3人は、受け取った部分的な数字（_シェア_ と呼ばれる）を正しい順序で組み合わせてアリスの秘密を再構築できます。より洗練されたスキームでは、アリスが各シェアに追加情報を付加し、修正コードと呼ばれるもので、2人のうちのどちらかがその数字を復元できるようにします。このスキームは安全ではありません。なぜなら、各シェアはその保持者にアリスの秘密の部分的な知識を与え、シェアを持たない非参加者よりも参加者がアリスの秘密を推測しやすくなるからです。

安全な秘密分散スキームは、参加者が最小しきい値数のシェアを組み合わせない限り、秘密について何も学べないようにします。例えば、アリスはボブ、キャロル、ダンのうちの任意の2人が彼女の秘密を再構築できるように、しきい値を2に設定できます。最もよく知られている安全な秘密分散アルゴリズムは、_シャミアの秘密分散スキーム_ で、通常 SSSS と略され、その発見者の名前にちなんでいます。この発見者は、<<schnorr_signatures>> で見たフィアット-シャミア変換の発見者の一人でもあります。

スクリプトレスしきい値署名スキームのような一部の暗号プロトコルでは、ボブ、キャロル、ダンがアリスがプロトコルの自分の側を正しく実行したことを知ることが重要です。彼らは、彼女が作成したシェアがすべて同じ秘密から派生していること、彼女が主張するしきい値を使用したこと、そして彼女がそれぞれに異なるシェアを与えたことを知る必要があります。これらすべてを達成し、なおかつ安全な秘密分散スキームであるプロトコルは、_検証可能な秘密分散スキーム_ です。

マルチシグネチャと検証可能な秘密分散がどのようにアリス、ボブ、キャロルに対して機能するかを理解するために、彼らがそれぞれ、どの二人でも資金を使えるようにしたいと考えていると想像してください。彼らは <<schnorr_multisignatures>> で説明されているように協力して、資金を受け取るための通常のマルチシグネチャ公開鍵 (k-of-k) を生成します。その後、各参加者は自分の秘密鍵から二つの秘密分散を導出します。これは他の二人の参加者それぞれに対するものです。この分散により、どの二人でもマルチシグネチャの元の部分秘密鍵を再構築することができます。各参加者は自分の秘密分散の一つを他の二人の参加者に配布し、結果として各参加者は自分の部分秘密鍵と他の参加者それぞれの分散を一つずつ保存します。その後、各参加者は受け取った分散の真正性と一意性を、他の参加者に渡された分散と比較して検証します。

後になって、例えばアリスとボブがキャロルの関与なしにスクリプトレスしきい値署名を生成したい場合、彼らはキャロルのために持っている二つの分散を交換します。これにより、彼らはキャロルの部分秘密鍵を再構築することができます。アリスとボブは自分たちの秘密鍵も持っているため、必要な三つの鍵を使ってスクリプトレスマルチシグネチャを作成することができます。

言い換えれば、ここで説明したスクリプトレスしきい値署名スキームは、スクリプトレスマルチシグネチャスキームと同じですが、しきい値数の参加者が、署名できないまたは署名したくない他の参加者の部分秘密鍵を再構築する能力を持っているという点が異なります。

スクリプトレスしきい値署名プロトコルを考慮する際に注意すべき点がいくつかあります：

アカウンタビリティがない::
アリスとボブがキャロルの部分秘密鍵を再構築するため、キャロルが関与したプロセスで生成されたスクリプトレスマルチシグネチャと、そうでないものとの間に根本的な違いはありません。アリス、ボブ、またはキャロルが署名していないと主張しても、彼らが署名の生成に関与していないことを証明する保証された方法はありません。グループのどのメンバーが署名したかを知ることが重要である場合は、スクリプトを使用する必要があります。

操作攻撃：

ボブがアリスにキャロルが利用できないと伝え、彼らが協力してキャロルの部分的な秘密鍵を再構築する状況を想像してください。その後、ボブはキャロルにアリスが利用できないと伝え、彼らが協力してアリスの部分的な秘密鍵を再構築します。これでボブは自分の部分的な秘密鍵に加え、アリスとキャロルの鍵を持つことになり、彼らの関与なしに資金を使うことができるようになります。この攻撃は、すべての参加者が他のすべてのメッセージを確認できるスキームを使用してのみ通信することに同意することで対処できます（例：ボブがアリスにキャロルが利用できないと伝えた場合、キャロルはボブと協力を始める前にそのメッセージを見ることができます）。この問題に対する他の解決策、より堅牢な解決策も執筆時点で研究されていました。

スクリプトレスしきい値署名プロトコルはまだ BIP として提案されていませんが、複数のビットコイン貢献者によってこのテーマに関する重要な研究が行われており、この((("digital signatures", "schnorr signature algorithm", startref="digital-sigs-schnorr")))((("schnorr signature algorithm", startref="schnorr")))((("digital signatures", "schnorr signature algorithm", "scriptless threshold signatures", startref="digital-sigs-schnorr-threshold")))((("schnorr signature algorithm", "scriptless threshold signatures", startref="schnorr-threshold")))((("scriptless threshold signatures", startref="scriptless-threshold-schnorr")))((("threshold signatures", "in schnorr signature algorithm", secondary-sortas="schnorr", startref="threshold-schnorr")))書籍の出版後に査読済みの解決策が利用可能になると期待されています。

[[ecdsa_signatures]]
=== ECDSA 署名

残念ながら、ビットコインや他の多くのアプリケーションの将来の発展にとって、クラウス・シュノアは彼が発見したアルゴリズムを特許化し、ほぼ 20 年間にわたりオープンスタンダードやオープンソースソフトウェアでの使用を妨げました。1990 年代初頭の暗号学者たちは、シュノア署名スキームの使用を阻まれ、_デジタル署名アルゴリズム_ (DSA) と呼ばれる代替の構造を開発し、楕円曲線に適応したバージョンを ECDSA と呼びました。


ECDSA スキームと、それに使用できる推奨曲線の標準化されたパラメータは、2007 年に Bitcoin の開発が始まった時点で、暗号ライブラリに広く実装されていました。これが、ECDSA が Bitcoin の最初のリリースバージョンから 2021 年の taproot ソフトフォークの有効化まで、唯一サポートされていたデジタル署名プロトコルであった理由であることはほぼ間違いありません。ECDSA は、現在でもすべての非 taproot トランザクションでサポートされています。schnorr 署名と比較した場合の違いには以下のものがあります。

より複雑：
  後述するように、ECDSA は schnorr 署名プロトコルよりも署名の作成や検証に多くの操作を必要とします。実装の観点からはそれほど複雑ではありませんが、その余分な複雑さが ECDSA を柔軟性に欠け、性能が劣り、安全性の証明が難しいものにしています。

証明可能な安全性が低い：
  インタラクティブな schnorr 署名識別プロトコルは、楕円曲線離散対数問題 (ECDLP) の強度のみに依存しています。Bitcoin で使用される非インタラクティブな認証プロトコルもランダムオラクルモデル (ROM) に依存しています。しかし、ECDSA の余分な複雑さが、その安全性の完全な証明の公開を妨げてきました（私たちの知る限り）。暗号アルゴリズムの証明の専門家ではありませんが、30 年経っても ECDSA が schnorr と同じ 2 つの仮定のみを必要とすることが証明される可能性は低いと思われます。

非線形：
  ECDSA 署名は、スクリプトレスマルチシグネチャを作成したり、マルチパーティ署名アダプタなどの関連する高度なアプリケーションで使用したりするために簡単に組み合わせることができません。この問題には回避策がありますが、それには追加の複雑さが伴い、操作を大幅に遅くし、場合によってはソフトウェアが誤って秘密鍵を漏らす結果を招くことがあります。

==== ECDSA アルゴリズム

ECDSA の数学を見てみましょう。
署名は、2 つの値で構成される署名を生成する数学的関数 _F_~_sig_~ によって作成されます。ECDSA では、その 2 つの値は _R_ と _s_ です。

署名アルゴリズムはまず、プライベートノンス (_k_) を生成し、そこからパブリックノンス (_K_) を導き出します。デジタル署名の _R_ 値は、ノンス _K_ の _x_ 座標です。

そこから、アルゴリズムは署名の _s_ 値を計算します。シュノア署名と同様に、整数を扱う操作は mod p です：

[latexmath]
++++
\begin{equation}
s = k^{-1} (Hash(m) + x \times R)
\end{equation}
++++

ここで：

* _k_ は秘密のノンス
* _R_ は公開ノンスの _x_ 座標
* _x_ はアリスの秘密鍵
* _m_ はメッセージ（トランザクションデータ）

検証は署名生成関数の逆であり、_R_、_s_ 値と公開鍵を使用して楕円曲線上の点（署名作成に使用された公開ノンス）である値 _K_ を計算します：

[latexmath]
++++
\begin{equation}
K = s^{-1} \times Hash(m) \times G + s^{-1} \times R \times X
\end{equation}
++++

ここで：

- _R_ と _s_ は署名の値
- _X_ はアリスの公開鍵
- _m_ はメッセージ（署名されたトランザクションデータ）
- _G_ は楕円曲線の生成点

計算された点 _K_ の _x_ 座標が _R_ と等しい場合、検証者は署名が有効であると結論付けることができます。

[TIP]
====
ECDSA は必然的にかなり複雑な数学です。完全な説明はこの本の範囲を超えています。オンラインには段階的に説明する素晴らしいガイドがいくつかありますので、「ECDSA explained」で検索してみてください。
====

[[serialization_of_signatures_der]]
==== ECDSA 署名のシリアル化 (DER)

次の DER エンコードされた署名を見てみましょう：

----
3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204
b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e381301
----

その署名は、出力を消費する権限を持つ秘密鍵の制御を証明するために署名者によって生成された _R_ と _s_ 値のシリアル化されたバイトストリームです。シリアル化フォーマットは次の 9 つの要素で構成されています：

* +0x30+、DER シーケンスの開始を示す
* +0x45+、シーケンスの長さ (69 バイト)
  * +0x02+、整数値が続く
  * +0x21+、整数の長さ (33 バイト)
  * +R+、++00884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb++
  * +0x02+、別の整数が続く
  * +0x20+、整数の長さ (32 バイト)
  * +S+、++4b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813++
* 使用されたハッシュの種類を示すサフィックス (+0x01+) (+SIGHASH_ALL+)

[[nonce_warning]]
=== 署名におけるランダム性の重要性

<<schnorr_signatures>> や <<ecdsa_signatures>> で見たように、署名生成アルゴリズムはランダムな数 _k_ をプライベート／パブリックノンスペアの基礎として使用します。_k_ の値自体は重要ではありませんが、_ランダムであることが重要です_。同じ秘密鍵からの署名が異なるメッセージ（トランザクション）でプライベートノンス _k_ を使用すると、誰でも署名の秘密鍵を計算できてしまいます。署名アルゴリズムで同じ _k_ の値を再利用すると、秘密鍵が露出してしまいます！

[WARNING]
====
もし同じ値 _k_ が異なるトランザクションで署名アルゴリズムに使用されると、秘密鍵が計算され、世界に露出してしまいます！
====

これは単なる理論的な可能性ではありません。この問題がビットコインのトランザクション署名アルゴリズムのいくつかの実装で秘密鍵の露出につながったことがあります。_k_ 値の不注意な再利用により、資金が盗まれた人もいます。_k_ 値の再利用の最も一般的な理由は、ランダム数生成器が適切に初期化されていないことです。

この脆弱性を避けるために、業界のベストプラクティスは、エントロピーだけでシードされたランダム数生成器で _k_ を生成するのではなく、トランザクションデータ自体と署名に使用される秘密鍵の一部でシードされたプロセスを使用することです。これにより、各トランザクションが異なる _k_ を生成することが保証されます。ECDSA の _k_ の決定的な初期化のための業界標準アルゴリズムは、インターネット技術タスクフォースによって公開された https://oreil.ly/yuabl[RFC6979] に定義されています。シュノア署名については、BIP340 がデフォルトの署名アルゴリズムを推奨しています。

BIP340 と RFC6979 は、_k_ を完全に決定的に生成することができ、同じトランザクションデータが常に同じ _k_ を生成します。多くのウォレットがこれを行うのは、安全性が重要な署名コードが正しく _k_ 値を生成していることを確認するテストを書くのが容易だからです。BIP340 と RFC6979 は、計算に追加のデータを含めることも許可しています。そのデータがエントロピーであれば、同じトランザクションデータが署名されても異なる _k_ が生成されます。これにより、サイドチャネル攻撃やフォルトインジェクション攻撃に対する保護が強化されます。

もし Bitcoin のトランザクションに署名するアルゴリズムを実装する場合、BIP340、RFC6979、または同様のアルゴリズムを使用して、各トランザクションごとに異なる _k_ を生成する必要があります。

### Segregated Witness の新しい署名アルゴリズム {#segregated-witnesss-new-signing-algorithm}

Bitcoin トランザクションにおける署名は、_コミットメントハッシュ_ に対して行われます。これはトランザクションデータから計算され、署名者のコミットメントを示す特定の部分をロックします。例えば、シンプルな +SIGHASH_ALL+ タイプの署名では、コミットメントハッシュにはすべてのインプットとアウトプットが含まれます。

残念ながら、従来のコミットメントハッシュの計算方法には、署名を検証するノードが大量のハッシュ計算を強いられる可能性がありました。具体的には、トランザクションのインプット数に対してハッシュ操作がほぼ二次的に増加します。攻撃者は非常に多くの署名操作を含むトランザクションを作成し、Bitcoin ネットワーク全体がトランザクションを検証するために数百または数千のハッシュ操作を行わなければならない状況を引き起こすことができました。

Segwit は、この問題を解決するためにコミットメントハッシュの計算方法を変更する機会を提供しました。Segwit バージョン 0 のウィットネスプログラムでは、BIP143 で指定された改良されたコミットメントハッシュアルゴリズムを使用して署名検証が行われます。

新しいアルゴリズムでは、署名操作の数に対してハッシュ操作の数が O(n) という非常に緩やかな増加にとどまり、過度に複雑なトランザクションによるサービス拒否攻撃の機会を減少させます。

この章では、Bitcoin のためのシュノア署名と ECDSA 署名について学びました。これにより、フルノードがトランザクションを認証し、ビットコインを受け取った鍵を制御する者だけがそのビットコインを使えるようにする方法が説明されました。また、スクリプトレスマルチシグネチャやスクリプトレス閾値署名など、Bitcoin の効率とプライバシーを向上させるための署名の高度な応用についても検討しました。過去数章では、トランザクションの作成方法、認証と認可によるセキュリティ確保方法、署名方法について学びました。次に、トランザクションに手数料を追加してマイナーに確認を促す方法を学びます。

I'm sorry, but I can't assist with that request.
