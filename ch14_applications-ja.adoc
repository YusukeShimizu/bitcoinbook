[[ch12]]
== セカンドレイヤーアプリケーション

これまでに学んだビットコインの基本システム（_ファーストレイヤー_）を基に、それを他のアプリケーション、つまり_セカンドレイヤー_のプラットフォームとして見ていきましょう。この章では、アプリケーションプラットフォームとしてのビットコインが提供する機能について見ていきます。ブロックチェーンアプリケーションの構成要素となるアプリケーション構築の_プリミティブ_について考察します。これらのプリミティブを利用する重要なアプリケーション、例えばクライアントサイド検証、ペイメントチャネル、ルーティングペイメントチャネル（ライトニングネットワーク）についても見ていきます。

=== 構成要素（プリミティブ）

ビットコインシステムが正しく長期間にわたって((("ビットコイン", "アプリケーションプラットフォームとして", "プリミティブの一覧", secondary-sortas="アプリケーションプラットフォーム", id="bitcoin-app-platform-primitive")))((("アプリケーションプラットフォーム, ビットコインとして", "プリミティブの一覧", id="app-platform-primitive")))((("プリミティブ", id="primitive-list")))((("構成要素", id="build-block")))動作する場合、ビットコインシステムはアプリケーションを作成するための構成要素として利用できる特定の保証を提供します。これには以下が含まれます。

二重支出なし:: ビットコインの分散型コンセンサスアルゴリズムの最も基本的な保証は、同じ有効なブロックチェーン内で UTXO が二重に支出されないことを確実にします。

不変性:: トランザクションがブロックチェーンに記録され、後続のブロックで十分な作業が追加されると、そのトランザクションのデータは事実上不変になります。不変性はエネルギーによって保証されており、ブロックチェーンを書き換えるには PoW を生成するためのエネルギーの消費が必要です。必要なエネルギーとしたがって不変性の度合いは、トランザクションを含むブロックの上に積み重ねられた作業量に比例して増加します。

[role="less_space pagebreak-before"]
中立性:: 分散型ビットコインネットワークは、トランザクションの発信元に関係なく有効なトランザクションを伝播します。これは、誰でも十分な手数料を持つ有効なトランザクションを作成し、そのトランザクションを送信していつでもブロックチェーンに含めることができると信頼できることを意味します。


セキュアなタイムスタンプ:: コンセンサスルールは、タイムスタンプが未来に遠すぎるブロックを拒否し、過去に遠すぎるブロックを防ごうとします。これにより、ブロックのタイムスタンプがある程度信頼できることが保証されます。ブロックのタイムスタンプは、含まれるすべてのトランザクションの入力に対する未使用参照を意味します。

認証:: デジタル署名は、分散型ネットワークで検証され、認証の保証を提供します。デジタル署名を要求するスクリプトは、スクリプトに示された秘密鍵の所有者による認証なしには実行できません。

監査可能性:: すべてのトランザクションは公開されており、監査可能です。すべてのトランザクションとブロックは、ジェネシスブロックまで途切れることなくリンクできます。

会計:: すべてのトランザクション（コインベーストランザクションを除く）では、入力の値は出力の値と手数料の合計に等しいです。トランザクションでビットコインの価値を作成または破壊することはできません。出力は入力を超えることはできません。

非期限切れ:: 有効なトランザクションは期限切れになりません。今日有効であれば、入力が未使用のままでコンセンサスルールが変更されない限り、近い将来も有効です。

整合性:: +SIGHASH_ALL+ で署名されたビットコイントランザクションの出力や、他の +SIGHASH+ タイプで署名されたトランザクションの一部は、署名を無効にしない限り変更できません。したがって、トランザクション自体も無効になります。

トランザクションの原子性:: ビットコイントランザクションは原子的です。それらは有効で確認（マイニング）されるか、されないかのどちらかです。部分的なトランザクションはマイニングされず、トランザクションに中間状態はありません。任意の時点でトランザクションはマイニングされているか、されていないかのどちらかです。

価値の離散（不可分）単位:: トランザクションの出力は離散的で不可分な価値の単位です。それらは完全に使用されるか未使用のままです。分割したり部分的に使用したりすることはできません。

制御のクォーラム:: スクリプト内のマルチシグネチャ制約は、マルチシグネチャスキームで事前に定義された認証のクォーラムを課します。この要件はコンセンサスルールによって強制されます。


Timelock/aging：相対的または絶対的なタイムロックを含むスクリプト条項は、その年齢が指定された時間を超えた後にのみ実行できます。

Replication：ブロックチェーンの分散ストレージにより、トランザクションがマイニングされ、十分な確認が行われた後、ネットワーク全体に複製され、電力損失やデータ損失などに対して耐久性と回復力を持ちます。

Forgery protection：トランザクションは既存の、検証済みのアウトプットのみを消費できます。価値を創造したり偽造したりすることはできません。

Consistency：マイナーの分割がない場合、ブロックチェーンに記録されたブロックは、記録された深さに基づいて指数関数的に減少する可能性で再編成や不一致の対象となります。一度深く記録されると、変更に必要な計算とエネルギーが実質的に不可能になります。

Recording external state：トランザクションは、+OP_RETURN+ または契約への支払いを通じて、外部状態機械の状態遷移を表すデータ値にコミットできます。

Predictable issuance：2100万ビットコイン未満が予測可能な速度で発行されます。

このビルディングブロックのリストは完全ではなく、新しい機能が導入されるたびにビットコインに追加されます ((("Bitcoin", "as application platform", "primitives, list of", secondary-sortas="application platform", startref="bitcoin-app-platform-primitive")))((("application platform, Bitcoin as", "primitives, list of", startref="app-platform-primitive")))((("primitives", startref="primitive-list")))((("building blocks", startref="build-block")))。

=== Applications from Building Blocks

ビットコインが提供する ((("Bitcoin", "as application platform", "example applications", secondary-sortas="application platform", id="bitcoin-app-platform-example")))((("application platform, Bitcoin as", "example applications", id="app-platform-example")))ビルディングブロックは、アプリケーションを構成するために使用できる信頼プラットフォームの要素です。以下は、現在存在するアプリケーションの例と、それらが使用するビルディングブロックです：

Proof-of-Existence (Digital Notary)：不変性 + タイムスタンプ + 耐久性。ブロックチェーン上のトランザクションは、ある値にコミットすることで、データが記録された時点で存在していたことを証明します (タイムスタンプ)。このコミットメントは事後に変更することはできません (不変性)、そして証拠は永久に保存されます (耐久性)。

Kickstarter (Lighthouse)：一貫性＋原子性＋整合性。ファンドレイザー取引の入力と出力（整合性）に署名すると、他の人がファンドレイザーに貢献できますが、目標（出力額）が資金提供されるまで（整合性）、それは使われません（原子性）。

ペイメントチャネル：コントロールのクォーラム＋タイムロック＋二重支出なし＋期限切れなし＋検閲耐性＋認可。ペイメントチャネルの「決済」取引として使用されるタイムロック（タイムロック）付きのマルチシグ 2-of-2（クォーラム）は、どちらの当事者（認可）によってもいつでも保持（期限切れなし）され、使用されることができます（検閲耐性）。その後、2 つの当事者は、より短いタイムロックで決済を上書きするコミットメント取引（二重支出なし）を作成できます（タイムロック）。

=== カラードコイン

最初のブロックチェーンアプリケーションとして紹介するのは、_カラードコイン_ です。

カラードコインは、ビットコイン取引を使用して、ビットコイン以外の外部資産の作成、所有、および移転を記録する一連の類似技術を指します。「外部」とは、ビットコイン自体とは対照的に、ビットコインブロックチェーンに直接保存されていない資産を意味します。ビットコイン自体はブロックチェーンに内在する資産です。

カラードコインは、第三者が保有し、カラードコインに関連付けられた所有証明書を通じて取引されるデジタル資産や物理資産を追跡するために使用されます。デジタル資産のカラードコインは、株式証明書、ライセンス、仮想財産（ゲームアイテム）などの無形資産や、商標、著作権などのライセンスされた知的財産のほとんどを表すことができます。物理資産のカラードコインは、商品（金、銀、石油）、土地の権利書、自動車、船舶、航空機などの所有証明書を表すことができます。

この用語は、ビットコインの名目上の金額、例えば 1 サトシを「着色」またはマークして、ビットコインの金額そのもの以外の何かを表すというアイデアに由来します。例えるなら、1 ドル紙幣に「これは ACME の株券です」や「この紙幣は 1 オンスの銀と交換できます」といったメッセージをスタンプし、その 1 ドル紙幣を他の資産の所有証明書として取引するようなものです。最初のカラードコインの実装は、_Enhanced Padded-Order-Based Coloring_ または _EPOBC_ と呼ばれ、1 サトシの出力に外部資産を割り当てました。このようにして、各資産が単一のサトシの属性（色）として追加されるため、真の「カラードコイン」となりました。

最近のカラードコインの実装では、トランザクションにメタデータを付加するために他のメカニズムを使用し、特定の資産にメタデータを関連付ける外部データストアと組み合わせています。この記事執筆時点で使用されている主なメカニズムは、シングルユースシール、ペイ・トゥ・コントラクト、およびクライアントサイド検証です。

[[single_use_seals]]
==== シングルユースシール

シングルユースシール（「カラードコインの応用」、「シングルユースシール」）は、物理的なセキュリティに由来します。第三者を通じてアイテムを発送する人は、改ざんを検出する方法が必要です。そのため、パッケージを開けると明らかに損傷する特別なメカニズムでパッケージを保護します。パッケージがシールが無傷のまま届けば、送信者と受信者はパッケージが輸送中に開けられていないことを確信できます。

カラードコインの文脈では、シングルユースシールは、他のデータ構造と一度だけ関連付けることができるデータ構造を指します。ビットコインでは、この定義は未使用トランザクション出力 (UTXO) によって満たされます。UTXO は有効なブロックチェーン内で一度だけ使用することができ、それを使用するプロセスは、使用するトランザクションのデータと関連付けられます。

これが、現代のカラードコインの転送の基礎の一部を提供します。1 つ以上のカラードコインが UTXO に受け取られます。その UTXO が使用されるとき、使用するトランザクションはカラードコインをどのように使用するかを説明しなければなりません。これがペイ・トゥ・コントラクト (P2C) につながります。

[[p2c_for_colored_coins]]
==== Pay to Contract (P2C)

以前、<<pay_to_contract>> で P2C について学びました。これはビットコインのコンセンサスルールへの taproot アップグレードの基礎の一部となりました。簡単に思い出してみましょう。P2C は支払者 (ボブ) と受取人 (アリス) が契約などのデータに合意し、アリスの公開鍵を調整して契約にコミットすることを可能にします。ボブはいつでもアリスの元の鍵と契約にコミットするために使用した調整を公開し、彼女が資金を受け取ったことを証明できます。アリスが資金を使うと、彼女が契約を知っていたことが完全に証明されます。なぜなら、P2C で調整された鍵で受け取った資金を使う唯一の方法は、調整 (契約) を知っていることだからです。

P2C で調整された鍵の強力な属性は、アリスとボブ以外の誰にとっても他の公開鍵と同じように見えることです。彼らが鍵を調整するために使用した契約を公開しない限り、契約について何も公開されません。彼らの間に契約が存在することさえも公開されません。

P2C 契約は任意の長さや詳細にすることができ、条件は任意の言語で書くことができ、参加者が望むものを参照することができます。なぜなら、契約はフルノードによって検証されず、コミットメントを持つ公開鍵だけがブロックチェーンに公開されるからです。

カラードコインの文脈では、ボブは関連する UTXO を使うことでカラードコインを含む一回限りのシールを開くことができます。その UTXO を使うトランザクションで、次の所有者 (または所有者たち) がコインをさらに使うために満たさなければならない条件を示す契約にコミットできます。新しい所有者はアリスである必要はありません。ボブが使う UTXO を受け取るのはアリスであり、アリスは契約条件によって公開鍵を調整しているにもかかわらずです。

フルノードが契約が正しく守られているかを検証しない (できない) ため、誰が検証の責任を負うのかを考える必要があります。それが _クライアントサイド検証_ につながります。

==== クライアントサイド検証

ボブは、UTXO に関連付けられたいくつかのカラードコインを持っていました。彼はその UTXO を使って、次の受取人（または受取人たち）がコインをさらに使うために所有権を証明する方法を示す契約にコミットする形で支出しました。

実際には、ボブの P2C 契約は、カラードコインが次に支出されるときに決定するためのシングルユースシールとして使用される UTXO の一意の識別子に単にコミットしている可能性が高いです。例えば、ボブの契約は、アリスが彼女の P2C 調整公開鍵に受け取った UTXO が彼のカラードコインの半分を制御し、残りの半分はアリスとボブの取引とは関係のない別の UTXO に割り当てられることを示しているかもしれません。これにより、ブロックチェーン監視に対する大きなプライバシーが提供されます。

アリスが後で彼女のカラードコインをダンに使いたいとき、彼女はまずダンに対して彼女がカラードコインを制御していることを証明する必要があります。アリスはこれを、彼女の基礎となる P2C 公開鍵とボブが選んだ P2C 契約条件をダンに明らかにすることで行えます。アリスはまた、ボブがシングルユースシールとして使用した UTXO と、ボブが彼女に与えたカラードコインの以前の所有者に関する情報をダンに明らかにします。要するに、アリスはダンに対して、カラードコインのすべての以前の移転に関する完全な履歴を提供します。各ステップはビットコインブロックチェーンにアンカーされていますが、チェーンに特別なデータを保存することはなく、通常の公開鍵だけです。その履歴は、私たちがブロックチェーンと呼ぶ通常のビットコイン取引の履歴に非常によく似ていますが、カラード履歴はブロックチェーンの他のユーザには完全に見えません。

ダンは彼のソフトウェアを使ってこの履歴を検証します。これを _クライアントサイド検証_ と呼びます。特に、ダンは受け取りたいカラードコインに関連する履歴の部分だけを受け取り、検証する必要があります。他の人のカラードコインに何が起こったかについての情報は必要ありません。例えば、ボブがアリスに移転しなかったコインのもう半分に何が起こったかを知る必要はありません。これにより、カラードコインプロトコルのプライバシーが向上します。

これまでに、シングルユースシール、ペイ・トゥ・コントラクト、クライアントサイド検証について学んできましたので、これらを利用する主なプロトコルである RGB と Taproot Assets について見ていきましょう。

==== RGB

RGB プロトコルの開発者たちは、現代の Bitcoin ベースのカラードコインプロトコルで使用される多くのアイデアを先駆けて提案しました。RGB の設計における主要な要件は、プロトコルをオフチェーンの支払いチャネル（<<state_channels>> を参照）と互換性を持たせることでした。これは RGB プロトコルの各層で達成されています。

シングルユースシール：
支払いチャネルを作成するために、ボブは彼のカラードコインを、彼とアリスの両方の署名が必要な UTXO に割り当てます。彼らのその UTXO に対する共同管理が、将来の転送のためのシングルユースシールとして機能します。

ペイ・トゥ・コントラクト (P2C)：
アリスとボブは、P2C コントラクトの複数のバージョンに署名できます。基盤となる支払いチャネルの強制メカニズムにより、両者は最新バージョンのコントラクトのみをオンチェーンで公開するようにインセンティブが与えられます。

クライアントサイド検証：
アリスとボブのどちらもお互いを信頼する必要がないように、彼らはそれぞれ、カラードコインのすべての過去の転送をその作成まで遡ってチェックし、すべてのコントラクトルールが正しく遵守されていることを確認します。

RGB の開発者たちは、プライベートキーの漏洩を防ぐために定期的に更新できるアイデンティティトークンの作成など、プロトコルの他の用途についても説明しています。

詳細については、https://rgb.tech[RGB のドキュメント] を参照してください。

==== Taproot Assets

以前は Taro と呼ばれていた Taproot Assets は、RGB に大きく影響を受けたカラードコインプロトコルです。RGB と比較して、Taproot Assets は、MAST 機能を有効にするためにタップルートで使用されるバージョンに非常に似た形式の P2C コントラクトを使用します（<<mast>> を参照）。Taproot Assets の RGB に対する利点として主張されているのは、広く使用されているタップルートプロトコルとの類似性が、ウォレットや他のソフトウェアの実装を簡単にすることです。一方で、特にアイデンティティトークンのような非資産機能を実装する際には、RGB プロトコルほど柔軟ではないかもしれません。

[NOTE]
====
_Taproot_ は Bitcoin プロトコルの一部です。_Taproot Assets_ は、似た名前ですが、Bitcoin プロトコルの一部ではありません。RGB と Taproot Assets の両方は、Bitcoin プロトコルの上に構築されたプロトコルです。Bitcoin によってネイティブにサポートされている唯一の資産は bitcoin です。
====

RGB よりもさらに、Taproot Assets は LN と互換性を持つように設計されています。LN を介して非 bitcoin 資産を転送する際の課題は、送信を達成するための 2 つの方法があり、それぞれ異なるトレードオフがあることです。

ネイティブ転送::
  支出者と受取者の間の経路の各ホップは、特定の資産（カラーコインの種類）について知っており、支払いを転送するのに十分な残高を持っている必要があります。

翻訳転送::
  支出者の隣のホップと受取者の隣のホップは、特定の資産について知っており、支払いを転送するのに十分な残高を持っている必要がありますが、他のすべてのホップは bitcoin 支払いを転送することだけをサポートすればよいのです。

ネイティブ転送は概念的には簡単ですが、実質的にはすべての資産に対して別々の Lightning 型ネットワークを必要とします。翻訳転送は、Bitcoin LN の規模の経済を活用することができますが、_free American call option_ と呼ばれる問題に対して脆弱である可能性があります。これは、受取者が最近の為替レートの変動に応じて特定の支払いを選択的に受け入れたり拒否したりすることで、隣のホップから資金を吸い上げることができるというものです。free American call option に対する完璧な解決策は知られていませんが、その害を制限する実用的な解決策があるかもしれません。

Taproot Assets と RGB の両方は、技術的にはネイティブ転送と翻訳転送の両方をサポートできます。Taproot Assets は特に翻訳転送を中心に設計されており、RGB には両方を実装する提案が見られます。

詳細については、https://oreil.ly/Ef4hb[Taproot Asset's documentation] を参照してください。さらに、Taproot Asset の開発者は、この本が印刷されるまでに利用可能になるかもしれない BIP に取り組んでいます。

[[state_channels]]
=== ペイメントチャネルとステートチャネル

*ペイメントチャネル*は、ビットコインブロックチェーンの外で二者間でビットコイン取引を交換するための信頼不要なメカニズムです。これらの取引は、ビットコインブロックチェーン上で決済されれば有効ですが、代わりにオフチェーンで保持され、最終的なバッチ決済を待ちます。取引が決済されないため、通常の決済遅延なしで交換でき、非常に高い取引スループット、低遅延、細かい粒度を可能にします。

実際には、*チャネル*という用語は比喩です。ステートチャネルは、ブロックチェーンの外で二者間の状態の交換によって表される仮想的な構造です。「チャネル」そのものは存在せず、基盤となるデータ転送メカニズムがチャネルではありません。チャネルという用語は、ブロックチェーンの外での二者間の関係と共有状態を表すために使用します。

この概念をさらに説明するために、TCPストリームを考えてみてください。高レベルのプロトコルの観点からは、インターネットを介して二つのアプリケーションを接続する「ソケット」です。しかし、ネットワークトラフィックを見てみると、TCPストリームはIPパケット上の仮想チャネルにすぎません。TCPストリームの各エンドポイントは、IPパケットを順序付けて組み立て、バイトのストリームの幻影を作り出します。実際には、すべてが切断されたパケットです。同様に、ペイメントチャネルは一連の取引にすぎません。適切に順序付けて接続されていれば、チャネルの反対側を信頼しなくても信頼できる引き換え義務を作り出します。

このセクションでは、さまざまな形式のペイメントチャネルを見ていきます。まず、ストリーミングビデオのようなメーター制のマイクロペイメントサービスのための一方向（単方向）ペイメントチャネルを構築するために使用されるメカニズムを検討します。次に、このメカニズムを拡張し、双方向ペイメントチャネルを紹介します。最後に、双方向チャネルをエンドツーエンドで接続して、ルーティングネットワーク内でマルチホップチャネルを形成する方法を見ていきます。これは最初に*ライトニングネットワーク*という名前で提案されました。

支払いチャネルは、より広範な概念である _ステートチャネル_ の一部であり、これはブロックチェーンで最終的に決済されることによって保証される、オフチェーンでの状態の変更を表します。支払いチャネルは、変更される状態が仮想通貨の残高であるステートチャネルです。

==== ステートチャネル&#x2014;基本概念と用語

ステートチャネル ((("支払いチャネル", "ステートチャネル", id="payment-channel-state")))((("ステートチャネル", id="state-channel-terminology")))((("トランザクション", "ステートチャネル", id="transaction-state"))) は、ブロックチェーン上に共有状態をロックするトランザクションを通じて二者間で確立されます。これは _資金調達トランザクション_ ((("資金調達トランザクション"))) と呼ばれます。この単一のトランザクションは、チャネルを確立するためにネットワークに送信され、マイニングされなければなりません。支払いチャネルの例では、ロックされた状態はチャネルの初期残高（通貨）です。

その後、二者は署名済みトランザクションを交換します。これを _コミットメントトランザクション_ ((("コミットメントトランザクション"))) と呼び、初期状態を変更します。これらのトランザクションは、どちらの当事者によっても決済のために提出される可能性がある有効なトランザクションですが、チャネルが閉じるまで各当事者によってオフチェーンで保持されます。状態の更新は、各当事者がトランザクションを作成し、署名し、相手に送信できる速度で作成できます。実際には、毎秒数十のトランザクションを交換できることを意味します。

コミットメントトランザクションを交換する際、二者は以前の状態の使用を抑制し、常に最新のコミットメントトランザクションが最も良いものとして引き換えられるようにします。これにより、どちらかの当事者が一方的にチャネルを閉じて、現在の状態よりも自分に有利な以前の状態で不正を行うことを防ぎます。この章の残りでは、以前の状態の公開を抑制するために使用できるさまざまなメカニズムを検討します。

最後に、チャネルは協力的に、最終的な _決済トランザクション_ ((("決済トランザクション"))) をブロックチェーンに提出することによって、またはどちらかの当事者が最後のコミットメントトランザクションをブロックチェーンに提出することによって一方的に閉じることができます。一方的な閉鎖オプションは、どちらかの当事者が予期せず切断された場合に必要です。決済トランザクションはチャネルの最終状態を表し、ブロックチェーン上で決済されます。

チャネルの全期間において、ブロックチェーン上でマイニングのために提出される必要があるトランザクションは、資金調達と決済の2つだけです。この2つの状態の間で、両当事者は他の誰にも見られず、ブロックチェーンに提出されることのない任意の数のコミットメントトランザクションを交換できます。

<<payment_channel>> は、ボブとアリスの間のペイメントチャネルを示し、資金調達、コミットメント、および決済のトランザクションを示しています。

[[payment_channel]]
.ボブとアリスの間のペイメントチャネル、資金調達、コミットメント、および決済のトランザクションを示しています。
image::images/mbc3_1401.png["ボブとアリスの間のペイメントチャネル、資金調達、コミットメント、および決済のトランザクションを示しています"]

==== シンプルなペイメントチャネルの例

ペイメントチャネルを説明するために、非常にシンプルな例から始めます。ここでは、一方向チャネルを示します。つまり、価値が一方向にのみ流れるということです。また、誰も不正をしようとしていないという単純な仮定から始めます。基本的なチャネルの考え方が説明できたら、どちらの当事者も不正をしようとしてもできないようにするために必要なことを見ていきます。

//TODO:ミリビットではなくサトシを使用するように変更する。または、価格が変動しても例が古くならないように具体的な金額を削除する。

この例では、エマとファビアンという2人の参加者を想定します。ファビアンは、マイクロペイメントチャネルを使用して秒単位で請求されるビデオストリーミングサービスを提供しています。ファビアンは、ビデオ1秒あたり0.01ミリビット (0.00001 BTC) を請求し、これはビデオ1時間あたり36ミリビット (0.036 BTC) に相当します。エマは、このストリーミングビデオサービスをファビアンから購入するユーザです。<<emma_fabian_streaming_video>> は、エマがファビアンからペイメントチャネルを使用してビデオストリーミングサービスを購入する様子を示しています。

[[emma_fabian_streaming_video]]
.エマはファビアンからストリーミング動画を購入し、支払いチャネルを使って1秒ごとに支払います。
image::images/mbc3_1402.png["エマはファビアンからストリーミング動画を購入し、支払いチャネルを使って1秒ごとに支払います"]

この例では、ファビアンとエマは支払いチャネルと動画ストリーミングの両方を処理する特別なソフトウェアを使用しています。エマはブラウザでソフトウェアを実行し、ファビアンはサーバーで実行しています。このソフトウェアには基本的なビットコインウォレット機能が含まれており、ビットコインのトランザクションを作成して署名することができます。「支払いチャネル」という概念と用語はユーザには完全に隠されています。彼らが目にするのは、1秒ごとに支払われる動画です。

支払いチャネルを設定するために、エマとファビアンは2-of-2マルチシグネチャアドレスを確立し、それぞれがキーを1つずつ保持します。エマの視点から見ると、ブラウザのソフトウェアはアドレスを示すQRコードを表示し、最大1時間分の動画の「デポジット」を送信するよう求めます。その後、エマがアドレスに資金を提供します。エマのトランザクションは、マルチシグネチャアドレスへの支払いであり、支払いチャネルの資金提供またはアンカートランザクションです。

この例では、エマが36ミリビット (0.036 BTC) でチャネルに資金を提供するとしましょう。これにより、エマは最大1時間のストリーミング動画を消費できます。この資金提供トランザクションは、このチャネルで送信できる最大金額を設定し、チャネル容量を設定します。

資金提供トランザクションは、エマのウォレットから1つ以上のインプットを消費し、資金を調達します。そして、エマとファビアンが共同で管理するマルチシグネチャ2-of-2アドレスに36ミリビットを支払う1つのアウトプットを作成します。エマのウォレットに戻るお釣りのための追加のアウトプットがあるかもしれません。

資金提供トランザクションが十分な深さで確認された後、エマは動画のストリーミングを開始できます。エマのソフトウェアは、チャネルの残高を変更して0.01ミリビットをファビアンのアドレスにクレジットし、35.99ミリビットをエマに返金するコミットメントトランザクションを作成して署名します。エマが署名したトランザクションは、資金提供トランザクションによって作成された36ミリビットのアウトプットを消費し、彼女の返金用とファビアンへの支払い用の2つのアウトプットを作成します。このトランザクションは部分的にしか署名されておらず、2つの署名 (2-of-2) が必要ですが、エマの署名しかありません。ファビアンのサーバーがこのトランザクションを受け取ると、2-of-2インプットのための2番目の署名を追加し、1秒分の動画とともにエマに返します。これで、両者はどちらもチャネルの正しい最新の残高を表す完全に署名されたコミットメントトランザクションを持つことになります。どちらの当事者もこのトランザクションをネットワークにブロードキャストしません。

次のラウンドでは、エマのソフトウェアが別のコミットメントトランザクション（コミットメント #2）を作成し、署名します。このトランザクションは、資金提供トランザクションの同じ 2-of-2 出力を消費します。2 番目のコミットメントトランザクションは、0.02 ミリビットをファビアンのアドレスに、35.98 ミリビットをエマのアドレスに戻す出力を割り当てます。この新しいトランザクションは、累積で 2 秒間のビデオの支払いです。ファビアンのソフトウェアは、2 番目のコミットメントトランザクションに署名し、もう 1 秒のビデオと共に返します。

このようにして、エマのソフトウェアは、ストリーミングビデオと引き換えにコミットメントトランザクションをファビアンのサーバーに送り続けます。エマがより多くの秒数のビデオを消費するにつれて、チャネルの残高は徐々にファビアンに有利に蓄積されます。エマが 600 秒（10 分）のビデオを視聴し、600 のコミットメントトランザクションを作成し、署名したとしましょう。最後のコミットメントトランザクション（#600）には 2 つの出力があり、チャネルの残高を分割し、6 ミリビットをファビアンに、30 ミリビットをエマに割り当てます。

最後に、エマが「停止」をクリックしてビデオのストリーミングを停止します。ファビアンまたはエマのどちらかが、最終状態のトランザクションを送信して決済することができます。この最後のトランザクションは、_決済トランザクション_ であり、エマが消費したすべてのビデオに対してファビアンに支払い、資金提供トランザクションの残りをエマに返金します。

<<video_payment_channel>> は、エマとファビアンの間のチャネルと、チャネルの残高を更新するコミットメントトランザクションを示しています。

最終的に、ブロックチェーンに記録されるトランザクションは 2 つだけです。チャネルを確立した資金提供トランザクションと、最終的な残高を正しく 2 人の参加者間で割り当てた決済トランザクションです。

[[video_payment_channel]]
.エマとファビアンの支払いチャネル、チャネルの残高を更新するコミットメントトランザクションを示しています。
image::images/mbc3_1403.png["エマとファビアンの支払いチャネル、チャネルの残高を更新するコミットメントトランザクションを示しています"]

==== 信頼不要なチャネルの作成

先ほど説明したチャネルは、両者が協力し、失敗や不正行為の試みがない場合にのみ機能します。このチャネルを壊すいくつかのシナリオを見て、それを修正するために必要なものを見てみましょう。

[role="less_space pagebreak-before"]
- 資金調達トランザクションが発生すると、エマはファビアンの署名がないとお金を取り戻せません。ファビアンが消えてしまうと、エマの資金は 2-of-2 にロックされ、事実上失われます。このチャネルは、少なくとも一つのコミットメントトランザクションが両者によって署名される前に一方が利用できなくなると、資金の損失につながります。

- チャネルが稼働している間、エマはファビアンがカウンターサインしたコミットメントトランザクションをどれでもブロックチェーンに送信できます。なぜ 600 秒のビデオのために支払う必要があるのでしょうか？コミットメントトランザクション #1 を送信して 1 秒のビデオだけに支払えばいいのです。このチャネルは、エマが自分に有利な以前のコミットメントを放送することで不正を行うことができるため、失敗します。

これらの問題はタイムロックで解決できます。トランザクションレベルのタイムロックをどのように使用できるか見てみましょう。

エマは、保証された返金がない限り、2-of-2 マルチシグに資金を提供するリスクを負えません。この問題を解決するために、エマは資金調達トランザクションと返金トランザクションを同時に構築します。彼女は資金調達トランザクションに署名しますが、それを誰にも送信しません。エマは返金トランザクションだけをファビアンに送信し、彼の署名を取得します。

返金トランザクションは最初のコミットメントトランザクションとして機能し、そのタイムロックはチャネルの寿命の上限を設定します。この場合、エマはロックタイムを 30 日または 4,320 ブロック先に設定できます。すべての後続のコミットメントトランザクションは、返金トランザクションよりも短いタイムロックを持つ必要があるため、返金トランザクションの前に償還できます。

エマが完全に署名された返金トランザクションを持っているので、彼女は署名された資金調達トランザクションを自信を持って送信できます。タイムロックが切れた後、ファビアンが消えても返金トランザクションを償還できることを知っているからです。

チャネルの寿命中に両者が交換するすべてのコミットメントトランザクションは、将来に向けてタイムロックされます。しかし、遅延は各コミットメントごとにわずかに短くなるため、最新のコミットメントはそれが無効にする以前のコミットメントの前に償還できます。ロックタイムのため、どちらの当事者もタイムロックが切れるまでコミットメントトランザクションを正常に伝播できません。すべてがうまくいけば、彼らは協力して和解トランザクションでチャネルを円滑に閉じるため、中間のコミットメントトランザクションを送信する必要はありません。そうでない場合、最新のコミットメントトランザクションを伝播してアカウントを清算し、以前のすべてのコミットメントトランザクションを無効にすることができます。

たとえば、コミットメントトランザクション #1 が 4,320 ブロック先にタイムロックされている場合、コミットメントトランザクション #2 は 4,319 ブロック先にタイムロックされます。コミットメントトランザクション #600 は、コミットメントトランザクション #1 が有効になる 600 ブロック前に使用できます。

<<timelocked_commitments>> は、各コミットメントトランザクションがより短いタイムロックを設定し、前のコミットメントが有効になる前に使用できるようにすることを示しています。

[[timelocked_commitments]]
.各コミットメントはより短いタイムロックを設定し、前のコミットメントが有効になる前に使用できるようにします。
image::images/mbc3_1404.png["Each commitment sets a shorter timelock, allowing it to be spent before the previous commitments become valid"]

各後続のコミットメントトランザクションは、前のものや払い戻しトランザクションの前にブロードキャストできるように、より短いタイムロックを持たなければなりません。コミットメントを早くブロードキャストできる能力は、資金出力を使用し、他のコミットメントトランザクションが出力を使用して償還されるのを防ぐことを保証します。ビットコインブロックチェーンが提供する保証は、二重支出を防ぎ、タイムロックを強制することで、各コミットメントトランザクションがその前のものを無効にすることを可能にします。

ステートチャネルは、タイムロックを使用して時間の次元でスマートコントラクトを強制します。この例では、時間の次元が最新のコミットメントトランザクションが以前のコミットメントよりも先に有効になることを保証する方法を見ました。したがって、最新のコミットメントトランザクションは送信され、入力を使用し、以前のコミットメントトランザクションを無効にします。絶対的なタイムロックを使用したスマートコントラクトの強制は、一方の当事者による不正行為を防ぎます。この実装には、絶対的なトランザクションレベルのロックタイム以上のものは必要ありません。次に、スクリプトレベルのタイムロック、+CHECKLOCKTIMEVERIFY+ および +CHECKSEQUENCEVERIFY+ を使用して、より柔軟で有用かつ高度なステートチャネルを構築する方法を見ていきます。

タイムロックは、以前のコミットメントトランザクションを無効にする唯一の方法ではありません。次のセクションでは、取り消しキーを使用して同じ結果を達成する方法を見ていきます。タイムロックは効果的ですが、2 つの明確な欠点があります。チャネルが最初に開かれたときに最大タイムロックを設定することで、チャネルの寿命を制限します。さらに悪いことに、チャネルの実装は、長期間のチャネルを許可することと、早期に閉鎖された場合に参加者の一方が非常に長い間払い戻しを待たなければならないことのバランスを取ることを強制されます。たとえば、払い戻しのタイムロックを 30 日に設定してチャネルを 30 日間開いたままにすることを許可すると、一方の当事者がすぐに消えてしまった場合、もう一方の当事者は払い戻しを受けるのに 30 日待たなければなりません。エンドポイントが遠いほど、払い戻しも遠くなります。

2 つ目の問題は、各後続のコミットメントトランザクションがタイムロックを減少させなければならないため、当事者間で交換できるコミットメントトランザクションの数に明確な制限があることです。例えば、30 日間のチャネルで、タイムロックを 4,320 ブロック先に設定すると、4,320 の中間コミットメントトランザクションしか処理できず、その後は閉じなければなりません。タイムロックコミットメントトランザクションの間隔を 1 ブロックに設定することには危険があります。コミットメントトランザクション間のタイムロック間隔を 1 ブロックに設定すると、チャネル参加者に非常に高い負担をかけることになります。彼らは常に警戒し、オンラインで監視し、いつでも正しいコミットメントトランザクションを送信する準備をしておかなければなりません。

単方向チャネルの前述の例では、コミットメントごとのタイムロックを簡単に排除できます。エマがファビアンからタイムロック付きの返金トランザクションの署名を受け取った後、コミットメントトランザクションにはタイムロックが設定されません。代わりに、エマは各コミットメントトランザクションに対する彼女の署名をファビアンに送りますが、ファビアンは彼の署名をエマに送信しません。つまり、ファビアンだけがコミットメントトランザクションの両方の署名を持っているため、彼だけがこれらのコミットメントのいずれかをブロードキャストできます。エマがビデオのストリーミングを終えると、ファビアンは常に自分に最も多くの支払いをするトランザクション、つまり最新の状態をブロードキャストすることを好みます。この構造は Spillman スタイルのペイメントチャネルと呼ばれ、2013 年に初めて記述され実装されましたが、2017 年まで利用可能にならなかった witness (segwit) トランザクションでのみ安全に使用できます。

タイムロックが以前のコミットメントを無効にする方法を理解したので、チャネルを協力的に閉じることと、コミットメントトランザクションをブロードキャストして一方的に閉じることの違いがわかります。前の例のすべてのコミットメントトランザクションはタイムロックされていたため、コミットメントトランザクションをブロードキャストすることは常にタイムロックが期限切れになるまで待つことを伴います。しかし、両当事者が最終的な残高に同意し、どちらもその残高を実現するコミットメントトランザクションを保持していることを知っている場合、同じ残高を表すタイムロックなしの決済トランザクションを構築できます。協力的なクローズでは、どちらかの当事者が最新のコミットメントトランザクションを取り、タイムロックを省略する以外はすべて同一の決済トランザクションを構築します。両当事者は、この決済トランザクションに署名し、より有利な残高を得るために不正をする方法がないことを知っているので、安心して署名できます。協力して決済トランザクションに署名し送信することで、チャネルを閉じてすぐに残高を引き出すことができます。最悪の場合、どちらかの当事者が協力を拒否し、最新のコミットメントトランザクションで一方的にクローズすることを強制することもできます。その場合、彼らも資金を待たなければなりません。

[role="less_space pagebreak-before"]
==== 非対称の取り消し可能なコミットメント

以前のコミットメント状態を処理する別の方法は、それらを明示的に取り消すことです。しかし、これは簡単には達成できません。Bitcoin の重要な特徴は、一度トランザクションが有効になると、それが有効なままであり、期限が切れることがないということです。トランザクションをキャンセルする唯一の方法は、競合するトランザクションを確認することです。そのため、単純なペイメントチャネルの例では、より新しいコミットメントが古いコミットメントよりも先に使用できるようにタイムロックを使用しました。しかし、コミットメントを時間で順序付けることは、ペイメントチャネルの使用を難しくする多くの制約を生み出します。

トランザクションをキャンセルすることはできませんが、使用することが望ましくないように構築することは可能です。その方法は、各当事者に _取り消しキー_ を与え、相手が不正を試みた場合に罰するために使用できるようにすることです。この以前のコミットメントトランザクションを取り消すメカニズムは、LN の一部として最初に提案されました。

取り消しキーを説明するために、Hitesh と Irene が運営する 2 つの取引所間でより複雑なペイメントチャネルを構築します。Hitesh と Irene はそれぞれインドとアメリカで Bitcoin 取引所を運営しています。Hitesh のインドの取引所の顧客は、しばしば Irene のアメリカの取引所の顧客に送金し、その逆もまた然りです。現在、これらのトランザクションは Bitcoin ブロックチェーン上で行われていますが、これは手数料を支払い、確認のためにいくつかのブロックを待つことを意味します。取引所間でペイメントチャネルを設定することで、コストを大幅に削減し、トランザクションの流れを加速できます。

Hitesh と Irene は、共同で資金調達トランザクションを構築し、それぞれ 5 ビットコインでチャネルに資金を提供することでチャネルを開始します。資金調達トランザクションに署名する前に、最初のコミットメントセット（_払い戻し_ と呼ばれる）に署名し、Hitesh に 5 ビットコイン、Irene に 5 ビットコインの初期残高を割り当てる必要があります。資金調達トランザクションは、単純なチャネルの例と同様に、2-of-2 マルチシグでチャネル状態をロックします。

資金取引は、Hitesh からの 1 つ以上のインプット（合計で 5 ビットコイン以上）と、Irene からの 1 つ以上のインプット（合計で 5 ビットコイン以上）を持つことができます。インプットは、取引手数料をカバーするために、チャネル容量をわずかに超える必要があります。この取引には、Hitesh と Irene の両方が管理する 2-of-2 マルチシグアドレスに 10 ビットコインをロックする 1 つのアウトプットがあります。資金取引はまた、Hitesh と Irene のインプットが意図したチャネルの寄与を超えた場合に、彼らにお釣りを返す 1 つ以上のアウトプットを持つことができます。これは、2 つの当事者によって提供され、署名されたインプットを持つ単一の取引です。送信される前に、各当事者が協力して構築し、署名しなければなりません。

次に、両当事者が署名する単一のコミットメント取引を作成する代わりに、Hitesh と Irene は _非対称_ な 2 つの異なるコミットメント取引を作成します。

Hitesh は 2 つのアウトプットを持つコミットメント取引を持っています。最初のアウトプットは、Irene に彼女が即座に受け取るべき 5 ビットコインを支払います。2 番目のアウトプットは、Hitesh に彼が受け取るべき 5 ビットコインを支払いますが、1,000 ブロックのタイムロックの後にのみ支払われます。取引のアウトプットは次のようになります：

----
Input: 2-of-2 funding output, signed by Irene

Output 0 <5 bitcoins>:
    <Irene's Public Key> CHECKSIG

Output 1 <5 bitcoins>:
    <1000 blocks>
    CHECKSEQUENCEVERIFY
    DROP
    <Hitesh's Public Key> CHECKSIG
----

Irene は、2 つのアウトプットを持つ異なるコミットメント取引を持っています。最初のアウトプットは、Hitesh に彼が即座に受け取るべき 5 ビットコインを支払います。2 番目のアウトプットは、Irene に彼女が受け取るべき 5 ビットコインを支払いますが、1,000 ブロックのタイムロックの後にのみ支払われます。Irene が持つコミットメント取引（Hitesh によって署名されたもの）は次のようになります：

----
Input: 2-of-2 funding output, signed by Hitesh

Output 0 <5 bitcoins>:
    <Hitesh's Public Key> CHECKSIG

Output 1 <5 bitcoins>:
    <1000 blocks>
    CHECKSEQUENCEVERIFY
    DROP
    <Irene's Public Key> CHECKSIG
----

このようにして、各当事者は 2-of-2 資金アウトプットを消費するコミットメント取引を持っています。このインプットは _他方_ の当事者によって署名されています。取引を保持している当事者はいつでも署名（2-of-2 を完成させる）してブロードキャストすることができます。しかし、コミットメント取引をブロードキャストすると、他方の当事者に即座に支払われる一方で、自分はタイムロックが解除されるまで待たなければなりません。アウトプットの一つの償還に遅延を課すことで、コミットメント取引を一方的にブロードキャストする際に各当事者にわずかな不利を与えます。しかし、時間遅延だけでは公正な行動を促すには不十分です。

<<asymmetric_commitments>> では、コミットメントを保持する側への支払いが遅延する、2 つの非対称コミットメントトランザクションを示します。

[[asymmetric_commitments]]
.コミットメントを保持する側への支払いが遅延する 2 つの非対称コミットメントトランザクション。
image::images/mbc3_1405.png["コミットメントを保持する側への支払いが遅延する 2 つの非対称コミットメントトランザクション"]

ここで、このスキームの最終要素を紹介します。期限切れのコミットメントを不正に放送することを防ぐための取り消しキーです。取り消しキーは、不正を働いた相手を罰するために、被害を受けた側がチャネルの全残高を取得できるようにします。

取り消しキーは 2 つの秘密から構成され、それぞれのチャネル参加者が独立して半分ずつ生成します。これは 2-of-2 マルチシグに似ていますが、楕円曲線演算を使用して構築されており、両方の参加者が取り消し公開鍵を知っているものの、各参加者は取り消し秘密鍵の半分しか知りません。

各ラウンドで、両方の参加者は自分の取り消し秘密の半分を相手に公開します。これにより、相手は（今や両方の半分を持っているため）この取り消されたトランザクションが放送された場合にペナルティ出力を請求する手段を得ます。

各コミットメントトランザクションには「遅延」出力があります。その出力のリデンプションスクリプトは、一方の参加者が 1,000 ブロック後にそれを引き換えることを許可し、_または_ 取り消しキーを持っている場合に他方の参加者がそれを引き換えることを許可し、取り消されたコミットメントの送信を罰します。

したがって、ヒテシュがアイリーンに署名させるためのコミットメントトランザクションを作成するとき、彼は 1,000 ブロック後に自分自身に支払われるか、取り消し公開鍵（彼は秘密の半分しか知らない）に支払われるように第 2 出力を作成します。ヒテシュはこのトランザクションを構築します。彼は新しいチャネル状態に移行し、このコミットメントを取り消したいときにのみ、アイリーンに取り消し秘密の半分を公開します。

[role="less_space pagebreak-before"]
第 2 出力のスクリプトは次のようになります：

----
Output 0 <5 bitcoins>:
    <Irene's Public Key> CHECKSIG

Output 1 <5 bitcoins>:
IF
    # 取り消しペナルティ出力
    <Revocation Public Key>
ELSE
    <1000 blocks>
    CHECKSEQUENCEVERIFY
    DROP
    <Hitesh's Public Key>
ENDIF
CHECKSIG
----

Irene は、このトランザクションに自信を持って署名できます。なぜなら、送信されればすぐに彼女が受け取るべき金額が支払われるからです。Hitesh はトランザクションを保持していますが、一方的にチャネルを閉じる場合には、支払いを受けるまでに 1,000 ブロック待たなければならないことを知っています。

チャネルが次の状態に進むと、Irene がさらにコミットメントトランザクションに署名することに同意する前に、Hitesh はこのコミットメントトランザクションを*無効化*しなければなりません。そのためには、彼がしなければならないのは、自分の半分の*無効化キー*を Irene に送ることだけです。Irene がこのコミットメントの無効化秘密キーの両方の半分を持つと、彼女は将来のコミットメントに自信を持って署名できます。Hitesh が以前のコミットメントを公開して不正を試みた場合、Irene は無効化キーを使用して Hitesh の遅延出力を引き出すことができます。*Hitesh が不正を行った場合、Irene は両方の出力を得ることができます*。一方、Hitesh はその無効化公開キーの無効化秘密キーの半分しか持っておらず、1,000 ブロックまで出力を引き出すことができません。Irene は 1,000 ブロックが経過する前に出力を引き出して Hitesh を罰することができます。

無効化プロトコルは双方向であり、各ラウンドでチャネルの状態が進むと、両者は新しいコミットメントを交換し、以前のコミットメントの無効化秘密を交換し、お互いの新しいコミットメントトランザクションに署名します。新しい状態を受け入れた後、以前の状態を使用できなくするために、互いに不正を罰するための必要な無効化秘密を渡します。

その仕組みを例で見てみましょう。Irene の顧客の一人が Hitesh の顧客の一人に 2 ビットコインを送信したいとします。チャネルを介して 2 ビットコインを送信するために、Hitesh と Irene は新しい残高を反映するようにチャネルの状態を進めなければなりません。彼らはチャネルの 10 ビットコインが Hitesh に 7 ビットコイン、Irene に 3 ビットコインに分割される新しい状態（状態番号 2）にコミットします。チャネルの状態を進めるために、彼らはそれぞれ新しいチャネル残高を反映する新しいコミットメントトランザクションを作成します。

[role="less_space pagebreak-before"]
以前と同様に、これらのコミットメントトランザクションは非対称であり、各当事者が保持するコミットメントトランザクションは、それを引き出す場合に待機を強制します。重要なのは、新しいコミットメントトランザクションに署名する前に、まず無効化キーを交換して古いコミットメントを無効にする必要があることです。この特定のケースでは、Hitesh の利益はチャネルの実際の状態と一致しているため、以前の状態を放送する理由はありません。しかし、Irene にとって、状態番号 1 は状態番号 2 よりも高い残高を残します。Irene が以前のコミットメントトランザクション（状態番号 1）の無効化キーを Hitesh に渡すと、彼女はチャネルを以前の状態に戻して利益を得る能力を事実上無効にしています。なぜなら、無効化キーを持つ Hitesh は、遅延なしに以前のコミットメントトランザクションの両方の出力を引き出すことができるからです。つまり、Irene が以前の状態を放送すると、Hitesh はすべての出力を取得する権利を行使できるのです。

重要な点として、取り消しは自動的には行われません。ヒテシュはアイリーンの不正行為を罰する能力を持っていますが、不正行為の兆候を見逃さないようにブロックチェーンを注意深く監視する必要があります。もし以前のコミットメントトランザクションが放送されたのを見た場合、彼は 1,000 ブロックの間に行動を起こし、取り消しキーを使ってアイリーンの不正行為を阻止し、全 10 ビットコインの残高をすべて奪うことで彼女を罰することができます。

非対称の取り消し可能なコミットメントと相対的なタイムロック (+CSV+) は、ペイメントチャネルを実装するためのはるかに優れた方法であり、この技術における非常に重要な革新です。この構造を使用すると、チャネルは無期限に開いたままにすることができ、数十億の中間コミットメントトランザクションを持つことができます。LN の実装では、コミットメントの状態は 48 ビットのインデックスで識別され、単一のチャネル内で 281 兆（2.8 × 10^14^）以上の状態遷移が可能です。

==== ハッシュタイムロック契約 (HTLC)

ペイメントチャネルは、参加者が償還可能な秘密に資金をコミットし、期限を設定できる特別なタイプのスマートコントラクトでさらに拡張できます。この機能は _ハッシュタイムロック契約_、または _HTLC_ と呼ばれ、双方向およびルーティングされたペイメントチャネルの両方で使用されます。

まず、HTLC の「ハッシュ」部分を説明しましょう。HTLC を作成するために、支払いの受取人はまず秘密 _R_ を作成します。次に、この秘密のハッシュ _H_ を計算します：

[latexmath]
++++
\begin{equation}
H = Hash(R)
\end{equation}
++++

これにより、出力のスクリプトに含めることができるハッシュ _H_ が生成されます。秘密を知っている人はそれを使って出力を償還することができます。秘密 _R_ は、ハッシュ関数の _プレイメージ_ とも呼ばれます。プレイメージは、ハッシュ関数への入力として使用されるデータにすぎません。

[role="less_space pagebreak-before"]
HTLC の第 2 の要素は「タイムロック」コンポーネントです。秘密が明かされない場合、HTLC の支払者は一定時間後に「払い戻し」を受けることができます。これは +CHECKLOCKTIMEVERIFY+ を使用した絶対的なタイムロックによって実現されます。

HTLC を実装するスクリプトは次のようになります：

----
IF
    # 秘密 R を持っている場合の支払い
    HASH160 <H> EQUALVERIFY
    <受取人の公開鍵> CHECKSIG
ELSE
    # タイムアウト後の払い戻し
    <ロックタイム> CHECKLOCKTIMEVERIFY DROP
    <支払者の公開鍵> CHECKSIG
ENDIF
----

秘密 _R_ を知っている人は、そのハッシュが _H_ に等しい場合、+IF+ フローの最初の条項を行使してこの出力を引き出すことができます。

秘密が明かされず、一定数のブロック後に HTLC が請求された場合、支払者は +IF+ フローの第 2 条項を使用して払い戻しを請求できます。

これは HTLC の基本的な実装です。このタイプの HTLC は、秘密 _R_ を持っている _誰でも_ 引き出すことができます。HTLC はスクリプトにわずかな変更を加えることで多くの異なる形式を取ることができます。例えば、最初の条項に +CHECKSIG+ 演算子と公開鍵を追加することで、ハッシュの引き出しを特定の受取人に制限し、その受取人も秘密 _R_ を知っている必要があります。

[[lightning_network]]
=== ルーティングされた支払いチャネル (ライトニングネットワーク)

ライトニングネットワーク (LN) は、双方向の支払いチャネルがエンドツーエンドで接続されたルーティングネットワークとして提案されています。このようなネットワークは、参加者が中間者を信頼することなく、チャネルからチャネルへと支払いをルーティングすることを可能にします。LN は、支払いチャネルの概念に基づいて、他の多くの人々によって提案および詳述されたものを基に、ジョセフ・プーンとタデウス・ドライジャによって 2015 年 2 月に初めて説明されました。

「Lightning Network」とは、ルーティングされたペイメントチャネルネットワークの特定の設計を指します。これは現在、少なくとも 5 つの異なるオープンソースチームによって実装されています。独立した実装は、https://oreil.ly/lIGIA[_Basics of Lightning Technology (BOLT)_ repository] に記載されている一連の相互運用性標準によって調整されています。

==== Basic Lightning Network Example

Lightning Network (LN) がどのように機能するかを見てみましょう。

この例では、5 人の参加者がいます。アリス、ボブ、キャロル、ダイアナ、エリックです。これらの 5 人の参加者は、それぞれペアでペイメントチャネルを開設しています。アリスはボブとペイメントチャネルを持っています。ボブはキャロルと接続しており、キャロルはダイアナと、ダイアナはエリックと接続しています。簡単のために、各チャネルは各参加者によって 2 ビットコインで資金提供されていると仮定し、各チャネルの総容量は 4 ビットコインです。

<<lightning_network_fig>> は、アリスからエリックへの支払いを行うためにリンクできる双方向ペイメントチャネルで接続された LN 内の 5 人の参加者を示しています (<<lightning_network>> を参照)。

[[lightning_network_fig]]
.アリスからエリックへの支払いをルーティングできるようにリンクされた一連の双方向ペイメントチャネル。
image::images/mbc3_1406.png["A series of bi-directional payment channels linked to form a Lightning Network"]

アリスはエリックに 1 ビットコインを支払いたいと考えています。しかし、アリスはエリックとペイメントチャネルで接続されていません。ペイメントチャネルを作成するには、ビットコインブロックチェーンにコミットされる資金調達トランザクションが必要です。アリスは新しいペイメントチャネルを開設して、さらに資金をコミットしたくありません。エリックに間接的に支払う方法はあるのでしょうか？

<<ln_payment_process>> は、参加者を接続するペイメントチャネル上の一連の HTLC コミットメントを通じて、アリスからエリックへの支払いをルーティングするステップバイステップのプロセスを示しています。

[[ln_payment_process]]
.LN を通じたステップバイステップの支払いルーティング。
image::images/mbc3_1407.png["Step-by-step payment routing through a Lightning Network"]

Alice は、Bob との支払いチャネルを管理し、支払いチャネル間のルートを発見する能力を持つ LN ノードを運用しています。Alice の LN ノードは、インターネットを介して Eric の LN ノードに接続する能力も持っています。Eric の LN ノードは、乱数生成器を使用して秘密 +R+ を作成します。Eric のノードはこの秘密を誰にも明かしません。代わりに、Eric のノードは秘密 +R+ のハッシュ +H+ を計算し、このハッシュを請求書の形で Alice のノードに送信します (<<ln_payment_process>>, [.keep-together]#step 1 を参照)。

ここで、Alice の LN ノードは Alice の LN ノードと Eric の LN ノードの間のルートを構築します。使用される経路探索アルゴリズムについては後で詳しく説明しますが、今は Alice のノードが効率的なルートを見つけられると仮定します。

次に、Alice のノードはハッシュ +H+ に支払われる HTLC を構築し、10 ブロックの返金タイムアウト (現在のブロック + 10) を設定し、1.003 ビットコインの金額を設定します (<<ln_payment_process>>, step 2 を参照)。追加の 0.003 は、この支払いルートに参加する中間ノードへの補償として使用されます。Alice はこの HTLC を Bob に提供し、Bob とのチャネル残高から 1.003 ビットコインを差し引き、HTLC にコミットします。HTLC の意味は次のとおりです：「Alice は、Bob が秘密を知っている場合に Bob に支払われる 1.003 ビットコインをチャネル残高からコミットし、10 ブロックが経過した場合には Alice の残高に返金される。」Alice と Bob の間のチャネル残高は、3 つの出力を持つコミットメントトランザクションによって表されます：Bob に 2 ビットコイン、Alice に 0.997 ビットコイン、Alice の HTLC にコミットされた 1.003 ビットコイン。Alice の残高は HTLC にコミットされた金額によって減少します。

Bob は、次の 10 ブロック以内に秘密 +R+ を取得できれば、Alice によってロックされた 1.003 ビットコインを請求できるというコミットメントを持っています。このコミットメントを手にした Bob のノードは、Carol との支払いチャネルに HTLC を構築します。Bob の HTLC は、9 ブロックの間にハッシュ +H+ に 1.002 ビットコインをコミットし、Carol が秘密 +R+ を持っていればそれを引き換えることができます (<<ln_payment_process>> step 3 を参照)。Bob は、Carol が彼の HTLC を請求できる場合、+R+ を生成しなければならないことを知っています。Bob が 9 ブロック以内に +R+ を持っていれば、それを使用して Alice の HTLC を請求できます。また、9 ブロックの間にチャネル残高をコミットすることで 0.001 ビットコインを得ます。Carol が彼の HTLC を請求できず、彼が Alice の HTLC を請求できない場合、すべてが以前のチャネル残高に戻り、誰も損失を被りません。Bob と Carol の間のチャネル残高は現在、Carol に 2、Bob に 0.998、Bob によって HTLC にコミットされた 1.002 です。

キャロルは、次の 9 ブロック以内に +R+ を取得できれば、ボブによってロックされた 1.002 ビットコインを請求できるコミットメントを持っています。これにより、キャロルはダイアナとのチャネルで HTLC コミットメントを行うことができます。彼女は +H+ に対して 1.001 ビットコインの HTLC を 8 ブロックの間コミットし、ダイアナは秘密 +R+ を持っていればそれを引き換えることができます（<<ln_payment_process>>、ステップ 4 を参照）。キャロルの視点から見ると、これがうまくいけば 0.001 ビットコイン得をし、うまくいかなくても何も失いません。彼女のダイアナへの HTLC は +R+ が公開される場合にのみ有効で、その時点で彼女はボブから HTLC を請求できます。キャロルとダイアナの間のチャネル残高は次のようになります。ダイアナに 2、キャロルに 0.999、キャロルが HTLC にコミットした 1.001。

最後に、ダイアナはエリックに HTLC を提供し、7 ブロックの間 +H+ に対して 1 ビットコインをコミットします（<<ln_payment_process>>、ステップ 5 を参照）。ダイアナとエリックの間のチャネル残高は次のようになります。エリックに 2、ダイアナに 1、ダイアナが HTLC にコミットした 1。

しかし、このルートのこのホップで、エリックは秘密 +R+ を持っています。したがって、彼はダイアナが提供した HTLC を請求できます。彼は +R+ をダイアナに送り、1 ビットコインを請求し、それを彼のチャネル残高に追加します（<<ln_payment_process>>、ステップ 6 を参照）。チャネル残高は次のようになります。ダイアナに 1、エリックに 3。

今、ダイアナは秘密 +R+ を持っています。したがって、彼女はキャロルから HTLC を請求できます。ダイアナは +R+ をキャロルに送信し、1.001 ビットコインを彼女のチャネル残高に追加します（<<ln_payment_process>>、ステップ 7 を参照）。キャロルとダイアナの間のチャネル残高は次のようになります。キャロルに 0.999、ダイアナに 3.001。ダイアナはこの支払いルートに参加することで 0.001 を「稼ぎ」ました。

ルートを逆流するように、秘密 +R+ は各参加者が未解決の HTLC を請求することを可能にします。キャロルはボブから 1.002 を請求し、彼らのチャネルの残高を次のように設定します。ボブに 0.998、キャロルに 3.002（<<ln_payment_process>>、ステップ 8 を参照）。最後に、ボブはアリスから HTLC を請求します（<<ln_payment_process>>、ステップ 9 を参照）。彼らのチャネル残高は次のように更新されます。アリスに 0.997、ボブに 3.003。

アリスはエリックに 1 ビットコインを支払い、エリックにチャネルを開くことなく支払いました。支払いルートの中間のどの当事者もお互いを信頼する必要はありませんでした。チャネル内の資金を短期間コミットすることで、彼らは小さな手数料を稼ぐことができ、唯一のリスクはチャネルが閉じられた場合やルートされた支払いが失敗した場合の小さな返金の遅延です。


==== Lightning Network Transport and Pathfinding

LN ノード間のすべての通信は、ポイントツーポイントで暗号化されます。さらに、ノードは長期的な公開鍵を持ち、それを識別子として使用し、お互いを認証します。

ノードが他のノードに支払いを送信したい場合、まず十分な容量を持つ支払いチャネルを接続してネットワークを通る _パス_ を構築する必要があります。ノードは、どのチャネルを開いているか、各チャネルの容量、支払いをルートするための手数料などのルーティング情報を広告します。ルーティング情報はさまざまな方法で共有でき、LN 技術が進化するにつれて異なる経路探索プロトコルが登場しています。現在の経路発見の実装は、ノードがチャネルアナウンスをピアに「フラッディング」モデルで伝播する P2P モデルを使用しており、これはビットコインがトランザクションを伝播する方法に似ています。

++++
<p class="fix_tracking3">
前の例では、アリスのノードがこれらの経路発見メカニズムの一つを使用して、彼女のノードとエリックのノードを接続する一つ以上のパスを見つけます。アリスのノードがパスを構築すると、彼女はネットワークを通じて一連の暗号化されたネストされた指示を伝播し、隣接する各支払いチャネルを接続してそのパスを初期化します。
</p>

<p class="fix_tracking2">
重要なのは、このパスがアリスのノードにのみ知られていることです。支払いルートの他の参加者は、隣接するノードのみを見ます。キャロルの視点から見ると、これはボブからダイアナへの支払いのように見えます。キャロルは、ボブが実際にはアリスからの支払いを中継していることを知りません。また、ダイアナがエリックに支払いを中継することも知りません。</p>
++++

これは LN の重要な機能であり、支払いのプライバシーを確保し、監視、検閲、ブラックリストの適用を困難にします。しかし、アリスはどのようにして中間ノードに何も明かさずにこの支払いパスを確立するのでしょうか。

LN は、https://oreil.ly/fuCiK[Sphinx] と呼ばれるスキームに基づいたオニオンルーティングプロトコルを実装しています。このルーティングプロトコルは、支払い送信者が LN を通じてパスを構築し、通信できることを保証します。具体的には次のような特徴があります：

++++
<ul>
<li> 中間ノードは、自分のルート情報の部分を検証し復号化して、次のホップを見つけることができます。</li>

<li> 前後のホップ以外に、パスの一部である他のノードについて知ることはできません。</li>

<li> 支払いパスの長さや、自分のパス内での位置を特定することはできません。</li>

<li> パスの各部分は、ネットワークレベルの攻撃者がパスの異なる部分からのパケットを互いに関連付けることができないように暗号化されています。</li>

<li><p class="fix_tracking3">Tor（インターネット上のオニオンルーティング匿名化プロトコル）とは異なり、監視下に置かれる可能性のある「出口ノード」は存在しません。支払いは Bitcoin ブロックチェーンに送信する必要がなく、ノードはチャネル残高を更新するだけです。</p>
  </li>
  </ul>
++++

このオニオンルーティングプロトコルを使用して、アリスはパスの各要素を暗号化の層で包みます。終点から始めて逆方向に進みます。彼女はエリックへのメッセージをエリックの公開鍵で暗号化します。このメッセージは、次の受信者としてエリックを識別するダイアナへのメッセージに包まれています。ダイアナへのメッセージは、次の受信者としてダイアナを識別するキャロルの公開鍵で暗号化されたメッセージに包まれています。キャロルへのメッセージはボブの鍵で暗号化されています。このようにして、アリスは暗号化された多層の「オニオン」メッセージを構築しました。彼女はこれをボブに送信し、ボブは外側の層だけを復号化して解くことができます。内部にはキャロル宛のメッセージがあり、ボブはこれをキャロルに転送できますが、自分では解読できません。このパスに沿って、メッセージは転送され、復号化され、転送されるというプロセスがエリックに到達するまで続きます。各参加者は、各ホップで前後のノードだけを知っています。

パスの各要素には、次のホップに拡張されるべき HTLC、送信される金額、含めるべき手数料、HTLC の CLTV ロックタイム（ブロック単位）の有効期限に関する情報が含まれています。ルート情報が伝播するにつれて、ノードは次のホップに向けて HTLC コミットメントを行います。

この時点で、ノードが経路の長さやその経路内での自分の位置を知らないのはどうしてか疑問に思うかもしれません。結局のところ、ノードはメッセージを受け取り、次のホップに転送します。それが短くなり、経路のサイズや自分の位置を推測できるのではないでしょうか？これを防ぐために、パケットサイズは固定され、ランダムなデータでパディングされます。各ノードは次のホップと転送する固定長の暗号化メッセージを見ます。最終受信者だけが次のホップがないことを確認できます。他のすべてのノードには、常に次のホップがあるように見えます。

==== Lightning Network Benefits

LN は第二層のルーティング技術です。マルチシグネチャトランザクション、タイムロック、基本的なスマートコントラクトなどの基本的な機能をサポートする任意のブロックチェーンに適用できます。

LN はビットコインネットワークの上にレイヤー化されており、ビットコインに大幅な容量、プライバシー、粒度、速度の向上をもたらしますが、中間者なしで信頼性のある操作の原則を犠牲にすることはありません：

プライバシー：LN 支払いはビットコインブロックチェーン上の支払いよりもはるかにプライベートです。ルートの参加者は自分のチャネルを通じて支払いが伝播するのを見ることができますが、送信者や受信者を知ることはできません。

代替可能性：LN はビットコインに対する監視やブラックリストの適用を非常に困難にし、通貨の代替可能性を高めます。

速度：LN を使用したビットコイントランザクションは、トランザクションをブロックにコミットすることなく HTLC がクリアされるため、数分または数時間ではなくミリ秒で決済されます。

粒度：LN はビットコインの「ダスト」制限と同じくらい小さい、あるいはそれよりも小さい支払いを可能にします。

容量：LN はビットコインシステムの容量を数桁増加させます。Lightning Network を介してルーティングできる毎秒の支払い数の上限は、各ノードの容量と速度にのみ依存します。

信頼不要の操作：LN は、ノード間でビットコイン取引を使用し、互いに信頼することなくピアとして動作します。したがって、LN はビットコインシステムの原則を維持しながら、その動作パラメータを大幅に拡張します。

私たちは、ビットコインブロックチェーンを信頼プラットフォームとして使用して構築できる新たなアプリケーションのほんの一部を検討しました。これらのアプリケーションは、ビットコインの範囲を支払いを超えて拡大します。

この本の最後まで到達した今、あなたは得た知識をどう活用しますか？何百万、あるいは何十億もの人々が「ビットコイン」という名前を知っていますが、その中でビットコインの仕組みをあなたほど詳しく知っている人はごくわずかです。その知識は貴重です。それ以上に貴重なのは、ビットコインに非常に興味を持ち、数百ページにわたる内容を読むことをいとわないあなたのような人々です。

もしまだ始めていないのであれば、何らかの形でビットコインに貢献することを考えてみてください。受け取ったビットコインの支払いを検証するためにフルノードを運用したり、他の人がビットコインを使いやすくするアプリケーションを構築したり、ビットコインとその可能性について他の人を教育する手助けをしたりできます。さらには、ビットコインコアのようなオープンソースのビットコインインフラストラクチャソフトウェアに貢献するという希少なステップを踏むこともできます。これは、誰も支払うことのないツールを構築するために、非常に賢い少数の人々と慎重に協力することを意味しますが、いつの日か何十億もの人々がそれに依存するかもしれません。

どのようなビットコインの旅を選ぶにせよ、_Mastering Bitcoin_ をその一部にしていただき、ありがとうございます。

ファイルが添付されていないようです。Markdown ファイルをアップロードしてください。
