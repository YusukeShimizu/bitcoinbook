[[bitcoin_network_ch08]]
== The Bitcoin Network

Bitcoin は、インターネット上に構築されたピアツーピアネットワークアーキテクチャとして構成されています。ピアツーピア、または P2P という用語は、ネットワークに参加するフルノードが互いにピアであり、すべてのノードが同じ機能を実行でき、「特別な」ノードが存在しないことを意味します。ネットワークノードは、メッシュネットワークで「フラット」なトポロジーで相互接続します。サーバーも中央集権的なサービスもネットワーク内に階層もありません。P2P ネットワークのノードは、サービスを提供しながら同時に消費もします。P2P ネットワークは本質的にレジリエントで、分散型で、オープンです。P2P ネットワークアーキテクチャの代表的な例は、初期のインターネットそのものであり、IP ネットワーク上のノードは平等でした。今日のインターネットアーキテクチャはより階層的ですが、インターネットプロトコルは依然としてそのフラットなトポロジーの本質を保持しています。Bitcoin やインターネットを超えて、P2P 技術の最大かつ最も成功した応用はファイル共有であり、Napster が先駆者であり、BitTorrent がアーキテクチャの最新の進化形です。

Bitcoin の P2P ネットワークアーキテクチャは、単なるトポロジーの選択以上のものです。Bitcoin は設計上、P2P デジタルキャッシュシステムであり、ネットワークアーキテクチャはその核心的な特徴の反映であり基盤でもあります。制御の分散化は、フラットで分散型の P2P コンセンサスネットワークによってのみ達成され維持されることができる、基本的な設計原則です。

「Bitcoin ネットワーク」という用語は、Bitcoin P2P プロトコルを実行しているノードの集合を指します。Bitcoin P2P プロトコルに加えて、マイニングや軽量ウォレットに使用される他のプロトコルもあります。これらの追加プロトコルは、Bitcoin P2P プロトコルを使用して Bitcoin ネットワークにアクセスし、他のプロトコルを実行しているノードにそのネットワークを拡張するゲートウェイルーティングサーバーによって提供されます。たとえば、Stratum サーバーは Stratum プロトコルを介して Stratum マイニングノードをメインの Bitcoin ネットワークに接続し、Stratum プロトコルを Bitcoin P2P プロトコルに橋渡しします。この章では、基本的な Bitcoin P2P プロトコルに加えて、最も一般的に使用されるこれらのプロトコルのいくつかについて説明します。


=== ノードの種類と役割

Bitcoin P2Pネットワーク内のフルノード（ピア）は互いに等しいですが、サポートしている機能に応じて異なる役割を担うことがあります。Bitcoinのフルノードはブロックを検証し、ルーティング、マイニング、ウォレットサービスなどの他の機能を含むことがあります。

_アーカイバルフルノード_ と呼ばれる一部のノードは、ブロックチェーンの完全で最新のコピーを維持します。これらのノードは、ブロックチェーンの一部のみを保存し、_簡易支払い検証_（SPV）と呼ばれる方法を使用してトランザクションを部分的に検証するクライアントにデータを提供できます。これらのクライアントは軽量クライアントとして知られています。

マイナーは、プルーフ・オブ・ワークアルゴリズムを解くために特化したハードウェアを使用して新しいブロックを作成するために競争します。一部のマイナーはフルノードを運用し、ブロックチェーン上のすべてのブロックを検証しますが、他のマイナーはプールマイニングに参加し、プールサーバーから作業を提供されるクライアントです。

ユーザのウォレットは、ユーザ自身のフルノードに接続することがありますが、特にスマートフォンのようなリソースが制約されたデバイスで動作する多くのユーザウォレットは軽量ノードです。

Bitcoin P2Pプロトコルの主なノードタイプに加えて、特化したマイニングプールプロトコルや軽量クライアントアクセスプロトコルなど、他のプロトコルを実行するサーバーやノードも存在します。

=== ネットワーク

この執筆時点で、Bitcoin P2Pプロトコルを実行しているメインのBitcoinネットワークは、約10,000のリスニングノードで構成されており、さまざまなバージョンのBitcoin Coreを実行しているノードと、BitcoinJ、btcd、bcoinなどのBitcoin P2Pプロトコルの他の実装を実行している数百のノードがあります。Bitcoin P2Pネットワーク上のノードの小さな割合はマイニングノードでもあります。さまざまな個人や企業がアーカイバルフルノードを運用し、ブロックチェーンの完全なコピーとネットワークノードを持ちながら、マイニングやウォレット機能を持たない形でBitcoinネットワークとインターフェースしています。これらのノードはネットワークエッジルーターとして機能し、さまざまな他のサービス（取引所、ウォレット、ブロックエクスプローラー、商人の支払い処理）がその上に構築されることを可能にします。

[role="less_space pagebreak-before"]
=== コンパクトブロックリレー

新しいブロックを見つけた((("Bitcoinネットワーク", "ノード", "コンパクトブロックリレー", id="bitcoin-network-node-compact-relay")))((("ノード", "コンパクトブロックリレー", id="node-compact-relay")))((("ブロック", "コンパクトブロックリレー", id="block-compact-relay")))((("コンパクトブロックリレー", id="compact-block-relay")))((("マイニング", "ブロック", "コンパクトブロックリレー", id="mining-block-compact-relay")))マイナーは、そのブロックをBitcoinネットワーク（他のマイナーも含む）にアナウンスします。そのブロックを見つけたマイナーはすぐにその上に新しいブロックを構築し始めることができます。まだそのブロックについて知らない他のマイナーは、それを知るまで前のブロックの上に構築を続けます。

新しいブロックを知る前に、他のマイナーの一人がブロックを作成した場合、そのブロックは最初のマイナーの新しいブロックと競合することになります。全てのフルノードが使用するブロックチェーンに含まれるのはどちらか一方のブロックだけであり、マイナーは広く受け入れられたブロックに対してのみ報酬を得ることができます。

どちらのブロックの上に最初に2番目のブロックが構築されるかが勝敗を決めます（他の近接した競争がない限り）。これは((("ブロック発見競争"))) _ブロック発見競争_ と呼ばれ、<<mining_race>>に示されています。
ブロック発見競争は大規模なマイナーに有利であり、Bitcoinの本質的な分散化に反します。ブロック発見競争を防ぎ、どの規模のマイナーでもBitcoinマイニングという宝くじに平等に参加できるようにするためには、あるマイナーが新しいブロックをアナウンスしてから他のマイナーがそのブロックを受け取るまでの時間を最小限に抑えることが非常に重要です。

[[mining_race]]
.マイニング競争を必要とするブロックチェーンのフォーク。
image::images/mbc3_1001.png["Mining race"]

2015年、新しいバージョンのBitcoin Coreに、_コンパクトブロックリレー_（BIP152で規定）という機能が追加され、新しいブロックの転送がより速く、かつ帯域幅を少なくすることができるようになりました。

背景として、未確認トランザクションをリレーするフルノードは、それらのトランザクションの多くをメンプールに保存します（<<mempool>>参照）。これらのトランザクションの一部が新しいブロックで確認されると、ノードはそれらのトランザクションの2つ目のコピーを受け取る必要がありません。

冗長な未確認トランザクションを受け取る代わりに、コンパクトブロックは各トランザクションに対して短い 6 バイトの識別子を送信することを可能にします。ノードが 1 つ以上の識別子を含むコンパクトブロックを受信すると、それらのトランザクションをメモリプールで確認し、見つかった場合はそれを使用します。ローカルノードのメモリプールに見つからないトランザクションについては、ノードはピアにコピーを要求できます。

逆に、リモートピアがノードのメモリプールにブロックに現れるトランザクションの一部がないと考える場合、それらのトランザクションのコピーをコンパクトブロックに含めることができます。例えば、Bitcoin Core は常にブロックのコインベーストランザクションを送信します。

リモートピアがノードのメモリプールにあるトランザクションとないトランザクションを正確に推測できた場合、理論上可能な限り効率的にブロックを送信します（典型的なブロックでは、97% から 99% の効率になります）。

[TIP]
====
コンパクトブロックリレーはブロックのサイズを減少させません。ノードがすでに持っている情報の冗長な転送を防ぐだけです。ノードがブロックに関する情報を事前に持っていない場合、例えばノードが最初に起動されたときには、各ブロックの完全なコピーを受け取る必要があります。
====

Bitcoin Core が現在実装しているコンパクトブロック送信のモードは 2 つあり、<<bip152_illustration>> に示されています。

低帯域幅モード::
  ノードがピアに低帯域幅モード（デフォルト）を使用するよう要求すると、そのピアは新しいブロックの 32 バイトの識別子（ヘッダーハッシュ）をノードに伝えますが、その詳細は送信しません。ノードが他のソースからそのブロックを先に取得した場合、冗長なコピーを取得するために帯域幅を無駄にすることを避けられます。ノードがそのブロックを必要とする場合、コンパクトブロックを要求します。

高帯域幅モード::
  ノードがピアに高帯域幅モードを使用するよう要求すると、そのピアはブロックが有効であることを完全に検証する前に、新しいブロックのコンパクトブロックをノードに送信します。ピアが行う唯一の検証は、ブロックのヘッダーが正しい量のプルーフ・オブ・ワークを含んでいることを確認することです。プルーフ・オブ・ワークの生成は高価で（執筆時点で約 150,000 USD）、マイナーがリレー ノードの帯域幅を無駄にするためだけにそれを偽造する可能性は低いです。リレー前の検証をスキップすることで、新しいブロックがネットワークを最小限の遅延で伝播できます。
+
高帯域幅モードの欠点は、ノードが選択した各高帯域幅ピアから冗長な情報を受け取る可能性が高いことです。執筆時点では、Bitcoin Core は現在、3 つのピアにのみ高帯域幅モードを使用するよう要求しており、ブロックを迅速に発表する履歴を持つピアを選択しようとします。

```markdown
// released into the public domain by Nicolas Dorier
[[bip152_illustration]]
.BIP152 モードの比較 (BIP152 より)。シェーディングされたバーは、ノードがブロックを検証するのにかかる時間を示しています。
image::images/mbc3_1002.png["BIP152"]

2 つの方法の名前 (BIP152 から取られています) は少し混乱を招くかもしれません。低帯域幅モードは、ほとんどの場合にブロックを送信しないことで帯域幅を節約します。高帯域幅モードは、低帯域幅モードよりも多くの帯域幅を使用しますが、ほとんどの場合、コンパクトブロックが実装される前のブロックリレーに使用されていた帯域幅よりもはるかに少ないです。

=== プライベートブロックリレーネットワーク

コンパクトブロックは、ブロックがネットワーク全体に伝播するのにかかる時間を最小限に抑えるために大いに役立ちますが、レイテンシをさらに最小化することも可能です。ただし、コンパクトブロックとは異なり、他の解決策にはトレードオフが伴い、それらを公共の P2P リレーネットワークで利用できない、または適していないものにします。そのため、ブロックのプライベートリレーネットワークの実験が行われています。

1 つの簡単な技術は、エンドポイント間のルートを事前に選択することです。たとえば、主要な海底光ファイバーラインの近くのデータセンターでサーバーを運用しているリレーネットワークは、光ファイバーラインから何キロも離れた場所でホームユーザーが運用するノードにブロックが到着するのを待つよりも、新しいブロックをより速く転送できるかもしれません。
```

もう一つの、より複雑な技術は、フォワードエラー訂正 (FEC) です。これにより、コンパクトブロックメッセージをいくつかの部分に分割し、各部分に追加データを付加することができます。もしどの部分かが受信されなかった場合、その部分は受信された他の部分から再構築できます。設定によっては、失われた部分をいくつか再構築することが可能です。

FEC は、基盤となるネットワーク接続の問題でコンパクトブロック（またはその一部）が到達しない問題を回避します。これらの問題は頻繁に発生しますが、通常は自動的に欠落したデータを再要求するプロトコルを使用しているため、あまり気づきません。しかし、欠落したデータを要求すると、受信までの時間が 3 倍になります。例えば：

1. アリスがボブにデータを送信します。
2. ボブがデータを受信しない（またはデータが損傷している）。ボブはアリスにデータを再要求します。
3. アリスが再度データを送信します。

第三の技術は、データを受信するすべてのノードがメモリプールにほぼ同じトランザクションを持っていると仮定することです。これにより、各ホップでコンパクトブロックを計算する時間を節約できるだけでなく、各ホップが検証する前に FEC パケットを次のホップに単に中継することができます。

これらの方法のトレードオフは、中央集権化にはうまく機能しますが、個々のノードが他のノードを信頼できない分散型ネットワークではうまく機能しないことです。データセンター内のサーバーは費用がかかり、しばしばデータセンターの運営者によってアクセスされる可能性があるため、安全な家庭用コンピュータよりも信頼性が低くなります。検証する前にデータを中継すると、帯域幅を無駄にするのが容易になるため、ある程度の信頼と責任があるプライベートネットワークでのみ合理的に使用できます。

元の [Bitcoin Relay Network](https://oreil.ly/30ZKi) は、2015 年に開発者の Matt Corallo によって、非常に低いレイテンシーでマイナー間のブロックの高速同期を可能にするために作成されました。このネットワークは、世界中のインフラストラクチャ上にホストされたいくつかの仮想プライベートサーバー (VPS) で構成されており、大多数のマイナーとマイニングプールを接続する役割を果たしました。

元の Bitcoin Relay Network は 2016 年に置き換えられました。開発者 Matt Corallo によって作成された _Fast Internet Bitcoin Relay Engine_、または https://bitcoinfibre.org[_FIBRE_] の導入により、UDP ベースのリレーネットワークを運用するためのソフトウェアです。FIBRE は FEC と _compact block_ 最適化を実装して、送信されるデータ量をさらに削減し、ネットワークのレイテンシーを低減します。

=== Network Discovery

新しいノードが起動すると、ネットワーク上の他の Bitcoin ノードを発見して参加する必要があります。このプロセスを開始するには、新しいノードがネットワーク上の既存のノードを少なくとも 1 つ発見し、それに接続する必要があります。他のノードの地理的位置は関係ありません。Bitcoin ネットワークのトポロジーは地理的に定義されていないため、既存の Bitcoin ノードはランダムに選択できます。

既知のピアに接続するために、ノードは通常ポート 8333（一般的に Bitcoin が使用するポートとして知られている）または提供されている場合は代替ポートに TCP 接続を確立します。接続が確立されると、ノードは +version+ メッセージを送信して「ハンドシェイク」を開始します（<<network_handshake>> を参照）。このメッセージには、以下を含む基本的な識別情報が含まれます。

+Version+:: クライアントが「話す」Bitcoin P2P プロトコルのバージョン（例：70002）
+nLocalServices+:: ノードがサポートするローカルサービスのリスト
+nTime+:: 現在の時刻
+addrYou+:: このノードから見たリモートノードの IP アドレス
+addrMe+:: ローカルノードによって発見されたローカルノードの IP アドレス
+subver+:: このノードで実行されているソフトウェアの種類を示すサブバージョン（例：[.keep-together]#+/Satoshi:0.9.2.1/+#）
+BestHeight+:: このノードのブロックチェーンのブロック高さ
+fRelay+:: 未確認トランザクションを受信しないように要求するために BIP37 によって追加されたフィールド

+version+ メッセージは、どのピアも他のピアに送信する最初のメッセージです。ローカルピアが +version+ メッセージを受信すると、リモートピアの報告した +Version+ を確認し、リモートピアが互換性があるかどうかを判断します。リモートピアが互換性がある場合、ローカルピアは +version+ メッセージを承認し、+verack+ を送信して接続を確立します。

新しいノードはどのようにしてピアを見つけるのでしょうか。最初の方法は、_DNS seeds_ を使用して DNS をクエリすることです。これは、Bitcoin ノードの IP アドレスのリストを提供する DNS サーバです。これらの DNS seeds の一部は、安定した Bitcoin リスニングノードの静的な IP アドレスリストを提供します。DNS seeds の一部は、BIND (Berkeley Internet Name Daemon) のカスタム実装であり、クローラや長期間稼働している Bitcoin ノードによって収集された Bitcoin ノードアドレスのリストからランダムなサブセットを返します。Bitcoin Core クライアントには、いくつかの異なる DNS seeds の名前が含まれています。異なる DNS seeds の所有権と実装の多様性は、初期のブートストラッププロセスに高い信頼性を提供します。Bitcoin Core クライアントでは、DNS seeds を使用するオプションはオプションスイッチ +-dnsseed+ によって制御されます（デフォルトでは 1 に設定されており、DNS seed を使用します）。

あるいは、ネットワークについて何も知らないブートストラップノードは、少なくとも 1 つの Bitcoin ノードの IP アドレスを与えられ、その後さらに紹介を通じて接続を確立する必要があります。コマンドライン引数 +-seednode+ を使用して、紹介のためだけに 1 つのノードに接続し、それをシードとして使用することができます。最初のシードノードを使用して紹介を形成した後、クライアントはそれとの接続を切断し、新たに発見されたピアを使用します。

[[network_handshake]]
.ピア間の初期ハンドシェイク
image::images/mbc3_1003.png["NetworkHandshake"]

一つ以上の接続が確立されると、新しいノードは自身の IP アドレスを含む +addr+ メッセージを隣接ノードに送信します。隣接ノードは、その +addr+ メッセージをさらに隣接ノードに転送し、新たに接続されたノードがよく知られ、より良く接続されるようにします。さらに、新たに接続されたノードは隣接ノードに +getaddr+ を送信し、他のピアの IP アドレスのリストを返すように要求することができます。これにより、ノードは接続するピアを見つけ、自身の存在をネットワーク上で宣伝し、他のノードがそれを見つけることができるようになります。<<address_propagation>> はアドレス発見プロトコルを示しています。

[[address_propagation]]
.アドレスの伝播と発見。
image::images/mbc3_1004.png["AddressPropagation"]

ノードは、ビットコインネットワークへの多様な経路を確立するために、いくつかの異なるピアに接続する必要があります。経路は信頼性がないため、ノードは古い接続を失うたびに新しいノードを発見し続ける必要があり、他のノードがブートストラップする際にも支援します。ブートストラップには一つの接続だけで十分です。最初のノードがそのピアノードへの紹介を提供し、そのピアがさらに紹介を提供できるからです。また、ネットワークリソースを無駄にするため、少数のノード以上に接続する必要はありません。ブートストラップ後、ノードは最近の成功したピア接続を記憶するので、再起動した場合でも、以前のピアネットワークとの接続を迅速に再確立できます。以前のピアのどれも接続要求に応答しない場合、ノードはシードノードを使用して再びブートストラップできます。

Bitcoin Core クライアントを実行しているノードでは、+getpeerinfo+ コマンドを使用してピア接続を一覧表示できます。

[source,bash]
----
$ bitcoin-cli getpeerinfo
----
[source,json]
----
[
  {
    "id": 0,
    "addr": "82.64.116.5:8333",
    "addrbind": "192.168.0.133:50564",
    "addrlocal": "72.253.6.11:50564",
    "network": "ipv4",
    "services": "0000000000000409",
    "servicesnames": [
      "NETWORK",
      "WITNESS",
      "NETWORK_LIMITED"
    ],
    "lastsend": 1683829947,
    "lastrecv": 1683829989,
    "last_transaction": 0,
    "last_block": 1683829989,
    "bytessent": 3558504,
    "bytesrecv": 6016081,
    "conntime": 1683647841,
    "timeoffset": 0,
    "pingtime": 0.204744,
    "minping": 0.20337,
    "version": 70016,
    "subver": "/Satoshi:24.0.1/",
    "inbound": false,
    "bip152_hb_to": true,
    "bip152_hb_from": false,
    "startingheight": 788954,
    "presynced_headers": -1,
    "synced_headers": 789281,
    "synced_blocks": 789281,
    "inflight": [
    ],
    "relaytxes": false,
    "minfeefilter": 0.00000000,
    "addr_relay_enabled": false,
    "addr_processed": 0,
    "addr_rate_limited": 0,
    "permissions": [
    ],
    "bytessent_per_msg": {
      ...
    },
    "bytesrecv_per_msg": {
      ...
    },
    "connection_type": "block-relay-only"
  },
]
----

ピアの自動管理をオーバーライドして IP アドレスのリストを指定するには、ユーザはオプション +-connect=<IPAddress>+ を提供し、1 つ以上の IP アドレスを指定できます。このオプションを使用すると、ノードは選択された IP アドレスにのみ接続し、自動的にピア接続を発見および維持することはありません。

接続にトラフィックがない場合、ノードは定期的にメッセージを送信して接続を維持します。ノードが接続上で長時間通信していない場合、切断されたと見なされ、新しいピアが探されます。このようにして、ネットワークは一時的なノードやネットワークの問題に動的に適応し、必要に応じて有機的に成長および縮小することができます。これは、中央制御なしで行われます。

### フルノード

フルノードは、最も多くのプルーフ・オブ・ワークを持つ有効なブロックチェーン上のすべてのブロック内のすべてのトランザクションを検証するノードです。

フルノードは、最初のブロック（ジェネシスブロック）の後から始まり、ネットワーク内で最新の既知のブロックまで、すべてのブロックを独立して処理します。フルノードは、任意のトランザクションを独立して権威を持って検証できます。フルノードは、トランザクションの新しいブロックに関する更新を受け取るためにネットワークに依存し、それを検証して、どのスクリプトがどのビットコインを制御しているかのローカルビューに組み込みます。これを _未使用トランザクション出力_ (UTXO) のセットと呼びます。

フルノードを実行することで、他のシステムに依存したり信頼したりすることなく、すべてのトランザクションを独立して検証するという純粋なビットコイン体験を得ることができます。

フルノードのいくつかの代替実装があり、異なるプログラミング言語やソフトウェアアーキテクチャを使用して構築されたものや、異なる設計上の決定を行ったものがあります。しかし、最も一般的な実装は Bitcoin Core です。ビットコインネットワーク上のフルノードの 95% 以上が、さまざまなバージョンの Bitcoin Core を実行しています。それは、+version+ メッセージで送信されるサブバージョン文字列で「Satoshi」として識別され、以前に見たように +getpeerinfo+ コマンドで表示されます。例えば、[.keep-together]#+/Satoshi:24.0.1/+# です。

=== 「インベントリ」の交換

フルノードがピアに接続すると、最初に行うことはブロックヘッダの完全なチェーンを構築しようとすることです。もしそれが全く新しいノードで、ブロックチェーンを全く持っていない場合、唯一知っているブロックはクライアントソフトウェアに静的に埋め込まれているジェネシスブロックだけです。ブロック #0（ジェネシスブロック）の後から、新しいノードはネットワークと同期し、完全なブロックチェーンを再構築するために数十万のブロックをダウンロードしなければなりません。

ブロックチェーンの同期プロセスは +version+ メッセージから始まります。これはノードの現在のブロックチェーンの高さ（ブロック数）を示す +BestHeight+ を含んでいるからです。ノードはピアからの +version+ メッセージを見て、それぞれのピアが何ブロック持っているかを知り、自分のブロックチェーンにあるブロック数と比較することができます。ピアノードは、ローカルブロックチェーンのトップブロックのハッシュを含む +getheaders+ メッセージを交換します。ピアの一つは、受け取ったハッシュがトップではなく、古いブロックに属していることを識別できるため、自分のローカルブロックチェーンがリモートノードのブロックチェーンよりも長いことを推測します。

より長いブロックチェーンを持つピアは、他のノードよりも多くのブロックを持っており、他のノードが「追いつく」ために必要なヘッダを特定できます。+headers+ メッセージを使用して、共有する最初の 2,000 ヘッダを特定します。ノードは、リモートピアが持っていると主張するすべてのブロックに対してヘッダを受け取るまで、追加のヘッダを要求し続けます。

並行して、ノードは以前に受け取った各ヘッダに対してブロックを +getdata+ メッセージを使用して要求し始めます。ノードは選択した各ピアから異なるブロックを要求し、平均よりも著しく遅いピアへの接続を切断して、新しい（そしておそらくより速い）ピアを見つけることができます。

例えば、ノードがジェネシスブロックしか持っていないと仮定します。この場合、ノードはピアからチェーン内の次の2,000ブロックのヘッダーを含む +headers+ メッセージを受け取ります。ノードは接続されているすべてのピアからブロックを要求し始め、最大1,024ブロックのキューを保持します。ブロックは順番に検証する必要があるため、キュー内の最も古いブロック（ノードが次に検証する必要があるブロック）がまだ受信されていない場合、ノードはそのブロックを提供するはずだったピアとの接続を切断します。その後、ノードは他のすべてのピアが1,023ブロックを提供する前に1ブロックを提供できる新しいピアを見つけます。

各ブロックが受信されると、それは <<blockchain>> で見るようにブロックチェーンに追加されます。ローカルブロックチェーンが徐々に構築されるにつれて、さらに多くのブロックが要求され受信され、このプロセスはノードがネットワークの他の部分に追いつくまで続きます。

ローカルブロックチェーンをピアと比較し、欠落しているブロックを取得するこのプロセスは、ノードが長期間オフラインになっていた場合にいつでも発生します((("Bitcoin network", "nodes", "syncing blockchain", startref="bitcoin-network-node-sync")))((("nodes", "syncing blockchain", startref="node-sync")))((("full nodes", "syncing blockchain", startref="full-node-sync")))((("blockchain", "syncing", startref="blockchain-sync")))((("syncing blockchain", startref="sync-blockchain")))。

[[spv_nodes]]
=== 軽量クライアント

多くの((("Bitcoin network", "lightweight clients", id="bitcoin-network-lightweight")))((("lightweight clients", id="lightweight")))((("SPV (simplified-payment-verification) clients", id="spv-lightweight")))Bitcoinクライアントは、スマートフォン、タブレット、または組み込みシステムなどのスペースと電力が制約されたデバイスで動作するように設計されています。このようなデバイスのために、_簡易支払い検証_ (SPV) メソッドが使用され、完全なブロックチェーンを検証せずに動作できるようにします。このタイプのクライアントは軽量クライアントと呼ばれます。

軽量クライアントはブロックヘッダーのみをダウンロードし、各ブロックに含まれるトランザクションはダウンロードしません。トランザクションを含まないヘッダーのチェーンは、完全なブロックチェーンの約10,000分の1のサイズです。軽量クライアントは、ネットワーク上のすべてのトランザクションを知らないため、利用可能なすべてのUTXOの完全な画像を構築することはできません。代わりに、ピアが要求に応じてブロックチェーンの関連部分の部分的なビューを提供する方法を使用してトランザクションを検証します。

たとえるなら、フルノードは見知らぬ街を訪れる観光客のようなもので、すべての通りと住所が詳細に記された地図を持っています。それに対して、軽量クライアントは、見知らぬ街で主要な通りだけを知っている状態で、道行く人に道順を尋ねる観光客のようなものです。どちらの観光客も通りの存在を訪れることで確認できますが、地図を持たない観光客は、脇道に何があるのか、他にどんな通りがあるのかを知りません。23 Church Street の前に立っている地図を持たない観光客は、その街に他に 12 件の「23 Church Street」住所があるかどうか、そしてそれが正しい場所かどうかを知ることができません。地図を持たない観光客の最善の方法は、十分な人数に尋ねて、誰かが彼を襲おうとしていないことを願うことです。

軽量クライアントは、ブロックチェーン内のトランザクションの「深さ」を参照してトランザクションを検証します。フルノードは、ジェネシスブロックまでさかのぼる何千ものブロックと何百万ものトランザクションを完全に検証されたチェーンとして構築しますが、軽量クライアントはすべてのブロックのプルーフ・オブ・ワークを検証し（ただし、ブロックとそのすべてのトランザクションが有効かどうかは検証しません）、そのチェーンを関心のあるトランザクションにリンクします。

たとえば、ブロック 800,000 のトランザクションを調べるとき、フルノードはジェネシスブロックまでの 800,000 ブロックすべてを検証し、UTXO の完全なデータベースを構築し、トランザクションが存在し、その出力が未使用であることを確認することでトランザクションの有効性を確立します。軽量クライアントは、トランザクションが存在することしか確認できません。クライアントは、トランザクションとそれを含むブロックとの間に _マークルパス_（<<merkle_trees>> を参照）を使用してリンクを確立します。そして、軽量クライアントは、トランザクションを含むブロックの上に 800,001 から 800,006 までの 6 つのブロックが積み重なるのを待ち、ブロック 800,006 から 800,001 の下にある深さを確立することでそれを検証します。ネットワーク上の他のノードがブロック 800,000 を受け入れ、マイナーがその上にさらに 6 つのブロックを生成するために必要な作業を行ったという事実は、代理として、そのトランザクションが実際に存在することの証明です。

軽量クライアントは、通常、トランザクションが実際には存在しないブロックに存在すると説得されることはありません。軽量クライアントは、マークルパス証明を要求し、ブロックチェーン内のプルーフ・オブ・ワークを検証することで、ブロック内のトランザクションの存在を確認します。しかし、軽量クライアントからトランザクションの存在を「隠す」ことは可能です。軽量クライアントは、トランザクションが存在することを確実に確認できますが、同じ UTXO の二重支払いのようなトランザクションが存在しないことを確認することはできません。なぜなら、すべてのトランザクションの記録を持っていないからです。この脆弱性は、軽量クライアントに対するサービス拒否攻撃や二重支払い攻撃に利用される可能性があります。これを防ぐために、軽量クライアントはランダムに複数のクライアントに接続し、少なくとも1つの正直なノードと接触している可能性を高める必要があります。このランダム接続の必要性は、軽量クライアントがネットワーク分割攻撃やシビル攻撃に対して脆弱であることも意味します。これらの攻撃では、偽のノードや偽のネットワークに接続され、正直なノードや実際のビットコインネットワークにアクセスできなくなります。

多くの実用的な目的において、十分に接続された軽量クライアントは、リソースの必要性、実用性、セキュリティのバランスを取ることで十分に安全です。しかし、完璧なセキュリティを求めるなら、フルノードを実行することに勝るものはありません。

[TIP]
====
フルノードは、UTXO が存在し、使用されていないことを保証するために、その下にある数千のブロック全体をチェックすることでトランザクションを検証します。一方、軽量クライアントは、トランザクションが存在することを証明し、そのトランザクションを含むブロックが上にあるいくつかのブロックによって埋められていることを確認するだけです。
====

トランザクションがチェーンの一部であることを確認するために必要なブロックヘッダーを取得するために、軽量クライアントは +getheaders+ メッセージを使用します。応答するピアは、単一の +headers+ メッセージを使用して最大 2,000 のブロックヘッダーを送信します。<<spv_synchronization>> の図を参照してください。

[[spv_synchronization]]
.ブロックヘッダーを同期する軽量クライアント。
image::images/mbc3_1005.png["Header synchronization"]

ブロックヘッダーは、軽量クライアントが任意の個別のブロックが最も多くのプルーフ・オブ・ワークを持つブロックチェーンに属していることを確認するのに役立ちますが、どのブロックがそのウォレットにとって興味深いトランザクションを含んでいるかをクライアントに教えることはありません。クライアントはすべてのブロックをダウンロードして確認することもできますが、それではフルノードを運用するのに必要なリソースの大部分を使用してしまうため、開発者たちはこの問題を解決する他の方法を模索してきました。

軽量クライアントの導入後まもなく、ビットコインの開発者たちは、軽量クライアントが送受信するトランザクションについて学ぶために必要な帯域幅を削減する試みとして、_ブルームフィルタ_ という機能を追加しました。ブルームフィルタは、軽量クライアントが興味のあるアドレスを正確に明かすことなく、トランザクションのサブセットを受け取ることを可能にします。これは、確定的なパターンではなく確率を用いたフィルタリングメカニズムを通じて行われます。

[[bloom_filters]]
=== ブルームフィルタ

ブルームフィルタは、確率的な検索フィルタであり、正確に指定することなく望ましいパターンを記述する方法です。ブルームフィルタは、検索パターンを効率的に表現しながらプライバシーを保護する手段を提供します。軽量クライアントは、特定のパターンに一致するトランザクションをピアに求める際に、どのアドレス、キー、またはトランザクションを探しているのかを正確に明かすことなく使用します。

以前のアナロジーでは、地図を持たない観光客が特定の住所「23 Church St.」への道順を尋ねているとします。もし彼らがこの通りへの道順を見知らぬ人に尋ねると、意図せずに目的地を明かしてしまいます。ブルームフィルタは、「この近所に名前が R-C-H で終わる通りはありますか？」と尋ねるようなものです。このような質問は、「23 Church St.」を尋ねるよりも目的地について少しだけ情報を明かします。この技術を使うことで、観光客は「U-R-C-H で終わる」や「H で終わる」など、望む住所をより詳細に、またはより少ない詳細で指定することができます。検索の精度を変えることで、観光客はより多くまたは少ない情報を明かし、より具体的または少ない具体的な結果を得ることができます。より少ない具体的なパターンを尋ねると、より多くの可能性のある住所を得てプライバシーが向上しますが、多くの結果が無関係になります。非常に具体的なパターンを尋ねると、結果は少なくなりますが、プライバシーを失います。

Bloomフィルタは、軽量クライアントがトランザクションの検索パターンを指定することを可能にし、精度やプライバシーに応じて調整できるようにすることで、この機能を果たします。より具体的なBloomフィルタは正確な結果をもたらしますが、その代償として軽量クライアントが関心を持っているパターンを明らかにし、ユーザのウォレットが所有するアドレスを明らかにしてしまいます。逆に、あまり具体的でないBloomフィルタは、クライアントにとって無関係な多くのトランザクションに関するデータを生成しますが、クライアントはより良いプライバシーを維持することができます。

==== Bloomフィルタの仕組み

Bloomフィルタは、N個のバイナリ桁（ビットフィールド）からなる可変サイズの配列と、M個の可変数のハッシュ関数として実装されます。ハッシュ関数は常に1からNの間の出力を生成するように設計されており、バイナリ桁の配列に対応しています。ハッシュ関数は決定論的に生成されるため、Bloomフィルタを実装するクライアントは常に同じハッシュ関数を使用し、特定の入力に対して同じ結果を得ることができます。異なる長さ（N）のBloomフィルタと異なる数（M）のハッシュ関数を選択することで、Bloomフィルタは調整可能であり、精度とプライバシーのレベルを変えることができます。

<<bloom1>>では、Bloomフィルタの仕組みを示すために、16ビットの非常に小さな配列と3つのハッシュ関数のセットを使用しています。

[[bloom1]]
.16ビットフィールドと3つのハッシュ関数を持つ単純なBloomフィルタの例。
image::images/mbc3_1006.png["Bloom1"]

Bloomフィルタは、ビットの配列がすべてゼロで初期化されます。Bloomフィルタにパターンを追加するには、そのパターンを順に各ハッシュ関数でハッシュします。最初のハッシュ関数を入力に適用すると、1からNの間の数が得られます。配列内の対応するビット（1からNまでのインデックス）が見つかり、+1+に設定され、ハッシュ関数の出力が記録されます。その後、次のハッシュ関数を使用して別のビットを設定し、これを繰り返します。すべてのM個のハッシュ関数が適用されると、検索パターンはBloomフィルタ内で+0+から+1+に変更されたM個のビットとして「記録」されます。

<<bloom2>>は、<<bloom1>>で示された単純なBloomフィルタにパターン「A」を追加する例です。

2 つ目のパターンを追加するのは、このプロセスを繰り返すだけで簡単です。パターンはそれぞれのハッシュ関数によって順にハッシュ化され、その結果はビットを +1+ に設定することで記録されます。ブルームフィルタにより多くのパターンが追加されると、ハッシュ関数の結果がすでに +1+ に設定されているビットと一致することがあります。この場合、そのビットは変更されません。基本的に、より多くのパターンが重複するビットに記録されると、ブルームフィルタは +1+ に設定されたビットが増え、フィルタの精度が低下し始めます。これがフィルタが確率的データ構造である理由です。パターンが追加されるほど精度が低下します。精度は、追加されたパターンの数とビット配列のサイズ (N) およびハッシュ関数の数 (M) に依存します。より大きなビット配列と多くのハッシュ関数は、より多くのパターンを高い精度で記録できます。より小さなビット配列や少ないハッシュ関数は、記録できるパターンが少なくなり、精度も低くなります。

[[bloom2]]
.単純なブルームフィルタにパターン "A" を追加する。
image::images/mbc3_1007.png["Bloom2"]

<<bloom3>> は、単純なブルームフィルタに 2 つ目のパターン "B" を追加する例です。

[[bloom3]]
.単純なブルームフィルタに 2 つ目のパターン "B" を追加する。
image::images/mbc3_1008.png["Bloom3"]

[role="less_space pagebreak-before"]
パターンがブルームフィルタの一部であるかどうかをテストするには、パターンをそれぞれのハッシュ関数でハッシュ化し、得られたビットパターンをビット配列と照合します。ハッシュ関数によってインデックスされたすべてのビットが +1+ に設定されている場合、そのパターンはブルームフィルタに _おそらく_ 記録されています。ビットは複数のパターンの重複によって設定される可能性があるため、答えは確実ではなく、むしろ確率的です。簡単に言えば、ブルームフィルタのポジティブマッチは「たぶん、はい」です。

<<bloom4>> は、単純なブルームフィルタでパターン "X" の存在をテストする例です。対応するビットが +1+ に設定されているため、パターンはおそらく一致しています。

[[bloom4]]
.ブルームフィルタでパターン "X" の存在をテストする。結果は確率的なポジティブマッチで、「たぶん」を意味します。
image::images/mbc3_1009.png["Bloom4"]

逆に、パターンがブルームフィルタに対してテストされ、ビットのいずれかが +0+ に設定されている場合、そのパターンはブルームフィルタに記録されていないことが証明されます。否定的な結果は確率ではなく、確実性です。簡単に言えば、ブルームフィルタでの否定的な一致は「絶対に違う！」ということです。

<<bloom5>> は、シンプルなブルームフィルタでパターン "Y" の存在をテストする例です。対応するビットの一つが +0+ に設定されているため、そのパターンは確実に一致しません。

[[bloom5]]
.ブルームフィルタでパターン "Y" の存在をテストします。結果は明確な否定的な一致で、「絶対に違う！」という意味です。
image::images/mbc3_1010.png[]

==== 軽量クライアントがブルームフィルタを使用する方法

ブルームフィルタ ((("Bitcoinネットワーク", "ブルームフィルタ", "軽量クライアントと", id="bitcoin-network-bloom-lightweight")))((("ブルームフィルタ", "軽量クライアントと", id="bloom-lightweight")))((("軽量クライアント", "ブルームフィルタと", id="lightweight-bloom")))は、軽量クライアントがピアから受け取るトランザクション（およびそれを含むブロック）をフィルタリングし、軽量クライアントにとって興味のあるトランザクションのみを選択し、どのアドレスやキーに興味があるかを正確に明かさないようにします。

軽量クライアントはブルームフィルタを「空」として初期化します。その状態では、ブルームフィルタはどのパターンとも一致しません。軽量クライアントは次に、興味のあるすべてのアドレス、キー、およびハッシュのリストを作成します。これは、ウォレットが管理する任意のUTXOから公開鍵ハッシュ、スクリプトハッシュ、およびトランザクションIDを抽出することによって行います。軽量クライアントは次に、これらの各項目をブルームフィルタに追加し、これらのパターンがトランザクションに存在する場合にブルームフィルタが「一致」するようにしますが、パターン自体は明かしません。

軽量クライアントは次に、接続で使用するブルームフィルタを含む +filterload+ メッセージをピアに送信します。ピアでは、ブルームフィルタが各受信トランザクションに対してチェックされます。フルノードは、ブルームフィルタに対して一致を探すために、トランザクションのいくつかの部分をチェックします。

++++
<ul>
<li>トランザクション ID</li>
<li>各トランザクション出力のスクリプトからのデータコンポーネント（スクリプト内のすべてのキーとハッシュ）</li>
<li class="less_space pagebreak-before">各トランザクション入力</li>
<li>各入力の署名データコンポーネント（またはウィットネススクリプト）</li>
</ul>
++++

これらすべてのコンポーネントをチェックすることで、ブルームフィルタを使用して公開鍵ハッシュ、スクリプト、+OP_RETURN+ 値、署名内の公開鍵、またはスマートコントラクトや複雑なスクリプトの将来のコンポーネントを一致させることができます。

フィルタが設定されると、ピアは各トランザクションの出力をブルームフィルタに対してテストします。フィルタに一致するトランザクションのみがクライアントに送信されます。

クライアントからの +getdata+ メッセージに応答して、ピアはフィルタに一致するブロックのブロックヘッダと各一致するトランザクションのマークルパス（<<merkle_trees>> を参照）を含む +merkleblock+ メッセージを送信します。その後、ピアはフィルタに一致したトランザクションを含む +tx+ メッセージも送信します。

フルノードがトランザクションを軽量クライアントに送信すると、軽量クライアントは誤検知を破棄し、正しく一致したトランザクションを使用して UTXO セットとウォレット残高を更新します。UTXO セットの自身のビューを更新するとき、見つけたばかりの UTXO を参照する将来のトランザクションに一致するようにブルームフィルタも変更します。その後、フルノードは新しいブルームフィルタを使用して新しいトランザクションに一致させ、このプロセス全体が繰り返されます。

ブルームフィルタを設定するクライアントは、+filteradd+ メッセージを送信することでフィルタにパターンをインタラクティブに追加できます。ブルームフィルタをクリアするには、クライアントは +filterclear+ メッセージを送信できます。ブルームフィルタからパターンを削除することはできないため、パターンが不要になった場合、クライアントはフィルタをクリアして新しいブルームフィルタを再送信する必要があります。

軽量クライアントのためのネットワークプロトコルとブルームフィルタメカニズムは BIP37 で定義されています。

残念ながら、ブルームフィルタの展開後、それらがあまりプライバシーを提供しないことが明らかになりました。ピアからブルームフィルタを受け取ったフルノードは、そのフィルタをブロックチェーン全体に適用してクライアントのすべてのトランザクション（および誤検知）を見つけることができました。そして、トランザクション間のパターンや関係を探すことができました。ランダムに選ばれた誤検知トランザクションは、出力から入力への親子関係を持つ可能性が低いですが、ユーザのウォレットからのトランザクションはその関係を持つ可能性が非常に高いです。すべての関連トランザクションが特定の特徴（少なくとも 1 つの P2PKH 出力など）を持っている場合、その特徴を持たないトランザクションはウォレットに属していないと推測できます。

特別に構築されたフィルタが、処理するフルノードに大量の作業を強いることができることも発見されました。これにより、サービス拒否攻撃が引き起こされる可能性があります。

これらの理由から、Bitcoin Core は最終的にブルームフィルタのサポートを、ノードオペレータによって明示的に許可された IP アドレスのクライアントに限定しました。これにより、軽量クライアントがトランザクションを見つけるのを助けるための代替方法が必要になりました。

=== コンパクトブロックフィルタ

// https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012636.html

2016年に匿名の開発者が Bitcoin-Dev メーリングリストに投稿したアイデアは、ブルームフィルタプロセスを逆転させるものでした。BIP37 ブルームフィルタでは、各クライアントがアドレスをハッシュしてブルームフィルタを作成し、ノードが各トランザクションの一部をハッシュしてそのフィルタに一致させようとします。新しい提案では、ノードがブロック内の各トランザクションの一部をハッシュしてブルームフィルタを作成し、クライアントがアドレスをハッシュしてそのフィルタに一致させようとします。クライアントが一致を見つけた場合、彼らはブロック全体をダウンロードします。

[NOTE]
====
名前の類似性にもかかわらず、BIP152 の _コンパクトブロック_ と BIP157/158 の _コンパクトブロックフィルタ_ は無関係です。
====

これにより、ノードは各ブロックに対して単一のフィルタを作成し、それをディスクに保存して何度も提供することができ、BIP37 のサービス拒否の脆弱性を排除します。クライアントは、過去または将来のアドレスに関する情報をフルノードに提供しません。彼らは、クライアントによって作成されていない何千ものトランザクションを含む可能性のあるブロックのみをダウンロードします。彼らは、各一致するブロックを異なるピアからダウンロードすることもでき、複数のブロックにわたって単一のクライアントに属するトランザクションをフルノードが接続するのを難しくします。

このサーバ生成フィルタのアイデアは完璧なプライバシーを提供するものではありません。依然としてフルノードにいくらかのコストをかけることになり、軽量クライアントがブロックダウンロードのためにより多くの帯域幅を使用する必要があります。また、フィルタは確認済みトランザクションにしか使用できません（未確認トランザクションには使用できません）。しかし、これは BIP37 のクライアント要求型ブルームフィルタよりもはるかにプライベートで信頼性があります。

ブルームフィルタに基づく元のアイデアの説明の後、開発者たちはサーバ生成フィルタにより適したデータ構造があることに気づきました。それが Golomb-Rice Coded Sets (GCS) と呼ばれるものです。

==== Golomb-Rice Coded Sets (GCS)

アリスがボブに数字のリストを送りたいとします。単純な方法は、彼に数字のリスト全体を送ることです。

```
849
653
476
900
379
```

しかし、もっと効率的な方法があります。まず、アリスはリストを数値順に並べます。

```
379
476
653
849
900
```

次に、アリスは最初の数字を送ります。残りの数字については、その数字と前の数字との差を送ります。例えば、2 番目の数字については 97 (476 – 379) を送ります。3 番目の数字については 177 (653 – 476) を送ります。以下同様です。

```
379
97
177
196
51
```

順序付けられたリストの中で二つの数字の差を取ると、元の数字よりも短い数字が得られることがわかります。このリストを受け取ったボブは、各数字をその前の数字に足すことで元のリストを再構築できます。つまり、情報を失うことなくスペースを節約できるのです。これは「ロスレスエンコーディング」と呼ばれます。

固定範囲内でランダムに数字を選ぶと、選ぶ数字が多いほど、差の平均サイズは小さくなります。つまり、データを転送するために必要な量は、リストの長さが増えるにつれて（ある程度まで）急激には増えません。

さらに便利なことに、差のリストにおけるランダムに選ばれた数の長さは、自然に小さい長さに偏ります。1 から 6 までのランダムな数を 2 つ選ぶことを考えてみましょう。これはサイコロを 2 つ振るのと同じです。サイコロ 2 つの組み合わせは 36 通りあります。

[cols="1,1,1,1,1,1"]
|===
| 1 1 | 1 2 | 1 3 | 1 4 | 1 5 | 1 6
| 2 1 | 2 2 | 2 3 | 2 4 | 2 5 | 2 6
| 3 1 | 3 2 | 3 3 | 3 4 | 3 5 | 3 6
| 4 1 | 4 2 | 4 3 | 4 4 | 4 5 | 4 6
| 5 1 | 5 2 | 5 3 | 5 4 | 5 5 | 5 6
| 6 1 | 6 2 | 6 3 | 6 4 | 6 5 | 6 6
|===

次に、数の大きい方と小さい方の差を求めてみましょう。

[role="less_space pagebreak-before"]
[cols="1,1,1,1,1,1"]
|===
| 0 | 1 | 2 | 3 | 4 | 5
| 1 | 0 | 1 | 2 | 3 | 4
| 2 | 1 | 0 | 1 | 2 | 3
| 3 | 2 | 1 | 0 | 1 | 2
| 4 | 3 | 2 | 1 | 0 | 1
| 5 | 4 | 3 | 2 | 1 | 0
|===

各差が発生する頻度を数えると、小さい差の方が大きい差よりもはるかに発生しやすいことがわかります。

++++
<table>

<thead>
<tr>
<th>Difference</th>
<th>Occurrences</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>0</p></td>
<td><p>6</p></td>
</tr>
<tr>
<td><p>1</p></td>
<td><p>10</p></td>
</tr>
<tr>
<td><p>2</p></td>
<td><p>8</p></td>
</tr>
<tr>
<td><p>3</p></td>
<td><p>6</p></td>
</tr>
<tr>
<td><p>4</p></td>
<td><p>4</p></td>
</tr>
<tr>
<td><p>5</p></td>
<td><p>2</p></td>
</tr>
</tbody>
</table>
++++

大きな差が発生する可能性があるため（たとえそれが稀であっても）、大きな数を保存する必要があるかもしれないとわかっている場合でも、ほとんどの場合は小さな数を保存する必要があります。そこで、小さな数には少ないスペースを、大きな数には余分なスペースを使用するシステムで各数をエンコードすることができます。平均すると、そのシステムはすべての数に同じ量のスペースを使用するよりも効率的に動作します。

Golomb コーディングはその機能を提供します。Rice コーディングは Golomb コーディングのサブセットであり、特定の状況でより便利に使用できます。例えば、Bitcoin のアプリケーションにおけるコンパクトブロックフィルタ ((("Bitcoin network", "compact block filters", "GCS (Golomb-Rice coded sets)", startref="bitcoin-network-compact-filter-gcs")))((("compact block filters", "GCS (Golomb-Rice coded sets)", startref="compact-block-filter-gcs")))((("blocks", "compact block filters", "GCS (Golomb-Rice coded sets)", startref="block-compact-filter-gcs")))((("GCS (Golomb-Rice coded sets)", startref="gcs-filter"))) においてです。


==== ブロックフィルターに含めるデータ

私たちの主な目標は、ウォレットがそのウォレットに影響を与えるトランザクションを含むブロックを学習できるようにすることです。ウォレットが効果的に機能するためには、次の 2 種類の情報を学習する必要があります。

お金を受け取ったとき：

具体的には、トランザクションの出力がウォレットが管理するスクリプトを含むとき（たとえば、認証された秘密鍵を管理することによって）

お金を使ったとき：

具体的には、トランザクションの入力がウォレットが管理していた以前のトランザクションの出力を参照するとき

コンパクトブロックフィルターの設計における二次的な目標は、フィルターを受け取ったウォレットがピアから正確なフィルターを受け取ったことを検証できるようにすることでした。たとえば、ウォレットがフィルターが作成されたブロックをダウンロードした場合、ウォレットは自分自身でフィルターを生成できます。その後、自分のフィルターをピアのフィルターと比較し、それらが同一であることを確認することで、ピアが正確なフィルターを生成したことを証明できます。

主目標と二次目標の両方を達成するために、フィルターは次の 2 種類の情報を参照する必要があります。

* ブロック内のすべてのトランザクションのすべての出力に対するスクリプト

* ブロック内のすべてのトランザクションのすべての入力に対するアウトポイント

コンパクトブロックフィルターの初期設計にはこれらの情報が含まれていましたが、二次目標を犠牲にすれば、主目標をより効率的に達成できる方法があることがわかりました。新しい設計では、ブロックフィルターは依然として 2 種類の情報を参照しますが、より密接に関連しています。

* 以前と同様に、ブロック内のすべてのトランザクションのすべての出力に対するスクリプト。

* 変更点として、ブロック内のすべてのトランザクションのすべての入力に対するアウトポイントが参照する出力のスクリプト、つまり消費される出力スクリプトも参照します。

これはいくつかの利点がありました。まず、ウォレットがアウトポイントを追跡する必要がなくなり、代わりにお金を受け取ることを期待する出力スクリプトをスキャンするだけで済むようになりました。次に、ブロック内の後のトランザクションが同じブロック内の前のトランザクションの出力を消費するたびに、両方とも同じ出力スクリプトを参照します。コンパクトブロックフィルタでは、同じ出力スクリプトへの複数の参照は冗長であるため、冗長なコピーを削除してフィルタのサイズを縮小できます。

フルノードがブロックを検証する際には、ブロック内の現在のトランザクション出力と、入力で参照されている以前のブロックのトランザクション出力の両方の出力スクリプトにアクセスする必要があります。この簡略化されたモデルでコンパクトブロックフィルタを構築できるようにするためです。しかし、ブロック自体には以前のブロックに含まれるトランザクションの出力スクリプトが含まれていないため、クライアントがブロックフィルタが正しく構築されたかどうかを検証する便利な方法はありません。しかし、ピアが嘘をついているかどうかをクライアントが検出するのに役立つ代替手段があります。それは、複数のピアから同じフィルタを取得することです。

==== 複数のピアからのブロックフィルタのダウンロード

ピアはウォレットに不正確なフィルタを提供することができます。不正確なフィルタを作成する方法は二つあります。ピアは、関連するブロックに実際には存在しないトランザクションを参照するフィルタを作成することができます（偽陽性）。または、関連するブロックに実際に存在するトランザクションを参照しないフィルタを作成することもできます（偽陰性）。

クライアントが不正確なフィルタに対する最初の防御策は、複数のピアからフィルタを取得することです。BIP157プロトコルでは、クライアントがフィルタに対する短い32バイトのコミットメントをダウンロードして、各ピアがクライアントの他のすべてのピアと同じフィルタを広告しているかどうかを確認することができます。これにより、すべてのピアが同意している場合に、クライアントがフィルタを問い合わせるために消費する帯域幅の量が最小限に抑えられます。

もし、同じブロックに対して異なるフィルタを持つピアが2つ以上ある場合、クライアントはそれらすべてをダウンロードすることができます。その後、関連するブロックもダウンロードできます。もしブロックにウォレットに関連するトランザクションが含まれていて、それがフィルタの一部でない場合、ウォレットはそのフィルタを作成したピアが不正確であったことを確信できます。Golomb-Rice Coded Setsは常に潜在的な一致を含むからです。

あるいは、ブロックにフィルタがウォレットに一致するかもしれないと示したトランザクションが含まれていない場合、それはフィルタが不正確であった証拠にはなりません。GCSのサイズを最小限に抑えるために、一定数の偽陽性を許容しています。ウォレットができることは、ランダムにまたは一致を示したときにピアから追加のフィルタをダウンロードし続け、クライアントの偽陽性率を追跡することです。もしそれがフィルタが設計された偽陽性率と大きく異なる場合、ウォレットはそのピアの使用を停止することができます。ほとんどの場合、不正確なフィルタの唯一の結果は、ウォレットが予想以上に多くの帯域幅を使用することです。

==== 帯域幅を削減するためのロッシーエンコーディング

ブロック内のトランザクションに関するデータは、出力スクリプトです。出力スクリプトは長さが異なり、パターンに従います。つまり、それらの違いは均等に分布しません。しかし、この本の多くの場所で既に見たように、ハッシュ関数を使用してデータに対するコミットメントを作成し、ランダムに選択された数のように見える値を生成することができます。

この本の他の箇所では、コミットメントの強度やランダム性からの識別不可能性について保証を提供する暗号学的に安全なハッシュ関数を使用してきました。しかし、より高速で設定可能な非暗号学的ハッシュ関数も存在します。たとえば、コンパクトブロックフィルタに使用する SipHash 関数などです。

使用されるアルゴリズムの詳細は BIP158 に記載されていますが、要点としては、各出力スクリプトが SipHash といくつかの算術演算を使用して 64 ビットのコミットメントに縮小されるということです。これは、大きな数のセットを取り、それを短い数に切り詰めるプロセスと考えることができます。このプロセスはデータを失うため、_ロッシーエンコーディング_ と呼ばれます。情報を一部失うことで、後で保存する情報が少なくて済み、スペースを節約できます。この場合、通常の出力スクリプトが 160 ビット以上からわずか 64 ビットに縮小されます。

==== コンパクトブロックフィルタの使用

ブロック内の出力スクリプトへの各コミットメントの 64 ビット値はソートされ、重複するエントリが削除され、各エントリ間の差分 (デルタ) を見つけることで GCS が構築されます。そのコンパクトブロックフィルタは、ピアによってクライアント (ウォレットなど) に配布されます。

クライアントはデルタを使用して元のコミットメントを再構築します。ウォレットのようなクライアントは、監視しているすべての出力スクリプトを取り、BIP158 と同じ方法でコミットメントを生成します。そして、生成されたコミットメントのいずれかがフィルタ内のコミットメントと一致するかどうかを確認します。

コンパクトブロックフィルタのロス性が数値を切り詰めることに似ているという例を思い出してください。クライアントが 123456 を含むブロックを探していて、正確 (だがロスのある) なコンパクトブロックフィルタが 1234 を含んでいると想像してください。クライアントが 1234 を見つけたとき、その関連するブロックをダウンロードします。

1234 を含む正確なフィルタが 123456 を含むブロックについてクライアントに知らせることができるという 100% の保証があります。これを _真陽性_ と呼びます。しかし、ブロックが 123400 や 123401、またはクライアントが探しているものではないほぼ 100 の他のエントリを含む可能性もあります (この例では)、これを _偽陽性_ と呼びます。

100% の真陽性一致率は素晴らしいことです。これは、ウォレットがコンパクトブロックフィルタに依存して、そのウォレットに影響を与えるすべてのトランザクションを見つけることができることを意味します。偽陽性率がゼロでない場合、ウォレットはそのウォレットにとって興味のないトランザクションを含まないブロックをいくつかダウンロードすることになります。これの主な結果は、クライアントが余分な帯域幅を使用することですが、これは大きな問題ではありません。BIP158 コンパクトブロックフィルタの実際の偽陽性率は非常に低いため、大きな問題ではありません。偽陽性率は、ブルームフィルタと同様にクライアントのプライバシーを向上させるのにも役立ちますが、可能な限り最高のプライバシーを望む人は、自分自身のフルノードを使用するべきです。

長期的には、いくつかの開発者はブロックがそのブロックのフィルタにコミットすることを提唱しています。最も可能性の高いスキームでは、各コインベーストランザクションがそのブロックのフィルタにコミットします。フルノードは各ブロックのフィルタを自分で計算し、正確なコミットメントを含むブロックのみを受け入れます。これにより、軽量クライアントは 80 バイトのブロックヘッダ、（通常は）小さなコインベーストランザクション、およびそのブロックのフィルタをダウンロードして、フィルタが正確であるという強力な証拠を受け取ることができます。

[role="less_space pagebreak-before"]
=== 軽量クライアントとプライバシー

軽量クライアントは、フルノードよりもプライバシーが弱いです。フルノードはすべてのトランザクションをダウンロードするため、ウォレットでいくつかのアドレスを使用しているかどうかについての情報を一切明らかにしません。軽量クライアントは、ウォレットに関連するトランザクションのみをダウンロードします。

ブルームフィルタとコンパクトブロックフィルタは、プライバシーの損失を減らす方法です。これらがなければ、軽量クライアントは興味のあるアドレスを明示的にリストする必要があり、深刻なプライバシーの侵害を引き起こします。しかし、フィルタを使用しても、軽量クライアントのトラフィックを監視する敵対者や、P2P ネットワーク内で直接接続しているノードは、時間をかけて十分な情報を収集し、軽量クライアントのウォレット内のアドレスを学習する可能性があります。


=== 暗号化された認証付き接続

ほとんどの新しい Bitcoin ユーザは、Bitcoin ノードのネットワーク通信が暗号化されていると想定します。実際には、Bitcoin の元の実装は完全にクリアな状態で通信を行い、執筆時点での Bitcoin Core の最新の実装も同様です。

Bitcoin P2P ネットワークのプライバシーとセキュリティを向上させる方法として、通信の暗号化を提供するソリューションがあります。それが _Tor トランスポート_ です。

Tor は、_The Onion Routing network_ の略で、匿名性、追跡不可能性、プライバシーを提供するランダム化されたネットワーク経路を通じてデータの暗号化とカプセル化を提供するソフトウェアプロジェクトおよびネットワークです。

Bitcoin Core は、Tor ネットワークを介してトラフィックを輸送する Bitcoin ノードを実行するためのいくつかの設定オプションを提供します。さらに、Bitcoin Core は他の Tor ノードが Tor を介して直接あなたのノードに接続できるようにする Tor 隠しサービスも提供できます。

Bitcoin Core バージョン 0.12 以降では、ローカルの Tor サービスに接続できる場合、ノードは自動的に隠し Tor サービスを提供します。Tor がインストールされており、Bitcoin Core プロセスが Tor 認証クッキーにアクセスするための十分な権限を持つユーザとして実行されている場合、自動的に動作するはずです。次のように +debug+ フラグを使用して、Tor サービスの Bitcoin Core のデバッグをオンにしてください：

----
$ bitcoind --daemon --debug=tor
----

ログに ++tor: ADD_ONION successful++ と表示されるはずです。これは、Bitcoin Core が Tor ネットワークに隠しサービスを追加したことを示しています。

Bitcoin Core を Tor 隠しサービスとして実行するための詳細な手順は、Bitcoin Core のドキュメント (_docs/tor.md_) やさまざまなオンラインチュートリアルで見つけることができます。

[role="less_space pagebreak-before"]
[[mempool]]
=== メモリプールと孤立プール

ほぼすべての Bitcoin ノードは、_メモリプール_ (_mempool_) と呼ばれる未確認トランザクションの一時リストを維持しています。ノードはこのプールを使用して、ネットワークに知られているがまだブロックチェーンに含まれていないトランザクション、つまり _未確認トランザクション_ を追跡します。

未確認のトランザクションが受信され、検証されると、それらはメモリプールに追加され、ネットワーク上で伝播するために隣接するノードに中継されます。

一部のノード実装では、孤立トランザクションのための別のプールも維持しています。トランザクションの入力がまだ知られていないトランザクション（例えば、親トランザクションが欠けている場合）を参照している場合、その孤立トランザクションは親トランザクションが到着するまで一時的に孤立プールに保存されます。

トランザクションがメモリプールに追加されると、孤立プールがこのトランザクションの出力（その子トランザクション）を参照する孤立トランザクションがないかチェックされます。該当する孤立トランザクションが見つかると、それらは検証されます。有効であれば、孤立プールから削除され、メモリプールに追加され、親トランザクションから始まるチェーンが完成します。新たに追加されたトランザクション（もはや孤立していない）に照らして、このプロセスは再帰的に繰り返され、さらに子孫が見つかるまで続けられます。このプロセスを通じて、親トランザクションの到着は、孤立トランザクションを親と再結合させることで、相互依存するトランザクションの全チェーンの再構築を引き起こします。

一部の Bitcoin の実装では、ブロックチェーン上のすべての未使用出力のセットである UTXO データベースも維持しています。これはメモリプールとは異なるデータセットを表しています。メモリプールや孤立プールとは異なり、UTXO データベースにはジェネシスブロックからすべての未使用トランザクション出力の数百万のエントリが含まれています。UTXO データベースは永続的なストレージにテーブルとして保存されます。

メモリプールや孤立プールが単一ノードのローカルな視点を表し、ノードの起動や再起動のタイミングによってノードごとに大きく異なる可能性があるのに対し、UTXO データベースはネットワークの出現するコンセンサスを表しており、通常はノード間で異なることはありません。

ノードやクライアントが Bitcoin ネットワーク上でデータを送信するために使用する多くのデータ型や構造について理解したので、次はネットワークを安全かつ運用可能に保つためのソフトウェアを見ていきます。

ファイルが添付されていないようです。Markdown ファイルをアップロードしてください。
